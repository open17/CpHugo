<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Distcrete Structures on CpHugo</title><link>https://open17.github.io/CpHugo/tags/distcrete-structures/</link><description>Recent content in Distcrete Structures on CpHugo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 08 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://open17.github.io/CpHugo/tags/distcrete-structures/index.xml" rel="self" type="application/rss+xml"/><item><title>离散数学————Counting</title><link>https://open17.github.io/CpHugo/p/counting/</link><pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><guid>https://open17.github.io/CpHugo/p/counting/</guid><description>&lt;h2 id="basic-counting-principles">Basic Counting Principles&lt;/h2>
&lt;h3 id="the-product-rule">The product rule&lt;/h3>
&lt;p>乘法原理&lt;/p>
&lt;h4 id="exercise">Exercise&lt;/h4>
&lt;p>•Prove Theorem: $ if |S| = n, then |P(S)| = 2^n$&lt;/p>
&lt;h3 id="the-sum-rule">The sum rule&lt;/h3>
&lt;p>加法原理&lt;/p>
&lt;h3 id="the-inclusion-exclusion-principle">The Inclusion-Exclusion Principle&lt;/h3>
&lt;p>容斥原理&lt;/p>
&lt;h3 id="the-pigeonhole-principle">The Pigeonhole Principle&lt;/h3>
&lt;p>抽屉原理&lt;/p>
&lt;h4 id="theorem-1">Theorem 1:&lt;/h4>
&lt;p>If k is a positive integer and k + 1 or more objects are placed into k boxes, then there is at least one box containing two or more of the objects.&lt;/p>
&lt;h4 id="theorem-2">Theorem 2:&lt;/h4>
&lt;p>If n objects are placed into k boxes, then there is at least one box containing at least n/k objects.&lt;/p>
&lt;h2 id="permutation">Permutation&lt;/h2>
&lt;p>排列（考虑顺序）
$P(n, r) = n!/(n − r)!$&lt;/p>
&lt;h2 id="combination">Combination&lt;/h2>
&lt;p>组合（不考虑顺序）
$C(n, r), or (^n_r)$&lt;/p>
&lt;h3 id="隔板法">隔板法&lt;/h3>
&lt;p>How many solutions does the equation a + b + c = 11
have where a, b, and c are non-negative integers?&lt;/p>
&lt;h2 id="binomial-coefficients">Binomial Coefficients&lt;/h2>
&lt;p>二项式定理： &lt;br>
&lt;img src="https://bkimg.cdn.bcebos.com/formula/90e7897708ac2d3e2619efc1fd9071ff.svg"
loading="lazy"
alt="公式"
>&lt;/p>
&lt;h2 id="recurrence-relations">Recurrence Relations&lt;/h2>
&lt;h3 id="linear-homogeneous-recurrence-relation">Linear Homogeneous recurrence relation&lt;/h3>
&lt;p>Theorem 1: &lt;br>
Let $c_1$ and $c_2$ be real numbers. Suppose that $r^2 – c_1 – c_2 = 0$ has two distinct roots $r_1$ and $r_2$. Then the sequence ${a_n}$ is a solution of the recurrence relation $a_n= c_1a_{n-1} + c_2a_{n-2}$ if and only if $a_n= k_1r_1^n+k_2r_2^n$ for $n = 0, 1, 2, …,$ where $k_1$ and $k_2$ are constants.&lt;/p></description></item><item><title>离散数学——Relations</title><link>https://open17.github.io/CpHugo/p/distcreterelations/</link><pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate><guid>https://open17.github.io/CpHugo/p/distcreterelations/</guid><description>&lt;img src="https://img0.baidu.com/it/u=1209717743,1836540112&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="Featured image of post 离散数学——Relations" />&lt;blockquote>
&lt;p>A relation is a structure that is used to represent the relationships between elements&lt;/p>
&lt;/blockquote>
&lt;h2 id="category-of-relations">Category of relations&lt;/h2>
&lt;ul>
&lt;li>Binary relations&lt;/li>
&lt;li>N-ary relations&lt;/li>
&lt;/ul>
&lt;h2 id="binary-relations">Binary Relations&lt;/h2>
&lt;p>A binary relation R from the set 𝐴 to the set 𝐵 is a subset of 𝐴 × 𝐵.&lt;/p>
&lt;p>R is a set of ordered pairs in the form (𝑎, 𝑏) where 𝑎 is from 𝐴 and 𝑏 is from 𝐵.&lt;/p>
&lt;p>a R b denotes (𝑎, 𝑏) ∈ 𝑅, called 𝑎 is related to 𝑏 by R&lt;/p>
&lt;h2 id="functions-and-relations">Functions and Relations&lt;/h2>
&lt;ul>
&lt;li>Are all the functions relations? Yes&lt;/li>
&lt;li>Are all relations functions? No&lt;/li>
&lt;/ul>
&lt;h2 id="relation-on-the-set">Relation on the Set&lt;/h2>
&lt;ul>
&lt;li>A relation on the set is a relation from 𝐴 to 𝐴.&lt;/li>
&lt;/ul>
&lt;h2 id="properties-of-relations">Properties of Relations&lt;/h2>
&lt;h3 id="reflexive">Reflexive&lt;/h3>
&lt;p>A relation 𝑅 on a set 𝐴 is called reflexive if (𝑎, 𝑎) ∈ 𝑅 for every element 𝑎 ∈ A&lt;/p>
&lt;h3 id="symmetric">Symmetric&lt;/h3>
&lt;p>A relation 𝑅 on a set 𝐴 is called symmetric if (𝑏, 𝑎) ∈ 𝑅 whenever (𝑎, 𝑏) ∈ R&lt;/p>
&lt;h3 id="anti-symmetric">Anti-symmetric&lt;/h3>
&lt;p>relation 𝑅 on a set 𝐴 is called anti-symmetric if whenever (𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑎) ∈ 𝑅, then 𝑎 = 𝑏&lt;/p>
&lt;h3 id="transitive">Transitive&lt;/h3>
&lt;p>A relation 𝑅 on a set 𝐴 is called transitive if whenever
(𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑐) ∈ 𝑅, then (𝑎, 𝑐) ∈ 𝑅&lt;/p>
&lt;h2 id="combining-relations">Combining Relations&lt;/h2>
&lt;p>The composite of 𝑅 and 𝑆 (𝑆 ◦ 𝑅): consisting of all ordered pairs (𝑎, 𝑐) where 𝑎 ∈ 𝐴, and 𝑐 ∈ 𝐶 if there exists 𝑏 such that (𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑐) ∈ 𝑆.&lt;/p>
&lt;blockquote>
&lt;p>E.g.,&lt;br>
▪ 𝐴 = {1}, 𝐵 = {0, 1}, 𝐶 = {2, 3}&lt;br>
▪ 𝑅 = {(1, 0), (1, 1)} (a relation from 𝐴 to 𝐵)&lt;br>
▪ 𝑆 = {(0, 2), (1, 3)} (a relation from 𝐵 to 𝐶)&lt;br>
▪ 𝑆 ◦ 𝑅 = {(1, 2), (1, 3)}&lt;/p>
&lt;/blockquote>
&lt;h2 id="powers-of-a-relation">Powers of a Relation&lt;/h2>
&lt;p>Let 𝑅 be a relation on the set 𝐴. The powers 𝑅𝑛
for integer 𝑛
with 𝑛 &amp;gt; 0 are defined recursively by
$R^1 = R$&lt;br>
$R^{n}=R^{n-1}◦R$&lt;/p>
&lt;blockquote>
&lt;p>Theorem: The relation 𝑅 on a set 𝐴 is transitive if and only if 𝑅^𝑛 ⊆ 𝑅 for 𝑛 = 1, 2, 3, ⋯&lt;/p>
&lt;/blockquote>
&lt;h2 id="𝑛-ary-relations">𝑛-ary Relations&lt;/h2>
&lt;ul>
&lt;li>Let 𝐴1, 𝐴2, … , 𝐴𝑛 be sets.&lt;/li>
&lt;li>An 𝑛-ary relation on these sets is a subset of 𝐴1 × 𝐴2 × ⋯ × 𝐴𝑛&lt;/li>
&lt;li>Domain: 𝐴1 × 𝐴2 × ⋯ × 𝐴𝑛&lt;/li>
&lt;li>Degree: n&lt;/li>
&lt;/ul>
&lt;h2 id="relations-and-database">Relations and Database&lt;/h2>
&lt;ul>
&lt;li>Currently, the most commonly used databases are relational databases.&lt;/li>
&lt;li>Each database consists of multiple relations.&lt;/li>
&lt;li>Each relation is presented as a table.&lt;/li>
&lt;/ul>
&lt;h2 id="operations-on-n-ary-relations">Operations on n-ary Relations&lt;/h2>
&lt;h3 id="selection-operator-𝜎">Selection operator 𝜎:&lt;/h3>
&lt;ul>
&lt;li>𝑛-ary relation 𝑅&lt;/li>
&lt;li>condition 𝑐&lt;/li>
&lt;li>Selection operator 𝜎𝑐: maps 𝑅 to an 𝑛-ary relations 𝑇, where all the tuples in 𝑇 satisfy the condition 𝑐.&lt;br>
i.e. 𝜎_{𝑚𝑎𝑗𝑜𝑟}=&amp;ldquo;𝐶𝑜𝑚𝑝𝑢𝑡𝑒𝑟 𝑆𝑐𝑖𝑒𝑛𝑐𝑒&amp;rdquo; 𝐺𝑟𝑎𝑑𝑒𝑅𝑒𝑝𝑜𝑟𝑡 = {(𝐽𝑜ℎ𝑛,001,𝐶𝑜𝑚𝑝𝑢𝑡𝑒𝑟 𝑆𝑐𝑖𝑒𝑛𝑐𝑒, 3.5)}&lt;/li>
&lt;/ul>
&lt;h3 id="projection-operator-𝜋">Projection operator 𝜋:&lt;/h3>
&lt;ul>
&lt;li>the input relation is on 𝑛 tuples (𝑎1, 𝑎2, ⋯ , 𝑎𝑛) ,&lt;/li>
&lt;li>the output relation is on 𝑚 tuples (𝑎𝑖_1,𝑎𝑖_2, ⋯ , 𝑎𝑖_𝑚), 𝑚 &amp;lt; 𝑛.&lt;/li>
&lt;li>Projection operator 𝜋𝑖1,𝑖2,⋯,𝑖𝑚: removes the tuples not in the 𝑚-tuple (𝑎𝑖1𝑎𝑖2, ⋯ , 𝑎𝑖𝑚) list
i.e. 𝜋_{𝑛𝑎𝑚𝑒,𝐺𝑃𝐴} (𝐺𝑟𝑎𝑑𝑒𝑅𝑒𝑝𝑜𝑟𝑡) = {(𝐽𝑜ℎ𝑛, 3.5 ),( 𝑇𝑜𝑛𝑦, 3.2 ),( 𝐽𝑜𝑛𝑎𝑠, 3.3)}&lt;/li>
&lt;/ul>
&lt;h2 id="equivalence-relations">Equivalence Relations&lt;/h2>
&lt;ul>
&lt;li>A relation on a set 𝐴 is called an equivalence relation if it is reflexive, symmetric, and transitive.
Let 𝑅 be an equivalence relation on 𝐴.&lt;/li>
&lt;/ul>
&lt;h3 id="equivalent-class">Equivalent class&lt;/h3>
&lt;p>Equivalent class -&amp;gt; Equivalent relations&lt;/p>
&lt;h3 id="partition">Partition&lt;/h3>
&lt;ul>
&lt;li>All the equivalent classes obtained from 𝐴 through an equivalent class are either same or disjoint.&lt;/li>
&lt;li>These disjoint classes are subsets of 𝐴.&lt;/li>
&lt;li>The union of these subsets is 𝐴.&lt;/li>
&lt;li>These subsets are called a partition of A
In general, (𝐴1, 𝐴2, ⋯ , 𝐴𝑛) is a partition of 𝐴 if:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>𝐴𝑖 ≠ ∅ for all 1 ≤ 𝑖 ≤ 𝑛&lt;/li>
&lt;li>𝐴𝑖 ∩ 𝐴𝑗 = ∅ for all 1 ≤ 𝑖,𝑗 ≤ 𝑛&lt;/li>
&lt;li>𝐴1 ∪ 𝐴2 ∪ ⋯ ∪ 𝐴𝑛 = A&lt;/li>
&lt;/ol>
&lt;h3 id="theorem-let-𝑅-be-an-equivalence-relation-on-a-nonempty-set-𝐴">Theorem: Let 𝑅 be an equivalence relation on a nonempty set 𝐴.&lt;/h3>
&lt;p>The following statements are equivalent:&lt;/p>
&lt;ul>
&lt;li>a R b&lt;/li>
&lt;li>[𝑎] = [𝑏]&lt;/li>
&lt;li>𝑎 ∩ [𝑏] ≠ ∅&lt;/li>
&lt;/ul></description></item><item><title>离散数学——SFSS</title><link>https://open17.github.io/CpHugo/p/sfss/</link><pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate><guid>https://open17.github.io/CpHugo/p/sfss/</guid><description>&lt;h2 id="sets">Sets&lt;/h2>
&lt;ul>
&lt;li>A set is a collection of objects&lt;/li>
&lt;li>Sets are used to group objects together&lt;/li>
&lt;/ul>
&lt;h3 id="three-ways-to-express-the-members-in-a-set">Three ways to express the members in a set&lt;/h3>
&lt;pre>&lt;code>- List all the members
- Use predicates
- Use suspension(省略号)points(must be inferred)
&lt;/code>&lt;/pre>
&lt;h3 id="universal-set">universal set&lt;/h3>
&lt;ul>
&lt;li>$ℕ$ : the set of all natural numbers&lt;/li>
&lt;li>$ℤ$ : the set of integers&lt;/li>
&lt;li>$ℤ^+$ : the set of all the positive integers&lt;/li>
&lt;li>$ℚ$: the set of all rational numbers&lt;/li>
&lt;li>$ℝ$: the set of all the real numbers&lt;/li>
&lt;li>$ℂ$: the set of all complex numbers&lt;/li>
&lt;/ul>
&lt;h3 id="venn-diagrams">Venn Diagrams&lt;/h3>
&lt;ul>
&lt;li>two basic shapes
&lt;ul>
&lt;li>A rectangle: indicates the universal set&lt;/li>
&lt;li>Circles or other shapes: indicate normal sets&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="elements-and-sets">Elements and Sets&lt;/h3>
&lt;ul>
&lt;li>$A∈B$ : A is in or is an element of B&lt;/li>
&lt;li>$A∉B$ : A is not in or is not an element of B&lt;/li>
&lt;/ul>
&lt;h3 id="subsets">Subsets&lt;/h3>
&lt;ul>
&lt;li>Subsets&lt;/li>
&lt;li>Proper subsets(真子集)&lt;/li>
&lt;li>Empty sets&lt;/li>
&lt;/ul>
&lt;h3 id="cardinality">Cardinality&lt;/h3>
&lt;p>number of distinct elements in a set&lt;br>
The cardinality of a set s is denoted as |s|&lt;/p>
&lt;h3 id="power-sets">Power Sets&lt;/h3>
&lt;p>$P(S) = {A|A ⊆ S}$&lt;/p>
&lt;h4 id="theorem-of-power-sets">Theorem of Power Sets:&lt;/h4>
&lt;p>$ if |S| = n, then |P(S)| = 2^n$&lt;/p>
&lt;h3 id="ordered-n-tuple">Ordered n-tuple&lt;/h3>
&lt;ul>
&lt;li>The form (1, 2, … , ) or &amp;lt; 1, 2, … , &amp;gt;&lt;/li>
&lt;li>(1,2) not equal to (2,1)&lt;/li>
&lt;/ul>
&lt;h3 id="cartesian-product笛卡尔乘积">Cartesian Product(笛卡尔乘积)&lt;/h3>
&lt;p>Cartesian product of $S_1, S_2, ⋯ ,S_n (denoted S_1 × S_2 × ⋯ ×S_n )$ &lt;br>
$S_1 × S_2 × ⋯ ×S_n = {(a1, a2, … ,an )|a_1 ∈ S_1 ∧ a_2 ∈ S_2 ∧⋯ ∧ a_n ∈ S_n}$&lt;/p>
&lt;h3 id="disjoint-sets">Disjoint Sets&lt;/h3>
&lt;ul>
&lt;li>If A ∩ B = ∅ then A and B are disjoint.&lt;/li>
&lt;li>If A ∩ B ≠ ∅ then A and B are overlapped.&lt;/li>
&lt;/ul>
&lt;h2 id="function">function&lt;/h2>
&lt;h3 id="conditions">conditions&lt;/h3>
&lt;blockquote>
&lt;p>A function from to is a subset of × which satisfies
the following two conditions&lt;/p>
&lt;/blockquote>
&lt;p>1.$ ∀ x(x ∈ A → ∃ y(y ∈ B ∧ (x,y) ∈f)) $&lt;br>
2. $ (((x_1,y_1 ) ∈ f ∧ (x_1,y_2 ) ∈ f) → y_1 = y_2)$&lt;/p>
&lt;h3 id="image-pre-image-and-range值域">Image, Pre-image and Range(值域)&lt;/h3>
&lt;p>If $y = f(x)$ from set A to set B, then&lt;/p>
&lt;ul>
&lt;li>y is called the image of x under f&lt;/li>
&lt;li>x is called a pre-image of y&lt;/li>
&lt;li>the set of all the images of the elements in the domain under is called the range of f, f(A) = {f(x)|x ∈ A}&lt;/li>
&lt;/ul>
&lt;h3 id="injective-function单射">injective function（单射）&lt;/h3>
&lt;p>f is one-to-one&lt;/p>
&lt;h3 id="urjective-function-满射">urjective function (满射)&lt;/h3>
&lt;p>Onto function :$∀y ∈ B (∃x(x ∈A ∧f (x) =y ))$&lt;/p>
&lt;h3 id="bijective-function-双射">bijective function (双射)&lt;/h3>
&lt;p>[One-to-One and onto function] is also called bijective function&lt;/p>
&lt;h3 id="floor-functions">Floor functions&lt;/h3>
&lt;ul>
&lt;li>Denoted $\lfloor x \rfloor$&lt;/li>
&lt;li>The largest integer less than or equivalent to x&lt;/li>
&lt;/ul>
&lt;h3 id="ceiling-functions">Ceiling functions&lt;/h3>
&lt;ul>
&lt;li>Denoted $\lceil x \rceil$&lt;/li>
&lt;li>The smallest integer greater than or equivalent to x&lt;/li>
&lt;/ul>
&lt;h2 id="sequences-数列">Sequences 数列&lt;/h2>
&lt;p>Sequences are ordered lists of elements
• A sequence is a function from a subset of the set of integers
({0, 1, 2, 3, … } or {1, 2, 3, … }) to a set , denoted {$a_n$}. The
integers determine the positions of the elements in the list&lt;/p>
&lt;h2 id="summations-求和">Summations 求和&lt;/h2>
&lt;p>A summation is the value of the sum of the terms of a sequence.&lt;/p>
&lt;h3 id="special-summations">Special Summations&lt;/h3>
&lt;h4 id="geometric-series-等比数列和">Geometric series 等比数列和&lt;/h4>
&lt;p>$\sum^n_{j=0}ar^j$&lt;/p>
&lt;h4 id="harmonic-series">harmonic series&lt;/h4>
&lt;p>$\sum^n_{j=1} \frac{1}{j}$&lt;/p></description></item><item><title>离散数学————Graph</title><link>https://open17.github.io/CpHugo/p/dmgraph/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://open17.github.io/CpHugo/p/dmgraph/</guid><description>&lt;h2 id="graph-theory">Graph Theory&lt;/h2>
&lt;h3 id="graph-concepts">Graph concepts&lt;/h3>
&lt;h4 id="definition1">Definition1&lt;/h4>
&lt;p>A graph G = (V,E) is a pair and consists of two sets V and such that:&lt;/p>
&lt;ul>
&lt;li>V is the set of vertices(顶点)&lt;/li>
&lt;li>E is the set of edges(边)&lt;/li>
&lt;/ul>
&lt;h4 id="remember">Remember&lt;/h4>
&lt;ol>
&lt;li>V cannot be empty,but E can(endpoint/node)&lt;/li>
&lt;li>Each edge have 1 or 2 vertices(1 is a ring)&lt;/li>
&lt;/ol>
&lt;h4 id="definition2">Definition2&lt;/h4>
&lt;ul>
&lt;li>(u,v) is an edge connetcing vettices u and v&lt;/li>
&lt;li>u and v are neighbors (adjacent).&lt;/li>
&lt;li>(u,v) connects u and v ((u,v) is incident on u and v).&lt;/li>
&lt;/ul>
&lt;h4 id="simple-graphs">Simple graphs&lt;/h4>
&lt;ul>
&lt;li>each edge connects two different vertices and&lt;/li>
&lt;li>where no two edges connect the same pair of vertices.&lt;/li>
&lt;/ul>
&lt;h4 id="multigraph">Multigraph&lt;/h4>
&lt;ul>
&lt;li>A multigraph is a graph that may have multiple edges connecting the same pair of vertices.&lt;/li>
&lt;li>If there are m different edges associated to the same unordered pair of vertices u and v, (u, v) is an edge of multiplicity.&lt;/li>
&lt;/ul>
&lt;h4 id="loops自环">Loops(自环)&lt;/h4>
&lt;ul>
&lt;li>A loop is an edge that connects one vertex to itself.&lt;/li>
&lt;li>Graphs that may include loops, and possibly multiples edges connecting the same pair of vertices are called &lt;em>&lt;strong>pseudo-graphs&lt;/strong>&lt;/em>.&lt;/li>
&lt;/ul>
&lt;h4 id="directed-graph有向图">Directed Graph(有向图)&lt;/h4>
&lt;p>A directed graph (V,E) consists of a nonempty set V and a
set of directed edges E&lt;/p>
&lt;h4 id="tips">tips&lt;/h4>
&lt;p>The edge (u,v) in a directed graph starts at u and ends at v.&lt;/p>
&lt;h4 id="degree度">Degree(度)&lt;/h4>
&lt;p>The degree of a vertex in an undirected graph is the number of edges connected with it except that a loop at a vertex(自环算2)contribute twice to the degree of that vertex.&lt;/p>
&lt;h5 id="in-degree-and-out-degree入度出度">In-Degree and Out-Degree(入度、出度)&lt;/h5>
&lt;p>$In:def^-(v)$&lt;br>
$Out:def^+(v)$&lt;/p>
&lt;h3 id="handshaking-theorem">Handshaking Theorem&lt;/h3>
&lt;p>For an undirected graph G= (V,E):&lt;br>
$$2|E|=\sum_{v \in V}deg(v)$$&lt;/p>
&lt;h3 id="odd-degree-theorem">Odd Degree Theorem&lt;/h3>
&lt;p>In a directed graph G = (V,E)
$$|E|=\sum_{v \in V}deg^-(v)=\sum_{v \in V}deg^+(v)$$&lt;/p>
&lt;h3 id="special-graphs">Special graphs&lt;/h3>
&lt;h4 id="complete-graphs完全图">Complete graphs(完全图)&lt;/h4>
&lt;p>A complete graph is a simple graph in which there is an edge between each pair of distinct vertices, denoted by $K_n$ where n is the number of nodes in the graph&lt;/p>
&lt;h4 id="cycles">Cycles&lt;/h4>
&lt;p>A cycle is a graph that contains (n ≥ 3) vertices {V1, V2, … ,Vn } and n edges (V1, V2), (V2, V3), …, (Vn, V1), denoted by $C_n$ where is the number of nodes in the graph.&lt;/p>
&lt;h4 id="wheels">Wheels&lt;/h4>
&lt;p>$Cn$加上中间一个点以及连边，记做$W_n$&lt;/p>
&lt;h4 id="cubes">Cubes&lt;/h4>
&lt;p>A cube of dimension n($Q_n$)is a simple graph of $2^n$ vertices, where each vertex represents a bit string of length n. Two vertices are adjacent if and only if they differ by one bit.&lt;/p>
&lt;h4 id="bipartite-graphs二分图">Bipartite Graphs(二分图)&lt;/h4>
&lt;ul>
&lt;li>A simple graph G = (V,E ) is called bipartite if its vertex set V can be partitioned into two disjoint set V1 and V2 such that every edge in the graph connects a vertex in V1 and a vertex in V2.&lt;/li>
&lt;li>V1 and V2 are called a bipartite of the vertex set V of G&lt;/li>
&lt;/ul>
&lt;h4 id="theorem染色法">Theorem(染色法)&lt;/h4>
&lt;p>前置知识：二分图不存在奇数环&lt;br>
A simple graph G= (V,E) is bipartite if and only if it is
possible to color each vertex with one of two colors so that no
adjacent vertices have the same color.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// n表示点数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">M&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ne&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">M&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">idx&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 邻接表存储图
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 参数：u表示当前节点，c表示当前点的颜色
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">bool&lt;/span> &lt;span class="nf">dfs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">u&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">color&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ne&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">dfs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">bool&lt;/span> &lt;span class="nf">check&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">++&lt;/span> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">dfs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//source：https://www.acwing.com/blog/content/405/
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="complete-bipartite-graphs完全二分图">Complete Bipartite Graphs(完全二分图)&lt;/h4>
&lt;p>$K_{m,n} $&lt;br>
In a complete bipartite graph, for any vertex in a subset,there is an edge between it and each vertex in another set.&lt;/p>
&lt;h4 id="outline">Outline&lt;/h4>
&lt;p>&lt;img src="http://ask.qcloudimg.com/http-save/yehe-8904777/6fb1fc6209cd5933717fbc5da940c425.png?imageView2/2/w/1200"
loading="lazy"
alt="图片"
>&lt;/p>
&lt;h3 id="subgraphs-and-proper-subgraphs">Subgraphs and Proper Subgraphs&lt;/h3>
&lt;ul>
&lt;li>A subgraph H = (W,F) of graph G = (V,E) is made up of vertices W ⊆ V and edges F ⊆ E.&lt;/li>
&lt;li>A subgraph H of G is a proper subgraph if H ≠ G.&lt;/li>
&lt;/ul>
&lt;h3 id="union-of-simple-graphs">Union of Simple Graphs&lt;/h3>
&lt;p>The union of two simple graphs G1 = (V1, E1) and G2 = (V2, E2) is the simple graph G = (V, E) such that V = V1 ∪ V2 and E = E1 ∪ E2&lt;/p>
&lt;h3 id="representing-graphs">Representing Graphs&lt;/h3>
&lt;ul>
&lt;li>Adjacency matrix(邻接矩阵):dense graph&lt;/li>
&lt;li>Adjacency table(邻接表):sparse graph&lt;/li>
&lt;/ul>
&lt;h3 id="graph-isomorphism同构图">Graph Isomorphism(同构图)&lt;/h3>
&lt;p>判断同构：推荐使用邻接矩阵判断&lt;/p>
&lt;h3 id="graph-connectivity">Graph Connectivity&lt;/h3>
&lt;h4 id="path">Path&lt;/h4>
&lt;p>path of length m from vertexu to vertex v is a sequence of edges e1, e2, … , $e_n$ such that e1 starts at u and $e_n$ ends at v.&lt;/p>
&lt;h4 id="circuit">Circuit&lt;/h4>
&lt;p>A circuit is a path that begins and ends at the same vertex in graph.&lt;/p>
&lt;h4 id="simple-path-or-circuit">Simple path or circuit&lt;/h4>
&lt;p>A simple path or circuit does not pass through the same edge twice or more.&lt;/p>
&lt;h3 id="graph-connectedness">Graph Connectedness&lt;/h3>
&lt;ul>
&lt;li>An undirected graph is connected if there is a path between every pair of distinct vertices&lt;/li>
&lt;li>A directed graph is &lt;strong>strongly connected&lt;/strong> if there is a path from a to b and from b to a whenever a and b are vertices in the graph&lt;/li>
&lt;/ul>
&lt;h3 id="euler-paths">Euler Paths&lt;/h3>
&lt;ul>
&lt;li>An Euler path in G is a &lt;em>simple&lt;/em> path containing every edge of G&lt;/li>
&lt;li>An Euler circuit in a graph G is a &lt;em>simple&lt;/em> circuit containing every edge of G&lt;/li>
&lt;/ul>
&lt;h4 id="theorem">THEOREM&lt;/h4>
&lt;p>A connected multi-graph has an Euler circuit if and only if each vertex has even degree.&lt;/p>
&lt;h3 id="hamilton-circuits">Hamilton Circuits&lt;/h3>
&lt;ul>
&lt;li>A Hamilton path is a path that traverses each vertex in G exactly once&lt;/li>
&lt;li>A Hamilton circuit is a circuit that traverses each vertex in G exactly once.&lt;/li>
&lt;/ul>
&lt;h4 id="ores-theorem">Ore’s theorem&lt;/h4>
&lt;p>If for every pair of nonadjacent vertices u and v in the simple graph G with n vertices, deg(u) + deg(v) ≥ n ,then has a Hamilton circuit.&lt;/p>
&lt;h4 id="diracs-theorem">Dirac’s theorem&lt;/h4>
&lt;p>If the degree of each vertex is great than or equals n/2 in
the connected simple graph G with n vertices where n ≥ 3,
then G has a Hamilton circuit.&lt;/p>
&lt;h3 id="planar-graphs">Planar Graphs&lt;/h3>
&lt;p>In a planar representation of&lt;/p>
&lt;ul>
&lt;li>e: number of edges&lt;/li>
&lt;li>v: number of vertices&lt;/li>
&lt;li>r: number of regions&lt;/li>
&lt;li>$r= e – v + 2$&lt;/li>
&lt;/ul>
&lt;h4 id="eulers-formula">Euler’s Formula&lt;/h4>
&lt;blockquote>
&lt;p>G is a connected planar simple graph&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>v ≥ 3, then e ≤ 3v – 6&lt;/li>
&lt;li>G has a vertex of degree not exceeding 5&lt;/li>
&lt;li>if v&amp;gt;=3 and no circuits of length 3,then e&amp;lt;=2v-4&lt;/li>
&lt;/ul></description></item></channel></rss>