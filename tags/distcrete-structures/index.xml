<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Distcrete Structures on >>>>CpHugo&lt;&lt;&lt;&lt;</title><link>https://open17.github.io/CpHugo/tags/distcrete-structures/</link><description>Recent content in Distcrete Structures on >>>>CpHugo&lt;&lt;&lt;&lt;</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 08 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://open17.github.io/CpHugo/tags/distcrete-structures/index.xml" rel="self" type="application/rss+xml"/><item><title>离散数学————Counting</title><link>https://open17.github.io/CpHugo/p/counting/</link><pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate><guid>https://open17.github.io/CpHugo/p/counting/</guid><description>&lt;h2 id="basic-counting-principles">Basic Counting Principles&lt;/h2>
&lt;h3 id="the-product-rule">The product rule&lt;/h3>
&lt;p>乘法原理&lt;/p>
&lt;h4 id="exercise">Exercise&lt;/h4>
&lt;p>•Prove Theorem: $ if |S| = n, then |P(S)| = 2^n$&lt;/p>
&lt;h3 id="the-sum-rule">The sum rule&lt;/h3>
&lt;p>加法原理&lt;/p>
&lt;h3 id="the-inclusion-exclusion-principle">The Inclusion-Exclusion Principle&lt;/h3>
&lt;p>容斥原理&lt;/p>
&lt;h3 id="the-pigeonhole-principle">The Pigeonhole Principle&lt;/h3>
&lt;p>抽屉原理&lt;/p>
&lt;h4 id="theorem-1">Theorem 1:&lt;/h4>
&lt;p>If k is a positive integer and k + 1 or more objects are placed into k boxes, then there is at least one box containing two or more of the objects.&lt;/p>
&lt;h4 id="theorem-2">Theorem 2:&lt;/h4>
&lt;p>If n objects are placed into k boxes, then there is at least one box containing at least n/k objects.&lt;/p>
&lt;h2 id="permutation">Permutation&lt;/h2>
&lt;p>排列（考虑顺序）
$P(n, r) = n!/(n − r)!$&lt;/p>
&lt;h2 id="combination">Combination&lt;/h2>
&lt;p>组合（不考虑顺序）
$C(n, r), or (^n_r)$&lt;/p>
&lt;h3 id="隔板法">隔板法&lt;/h3>
&lt;p>How many solutions does the equation a + b + c = 11
have where a, b, and c are non-negative integers?&lt;/p>
&lt;h2 id="binomial-coefficients">Binomial Coefficients&lt;/h2>
&lt;p>二项式定理： &lt;br>
&lt;img src="https://bkimg.cdn.bcebos.com/formula/90e7897708ac2d3e2619efc1fd9071ff.svg"
loading="lazy"
alt="公式"
>&lt;/p>
&lt;h2 id="recurrence-relations">Recurrence Relations&lt;/h2>
&lt;h3 id="linear-homogeneous-recurrence-relation">Linear Homogeneous recurrence relation&lt;/h3>
&lt;p>Theorem 1: &lt;br>
Let $c_1$ and $c_2$ be real numbers. Suppose that $r^2 – c_1 – c_2 = 0$ has two distinct roots $r_1$ and $r_2$. Then the sequence ${a_n}$ is a solution of the recurrence relation $a_n= c_1a_{n-1} + c_2a_{n-2}$ if and only if $a_n= k_1r_1^n+k_2r_2^n$ for $n = 0, 1, 2, …,$ where $k_1$ and $k_2$ are constants.&lt;/p></description></item><item><title>离散数学——Relations</title><link>https://open17.github.io/CpHugo/p/distcreterelations/</link><pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate><guid>https://open17.github.io/CpHugo/p/distcreterelations/</guid><description>&lt;img src="https://img0.baidu.com/it/u=1209717743,1836540112&fm=253&fmt=auto&app=138&f=JPEG?w=889&h=500" alt="Featured image of post 离散数学——Relations" />&lt;blockquote>
&lt;p>A relation is a structure that is used to represent the relationships between elements&lt;/p>
&lt;/blockquote>
&lt;h2 id="category-of-relations">Category of relations&lt;/h2>
&lt;ul>
&lt;li>Binary relations&lt;/li>
&lt;li>N-ary relations&lt;/li>
&lt;/ul>
&lt;h2 id="binary-relations">Binary Relations&lt;/h2>
&lt;p>A binary relation R from the set 𝐴 to the set 𝐵 is a subset of 𝐴 × 𝐵.&lt;/p>
&lt;p>R is a set of ordered pairs in the form (𝑎, 𝑏) where 𝑎 is from 𝐴 and 𝑏 is from 𝐵.&lt;/p>
&lt;p>a R b denotes (𝑎, 𝑏) ∈ 𝑅, called 𝑎 is related to 𝑏 by R&lt;/p>
&lt;h2 id="functions-and-relations">Functions and Relations&lt;/h2>
&lt;ul>
&lt;li>Are all the functions relations? Yes&lt;/li>
&lt;li>Are all relations functions? No&lt;/li>
&lt;/ul>
&lt;h2 id="relation-on-the-set">Relation on the Set&lt;/h2>
&lt;ul>
&lt;li>A relation on the set is a relation from 𝐴 to 𝐴.&lt;/li>
&lt;/ul>
&lt;h2 id="properties-of-relations">Properties of Relations&lt;/h2>
&lt;h3 id="reflexive">Reflexive&lt;/h3>
&lt;p>A relation 𝑅 on a set 𝐴 is called reflexive if (𝑎, 𝑎) ∈ 𝑅 for every element 𝑎 ∈ A&lt;/p>
&lt;h3 id="symmetric">Symmetric&lt;/h3>
&lt;p>A relation 𝑅 on a set 𝐴 is called symmetric if (𝑏, 𝑎) ∈ 𝑅 whenever (𝑎, 𝑏) ∈ R&lt;/p>
&lt;h3 id="anti-symmetric">Anti-symmetric&lt;/h3>
&lt;p>relation 𝑅 on a set 𝐴 is called anti-symmetric if whenever (𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑎) ∈ 𝑅, then 𝑎 = 𝑏&lt;/p>
&lt;h3 id="transitive">Transitive&lt;/h3>
&lt;p>A relation 𝑅 on a set 𝐴 is called transitive if whenever
(𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑐) ∈ 𝑅, then (𝑎, 𝑐) ∈ 𝑅&lt;/p>
&lt;h2 id="combining-relations">Combining Relations&lt;/h2>
&lt;p>The composite of 𝑅 and 𝑆 (𝑆 ◦ 𝑅): consisting of all ordered pairs (𝑎, 𝑐) where 𝑎 ∈ 𝐴, and 𝑐 ∈ 𝐶 if there exists 𝑏 such that (𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑐) ∈ 𝑆.&lt;/p>
&lt;blockquote>
&lt;p>E.g.,&lt;br>
▪ 𝐴 = {1}, 𝐵 = {0, 1}, 𝐶 = {2, 3}&lt;br>
▪ 𝑅 = {(1, 0), (1, 1)} (a relation from 𝐴 to 𝐵)&lt;br>
▪ 𝑆 = {(0, 2), (1, 3)} (a relation from 𝐵 to 𝐶)&lt;br>
▪ 𝑆 ◦ 𝑅 = {(1, 2), (1, 3)}&lt;/p>
&lt;/blockquote>
&lt;h2 id="powers-of-a-relation">Powers of a Relation&lt;/h2>
&lt;p>Let 𝑅 be a relation on the set 𝐴. The powers 𝑅𝑛
for integer 𝑛
with 𝑛 &amp;gt; 0 are defined recursively by
$R^1 = R$&lt;br>
$R^{n}=R^{n-1}◦R$&lt;/p>
&lt;blockquote>
&lt;p>Theorem: The relation 𝑅 on a set 𝐴 is transitive if and only if 𝑅^𝑛 ⊆ 𝑅 for 𝑛 = 1, 2, 3, ⋯&lt;/p>
&lt;/blockquote>
&lt;h2 id="𝑛-ary-relations">𝑛-ary Relations&lt;/h2>
&lt;ul>
&lt;li>Let 𝐴1, 𝐴2, … , 𝐴𝑛 be sets.&lt;/li>
&lt;li>An 𝑛-ary relation on these sets is a subset of 𝐴1 × 𝐴2 × ⋯ × 𝐴𝑛&lt;/li>
&lt;li>Domain: 𝐴1 × 𝐴2 × ⋯ × 𝐴𝑛&lt;/li>
&lt;li>Degree: n&lt;/li>
&lt;/ul>
&lt;h2 id="relations-and-database">Relations and Database&lt;/h2>
&lt;ul>
&lt;li>Currently, the most commonly used databases are relational databases.&lt;/li>
&lt;li>Each database consists of multiple relations.&lt;/li>
&lt;li>Each relation is presented as a table.&lt;/li>
&lt;/ul>
&lt;h2 id="operations-on-n-ary-relations">Operations on n-ary Relations&lt;/h2>
&lt;h3 id="selection-operator-𝜎">Selection operator 𝜎:&lt;/h3>
&lt;ul>
&lt;li>𝑛-ary relation 𝑅&lt;/li>
&lt;li>condition 𝑐&lt;/li>
&lt;li>Selection operator 𝜎𝑐: maps 𝑅 to an 𝑛-ary relations 𝑇, where all the tuples in 𝑇 satisfy the condition 𝑐.&lt;br>
i.e. 𝜎_{𝑚𝑎𝑗𝑜𝑟}=&amp;ldquo;𝐶𝑜𝑚𝑝𝑢𝑡𝑒𝑟 𝑆𝑐𝑖𝑒𝑛𝑐𝑒&amp;rdquo; 𝐺𝑟𝑎𝑑𝑒𝑅𝑒𝑝𝑜𝑟𝑡 = {(𝐽𝑜ℎ𝑛,001,𝐶𝑜𝑚𝑝𝑢𝑡𝑒𝑟 𝑆𝑐𝑖𝑒𝑛𝑐𝑒, 3.5)}&lt;/li>
&lt;/ul>
&lt;h3 id="projection-operator-𝜋">Projection operator 𝜋:&lt;/h3>
&lt;ul>
&lt;li>the input relation is on 𝑛 tuples (𝑎1, 𝑎2, ⋯ , 𝑎𝑛) ,&lt;/li>
&lt;li>the output relation is on 𝑚 tuples (𝑎𝑖_1,𝑎𝑖_2, ⋯ , 𝑎𝑖_𝑚), 𝑚 &amp;lt; 𝑛.&lt;/li>
&lt;li>Projection operator 𝜋𝑖1,𝑖2,⋯,𝑖𝑚: removes the tuples not in the 𝑚-tuple (𝑎𝑖1𝑎𝑖2, ⋯ , 𝑎𝑖𝑚) list
i.e. 𝜋_{𝑛𝑎𝑚𝑒,𝐺𝑃𝐴} (𝐺𝑟𝑎𝑑𝑒𝑅𝑒𝑝𝑜𝑟𝑡) = {(𝐽𝑜ℎ𝑛, 3.5 ),( 𝑇𝑜𝑛𝑦, 3.2 ),( 𝐽𝑜𝑛𝑎𝑠, 3.3)}&lt;/li>
&lt;/ul>
&lt;h2 id="equivalence-relations">Equivalence Relations&lt;/h2>
&lt;ul>
&lt;li>A relation on a set 𝐴 is called an equivalence relation if it is reflexive, symmetric, and transitive.
Let 𝑅 be an equivalence relation on 𝐴.&lt;/li>
&lt;/ul>
&lt;h3 id="equivalent-class">Equivalent class&lt;/h3>
&lt;p>Equivalent class -&amp;gt; Equivalent relations&lt;/p>
&lt;h3 id="partition">Partition&lt;/h3>
&lt;ul>
&lt;li>All the equivalent classes obtained from 𝐴 through an equivalent class are either same or disjoint.&lt;/li>
&lt;li>These disjoint classes are subsets of 𝐴.&lt;/li>
&lt;li>The union of these subsets is 𝐴.&lt;/li>
&lt;li>These subsets are called a partition of A
In general, (𝐴1, 𝐴2, ⋯ , 𝐴𝑛) is a partition of 𝐴 if:&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>𝐴𝑖 ≠ ∅ for all 1 ≤ 𝑖 ≤ 𝑛&lt;/li>
&lt;li>𝐴𝑖 ∩ 𝐴𝑗 = ∅ for all 1 ≤ 𝑖,𝑗 ≤ 𝑛&lt;/li>
&lt;li>𝐴1 ∪ 𝐴2 ∪ ⋯ ∪ 𝐴𝑛 = A&lt;/li>
&lt;/ol>
&lt;h3 id="theorem-let-𝑅-be-an-equivalence-relation-on-a-nonempty-set-𝐴">Theorem: Let 𝑅 be an equivalence relation on a nonempty set 𝐴.&lt;/h3>
&lt;p>The following statements are equivalent:&lt;/p>
&lt;ul>
&lt;li>a R b&lt;/li>
&lt;li>[𝑎] = [𝑏]&lt;/li>
&lt;li>𝑎 ∩ [𝑏] ≠ ∅&lt;/li>
&lt;/ul></description></item><item><title>离散数学——SFSS</title><link>https://open17.github.io/CpHugo/p/sfss/</link><pubDate>Fri, 05 May 2023 00:00:00 +0000</pubDate><guid>https://open17.github.io/CpHugo/p/sfss/</guid><description>&lt;h2 id="sets">Sets&lt;/h2>
&lt;ul>
&lt;li>A set is a collection of objects&lt;/li>
&lt;li>Sets are used to group objects together&lt;/li>
&lt;/ul>
&lt;h3 id="three-ways-to-express-the-members-in-a-set">Three ways to express the members in a set&lt;/h3>
&lt;pre>&lt;code>- List all the members
- Use predicates
- Use suspension(省略号)points(must be inferred)
&lt;/code>&lt;/pre>
&lt;h3 id="universal-set">universal set&lt;/h3>
&lt;ul>
&lt;li>$ℕ$ : the set of all natural numbers&lt;/li>
&lt;li>$ℤ$ : the set of integers&lt;/li>
&lt;li>$ℤ^+$ : the set of all the positive integers&lt;/li>
&lt;li>$ℚ$: the set of all rational numbers&lt;/li>
&lt;li>$ℝ$: the set of all the real numbers&lt;/li>
&lt;li>$ℂ$: the set of all complex numbers&lt;/li>
&lt;/ul>
&lt;h3 id="venn-diagrams">Venn Diagrams&lt;/h3>
&lt;ul>
&lt;li>two basic shapes
&lt;ul>
&lt;li>A rectangle: indicates the universal set&lt;/li>
&lt;li>Circles or other shapes: indicate normal sets&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="elements-and-sets">Elements and Sets&lt;/h3>
&lt;ul>
&lt;li>$A∈B$ : A is in or is an element of B&lt;/li>
&lt;li>$A∉B$ : A is not in or is not an element of B&lt;/li>
&lt;/ul>
&lt;h3 id="subsets">Subsets&lt;/h3>
&lt;ul>
&lt;li>Subsets&lt;/li>
&lt;li>Proper subsets(真子集)&lt;/li>
&lt;li>Empty sets&lt;/li>
&lt;/ul>
&lt;h3 id="cardinality">Cardinality&lt;/h3>
&lt;p>number of distinct elements in a set&lt;br>
The cardinality of a set s is denoted as |s|&lt;/p>
&lt;h3 id="power-sets">Power Sets&lt;/h3>
&lt;p>$P(S) = {A|A ⊆ S}$&lt;/p>
&lt;h4 id="theorem-of-power-sets">Theorem of Power Sets:&lt;/h4>
&lt;p>$ if |S| = n, then |P(S)| = 2^n$&lt;/p>
&lt;h3 id="ordered-n-tuple">Ordered n-tuple&lt;/h3>
&lt;ul>
&lt;li>The form (1, 2, … , ) or &amp;lt; 1, 2, … , &amp;gt;&lt;/li>
&lt;li>(1,2) not equal to (2,1)&lt;/li>
&lt;/ul>
&lt;h3 id="cartesian-product笛卡尔乘积">Cartesian Product(笛卡尔乘积)&lt;/h3>
&lt;p>Cartesian product of $S_1, S_2, ⋯ ,S_n (denoted S_1 × S_2 × ⋯ ×S_n )$ &lt;br>
$S_1 × S_2 × ⋯ ×S_n = {(a1, a2, … ,an )|a_1 ∈ S_1 ∧ a_2 ∈ S_2 ∧⋯ ∧ a_n ∈ S_n}$&lt;/p>
&lt;h3 id="disjoint-sets">Disjoint Sets&lt;/h3>
&lt;ul>
&lt;li>If A ∩ B = ∅ then A and B are disjoint.&lt;/li>
&lt;li>If A ∩ B ≠ ∅ then A and B are overlapped.&lt;/li>
&lt;/ul>
&lt;h2 id="function">function&lt;/h2>
&lt;h3 id="conditions">conditions&lt;/h3>
&lt;blockquote>
&lt;p>A function from to is a subset of × which satisfies
the following two conditions&lt;/p>
&lt;/blockquote>
&lt;p>1.$ ∀ x(x ∈ A → ∃ y(y ∈ B ∧ (x,y) ∈f)) $&lt;br>
2. $ (((x_1,y_1 ) ∈ f ∧ (x_1,y_2 ) ∈ f) → y_1 = y_2)$&lt;/p>
&lt;h3 id="image-pre-image-and-range值域">Image, Pre-image and Range(值域)&lt;/h3>
&lt;p>If $y = f(x)$ from set A to set B, then&lt;/p>
&lt;ul>
&lt;li>y is called the image of x under f&lt;/li>
&lt;li>x is called a pre-image of y&lt;/li>
&lt;li>the set of all the images of the elements in the domain under is called the range of f, f(A) = {f(x)|x ∈ A}&lt;/li>
&lt;/ul>
&lt;h3 id="injective-function单射">injective function（单射）&lt;/h3>
&lt;p>f is one-to-one&lt;/p>
&lt;h3 id="urjective-function-满射">urjective function (满射)&lt;/h3>
&lt;p>Onto function :$∀y ∈ B (∃x(x ∈A ∧f (x) =y ))$&lt;/p>
&lt;h3 id="bijective-function-双射">bijective function (双射)&lt;/h3>
&lt;p>[One-to-One and onto function] is also called bijective function&lt;/p>
&lt;h3 id="floor-functions">Floor functions&lt;/h3>
&lt;ul>
&lt;li>Denoted $\lfloor x \rfloor$&lt;/li>
&lt;li>The largest integer less than or equivalent to x&lt;/li>
&lt;/ul>
&lt;h3 id="ceiling-functions">Ceiling functions&lt;/h3>
&lt;ul>
&lt;li>Denoted $\lceil x \rceil$&lt;/li>
&lt;li>The smallest integer greater than or equivalent to x&lt;/li>
&lt;/ul>
&lt;h2 id="sequences-数列">Sequences 数列&lt;/h2>
&lt;p>Sequences are ordered lists of elements
• A sequence is a function from a subset of the set of integers
({0, 1, 2, 3, … } or {1, 2, 3, … }) to a set , denoted {$a_n$}. The
integers determine the positions of the elements in the list&lt;/p>
&lt;h2 id="summations-求和">Summations 求和&lt;/h2>
&lt;p>A summation is the value of the sum of the terms of a sequence.&lt;/p>
&lt;h3 id="special-summations">Special Summations&lt;/h3>
&lt;h4 id="geometric-series-等比数列和">Geometric series 等比数列和&lt;/h4>
&lt;p>$\sum^n_{j=0}ar^j$&lt;/p>
&lt;h4 id="harmonic-series">harmonic series&lt;/h4>
&lt;p>$\sum^n_{j=1} \frac{1}{j}$&lt;/p></description></item><item><title>离散数学---Tree</title><link>https://open17.github.io/CpHugo/p/dstree/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://open17.github.io/CpHugo/p/dstree/</guid><description>&lt;blockquote>
&lt;p>A tree is a connected undirected simple graph that contains no simple circuits.&lt;/p>
&lt;/blockquote>
&lt;h2 id="rooted-trees">Rooted Trees&lt;/h2>
&lt;h3 id="concept">concept&lt;/h3>
&lt;p>A &lt;strong>rooted tree&lt;/strong> is a tree in which &lt;em>one node&lt;/em> has been designated the root.&lt;br>
Every edge is &lt;em>directed&lt;/em> away from the root.&lt;br>
Given a vertex 𝑣 in a rooted tree 𝑇:&lt;/p>
&lt;ul>
&lt;li>Parent: unique vertex 𝑢 such that (𝑢,𝑣) is an edge (in the direction from root to 𝑣)&lt;/li>
&lt;li>Child: any vertex for which 𝑣 is a parent&lt;/li>
&lt;li>Siblings : vertices with the same parent(兄弟节点)&lt;/li>
&lt;li>Ancestors : all vertices from root to 𝑣 (except itself)&lt;/li>
&lt;li>Descendants : vertices with 𝑣 as an ancestors&lt;/li>
&lt;/ul>
&lt;h3 id="tips">tips&lt;/h3>
&lt;p>&lt;strong>A vertex of a tree is called a leaf if it has no children.&lt;/strong>&lt;br>
&lt;strong>Vertices that have children are called internal vertices.&lt;/strong>&lt;/p>
&lt;h2 id="gamestate-trees决策树">Game(state) Trees(决策树)&lt;/h2>
&lt;ul>
&lt;li>Vertices: positions (states) in a game&lt;/li>
&lt;li>Edges: legal moves from one position (state) to another&lt;/li>
&lt;li>Leaves: Final positions (states) of a game&lt;/li>
&lt;/ul>
&lt;h2 id="m-ary-treesm叉树">m-ary Trees(M叉树)&lt;/h2>
&lt;blockquote>
&lt;p>A rooted tree is called 𝑚-ary if every internal vertex has no more than 𝑚 children&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>It is called full if every internal (non-leaf) vertex has exactly 𝑚 children.&lt;/li>
&lt;li>A 2-ary tree is called a binary tree&lt;/li>
&lt;li>If vertex 𝑣 is in a tree 𝑇, the sub-tree with root 𝑣 is the tree consisting of 𝑣 and all its descendants.&lt;/li>
&lt;/ul>
&lt;h2 id="balanced-tree平衡树">Balanced Tree(平衡树)&lt;/h2>
&lt;h3 id="level-and-height">level and height&lt;/h3>
&lt;p>The level of a node is the length of the path from the root to the node (The level of the root is defined to be zero). &lt;br>
The height of a tree is &lt;em>maximum&lt;/em> level of node.&lt;/p>
&lt;h3 id="balanced">balanced&lt;/h3>
&lt;p>A rooted 𝑚-ary tree with height ℎ is called balanced if all leaves are at levels ℎ or ℎ−1.&lt;/p>
&lt;h2 id="binary-search-tree-二叉搜索树">Binary Search Tree (二叉搜索树)&lt;/h2>
&lt;p>左小右大&lt;/p>
&lt;h2 id="algorithms">Algorithms&lt;/h2>
&lt;p>The presentation of an algorithm (from high level to low level):&lt;/p>
&lt;ol>
&lt;li>descriptive method in a natural language&lt;/li>
&lt;li>pseudo code&lt;/li>
&lt;li>source code&lt;/li>
&lt;/ol>
&lt;h2 id="traversal-algorithm">Traversal Algorithm&lt;/h2>
&lt;h3 id="pre-order-traversal">Pre-order traversal&lt;/h3>
&lt;p>Let 𝑇 be a rooted tree with root 𝑟.
If 𝑇 consists only of 𝑟, then 𝑟 is the preorder traversal of 𝑇.
Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right.
The preorder traversal of 𝑇 will begin by visiting 𝑟, then 𝑇1 (in preorder), then 𝑇2 (in preorder), etc, until 𝑇𝑛 is traversed in preorder&lt;/p>
&lt;h3 id="in-order-traversal">In-order traversal&lt;/h3>
&lt;p>Let 𝑇 be a rooted tree with root 𝑟
If 𝑇 consists only of 𝑟, then 𝑟 is the in-order traversal of 𝑇.
Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right.
The in-order traversal of 𝑇 will begin by visiting 𝑇1 (in-order), then the root 𝑟, then 𝑇2 (in-order), etc, until 𝑇𝑛 is traversed in-order&lt;/p>
&lt;h3 id="post-order-traversal">Post-order traversal&lt;/h3>
&lt;p>Let 𝑇 be a rooted tree with root 𝑟
If 𝑇 consists only of 𝑟, then r is the post-order traversal of 𝑇.
Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right.
The post-order traversal of 𝑇 will begin by visiting 𝑇1 (in post-order), then 𝑇2 (in post-order), etc, then 𝑇𝑛 (in post-order) and finally the root 𝑟.&lt;/p>
&lt;h2 id="expression-trees">Expression Trees&lt;/h2>
&lt;p>The expression tree for an arithmetic expression consists of&lt;/p>
&lt;ul>
&lt;li>Vertices: numbers, +, −, ∗, /, ↑(↑ represents the power function)&lt;/li>
&lt;li>Edges: linking parts of an expression&lt;/li>
&lt;li>Internal vertices(非叶子节点) represent operations&lt;/li>
&lt;li>Leaves(叶子节点) represent the variables or numbers&lt;/li>
&lt;/ul>
&lt;h2 id="spanning-trees生成树">Spanning Trees(生成树)&lt;/h2>
&lt;blockquote>
&lt;p>A spanning tree of a connected undirected graph 𝐺 is a sub-graph of 𝐺 that contains all of 𝐺’s vertices and enough of its edges to form a tree.&lt;/p>
&lt;/blockquote>
&lt;h3 id="how-to-obtain">How to obtain?&lt;/h3>
&lt;p>To obtain a spanning tree from a connected undirected graph with cycles:&lt;br>
Remove edges until there are no cycles&lt;/p>
&lt;h3 id="depth-first-search">Depth-First Search&lt;/h3>
&lt;p>Depth-First Search (DFS) proceeds along a path from a vertex 𝑣 as deeply into the graph as possible before backing up (back-tracking). &lt;br>
To create a depth-first search (DFS) spanning tree: &lt;br>
Traverse the graph using a depth-first search and mark the edges that you follow. &lt;br>
After the traversal is complete, the graph’s vertices and marked edges form the spanning tree.&lt;br>
(If there are multiple choices, choose the next vertex in the alphabetical order.)&lt;/p>
&lt;h3 id="breadth-first-search">Breadth-First Search&lt;/h3>
&lt;p>Breadth-First Search (BFS) visits every vertex adjacent to a vertex v that it can before visiting any other vertex.
To create a breath-first search (BFS) spanning tree
Traverse the graph using a bread-first search and mark the edges that you follow.
When the traversal is complete, the graph’s vertices and marked edges form the spanning tree.&lt;/p>
&lt;h2 id="minimum-spanning-trees最小生成树">Minimum Spanning Trees(最小生成树)&lt;/h2>
&lt;p>A minimum spanning tree in a connected weighted graph is a spanning tree that has the smallest possible sum of weights of edges.&lt;br>
There may be several different minimum spanning trees for a particular graph. But the minimum weight is unique.&lt;/p>
&lt;h3 id="prim">Prim&lt;/h3>
&lt;ol>
&lt;li>Initially, starts from an empty (no vertices, no edges) sub minimum spanning tree 𝑇.
Randomly put a vertex 𝑣 into 𝑇.&lt;/li>
&lt;li>Among all the edges (𝑢,𝑠) such that 𝑢 is in 𝑇 and 𝑠 is not in 𝑇, find the one of the minimum weight.&lt;/li>
&lt;li>And add the edge and the endpoint to 𝑇.&lt;/li>
&lt;li>Repeat Step 3 for 𝑛−1 iterations (because a tree has 𝑛−1 edges).&lt;/li>
&lt;/ol>
&lt;h3 id="kruskal">Kruskal&lt;/h3>
&lt;ul>
&lt;li>Initially, starts from a subgraph of all vertices but no edges.&lt;/li>
&lt;li>Find the edge with the smallest weight.&lt;/li>
&lt;li>If adding the smallest edge to the subgraph does not create any cycle, add it. (To maintain the tree property.)&lt;/li>
&lt;li>Otherwise, this edge is not in the MST. So, discard the edge.&lt;/li>
&lt;li>Repeat steps 2-4 until for 𝑛−1 iterations (because a tree has 𝑛−1 edges).&lt;/li>
&lt;/ul></description></item><item><title>离散数学————Graph</title><link>https://open17.github.io/CpHugo/p/dmgraph/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://open17.github.io/CpHugo/p/dmgraph/</guid><description>&lt;h2 id="graph-theory">Graph Theory&lt;/h2>
&lt;h3 id="graph-concepts">Graph concepts&lt;/h3>
&lt;h4 id="definition1">Definition1&lt;/h4>
&lt;p>A graph G = (V,E) is a pair and consists of two sets V and such that:&lt;/p>
&lt;ul>
&lt;li>V is the set of vertices(顶点)&lt;/li>
&lt;li>E is the set of edges(边)&lt;/li>
&lt;/ul>
&lt;h4 id="remember">Remember&lt;/h4>
&lt;ol>
&lt;li>V cannot be empty,but E can(endpoint/node)&lt;/li>
&lt;li>Each edge have 1 or 2 vertices(1 is a ring)&lt;/li>
&lt;/ol>
&lt;h4 id="definition2">Definition2&lt;/h4>
&lt;ul>
&lt;li>(u,v) is an edge connetcing vettices u and v&lt;/li>
&lt;li>u and v are neighbors (adjacent).&lt;/li>
&lt;li>(u,v) connects u and v ((u,v) is incident on u and v).&lt;/li>
&lt;/ul>
&lt;h4 id="simple-graphs">Simple graphs&lt;/h4>
&lt;ul>
&lt;li>each edge connects two different vertices and&lt;/li>
&lt;li>where no two edges connect the same pair of vertices.&lt;/li>
&lt;/ul>
&lt;h4 id="multigraph">Multigraph&lt;/h4>
&lt;ul>
&lt;li>A multigraph is a graph that may have multiple edges connecting the same pair of vertices.&lt;/li>
&lt;li>If there are m different edges associated to the same unordered pair of vertices u and v, (u, v) is an edge of multiplicity.&lt;/li>
&lt;/ul>
&lt;h4 id="loops自环">Loops(自环)&lt;/h4>
&lt;ul>
&lt;li>A loop is an edge that connects one vertex to itself.&lt;/li>
&lt;li>Graphs that may include loops, and possibly multiples edges connecting the same pair of vertices are called &lt;em>&lt;strong>pseudo-graphs&lt;/strong>&lt;/em>.&lt;/li>
&lt;/ul>
&lt;h4 id="directed-graph有向图">Directed Graph(有向图)&lt;/h4>
&lt;p>A directed graph (V,E) consists of a nonempty set V and a
set of directed edges E&lt;/p>
&lt;h4 id="tips">tips&lt;/h4>
&lt;p>The edge (u,v) in a directed graph starts at u and ends at v.&lt;/p>
&lt;h4 id="degree度">Degree(度)&lt;/h4>
&lt;p>The degree of a vertex in an undirected graph is the number of edges connected with it except that a loop at a vertex(自环算2)contribute twice to the degree of that vertex.&lt;/p>
&lt;h5 id="in-degree-and-out-degree入度出度">In-Degree and Out-Degree(入度、出度)&lt;/h5>
&lt;p>$In:def^-(v)$&lt;br>
$Out:def^+(v)$&lt;/p>
&lt;h3 id="handshaking-theorem">Handshaking Theorem&lt;/h3>
&lt;p>For an undirected graph G= (V,E):&lt;br>
$$2|E|=\sum_{v \in V}deg(v)$$&lt;/p>
&lt;h3 id="odd-degree-theorem">Odd Degree Theorem&lt;/h3>
&lt;p>In a directed graph G = (V,E)
$$|E|=\sum_{v \in V}deg^-(v)=\sum_{v \in V}deg^+(v)$$&lt;/p>
&lt;h3 id="special-graphs">Special graphs&lt;/h3>
&lt;h4 id="complete-graphs完全图">Complete graphs(完全图)&lt;/h4>
&lt;p>A complete graph is a simple graph in which there is an edge between each pair of distinct vertices, denoted by $K_n$ where n is the number of nodes in the graph&lt;/p>
&lt;h4 id="cycles">Cycles&lt;/h4>
&lt;p>A cycle is a graph that contains (n ≥ 3) vertices {V1, V2, … ,Vn } and n edges (V1, V2), (V2, V3), …, (Vn, V1), denoted by $C_n$ where is the number of nodes in the graph.&lt;/p>
&lt;h4 id="wheels">Wheels&lt;/h4>
&lt;p>$Cn$加上中间一个点以及连边，记做$W_n$&lt;/p>
&lt;h4 id="cubes">Cubes&lt;/h4>
&lt;p>A cube of dimension n($Q_n$)is a simple graph of $2^n$ vertices, where each vertex represents a bit string of length n. Two vertices are adjacent if and only if they differ by one bit.&lt;/p>
&lt;h4 id="bipartite-graphs二分图">Bipartite Graphs(二分图)&lt;/h4>
&lt;ul>
&lt;li>A simple graph G = (V,E ) is called bipartite if its vertex set V can be partitioned into two disjoint set V1 and V2 such that every edge in the graph connects a vertex in V1 and a vertex in V2.&lt;/li>
&lt;li>V1 and V2 are called a bipartite of the vertex set V of G&lt;/li>
&lt;/ul>
&lt;h4 id="theorem染色法">Theorem(染色法)&lt;/h4>
&lt;p>前置知识：二分图不存在奇数环&lt;br>
A simple graph G= (V,E) is bipartite if and only if it is
possible to color each vertex with one of two colors so that no
adjacent vertices have the same color.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// n表示点数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">M&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">ne&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">M&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">idx&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 邻接表存储图
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">N&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="c1">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 参数：u表示当前节点，c表示当前点的颜色
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">bool&lt;/span> &lt;span class="nf">dfs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">u&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">color&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">h&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="p">];&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">ne&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">dfs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">bool&lt;/span> &lt;span class="nf">check&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">sizeof&lt;/span> &lt;span class="n">color&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">bool&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">++&lt;/span> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">color&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">dfs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">flag&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//source：https://www.acwing.com/blog/content/405/
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="complete-bipartite-graphs完全二分图">Complete Bipartite Graphs(完全二分图)&lt;/h4>
&lt;p>$K_{m,n} $&lt;br>
In a complete bipartite graph, for any vertex in a subset,there is an edge between it and each vertex in another set.&lt;/p>
&lt;h4 id="outline">Outline&lt;/h4>
&lt;p>&lt;img src="http://ask.qcloudimg.com/http-save/yehe-8904777/6fb1fc6209cd5933717fbc5da940c425.png?imageView2/2/w/1200"
loading="lazy"
alt="图片"
>&lt;/p>
&lt;h3 id="subgraphs-and-proper-subgraphs">Subgraphs and Proper Subgraphs&lt;/h3>
&lt;ul>
&lt;li>A subgraph H = (W,F) of graph G = (V,E) is made up of vertices W ⊆ V and edges F ⊆ E.&lt;/li>
&lt;li>A subgraph H of G is a proper subgraph if H ≠ G.&lt;/li>
&lt;/ul>
&lt;h3 id="union-of-simple-graphs">Union of Simple Graphs&lt;/h3>
&lt;p>The union of two simple graphs G1 = (V1, E1) and G2 = (V2, E2) is the simple graph G = (V, E) such that V = V1 ∪ V2 and E = E1 ∪ E2&lt;/p>
&lt;h3 id="representing-graphs">Representing Graphs&lt;/h3>
&lt;ul>
&lt;li>Adjacency matrix(邻接矩阵):dense graph&lt;/li>
&lt;li>Adjacency table(邻接表):sparse graph&lt;/li>
&lt;/ul>
&lt;h3 id="graph-isomorphism同构图">Graph Isomorphism(同构图)&lt;/h3>
&lt;p>判断同构：推荐使用邻接矩阵判断&lt;/p>
&lt;h3 id="graph-connectivity">Graph Connectivity&lt;/h3>
&lt;h4 id="path">Path&lt;/h4>
&lt;p>path of length m from vertexu to vertex v is a sequence of edges e1, e2, … , $e_n$ such that e1 starts at u and $e_n$ ends at v.&lt;/p>
&lt;h4 id="circuit">Circuit&lt;/h4>
&lt;p>A circuit is a path that begins and ends at the same vertex in graph.&lt;/p>
&lt;h4 id="simple-path-or-circuit">Simple path or circuit&lt;/h4>
&lt;p>A simple path or circuit does not pass through the same edge twice or more.&lt;/p>
&lt;h3 id="graph-connectedness">Graph Connectedness&lt;/h3>
&lt;ul>
&lt;li>An undirected graph is connected if there is a path between every pair of distinct vertices&lt;/li>
&lt;li>A directed graph is &lt;strong>strongly connected&lt;/strong> if there is a path from a to b and from b to a whenever a and b are vertices in the graph&lt;/li>
&lt;/ul>
&lt;h3 id="euler-paths">Euler Paths&lt;/h3>
&lt;ul>
&lt;li>An Euler path in G is a &lt;em>simple&lt;/em> path containing every edge of G&lt;/li>
&lt;li>An Euler circuit in a graph G is a &lt;em>simple&lt;/em> circuit containing every edge of G&lt;/li>
&lt;/ul>
&lt;h4 id="theorem">THEOREM&lt;/h4>
&lt;p>A connected multi-graph has an Euler circuit if and only if each vertex has even degree.&lt;/p>
&lt;h3 id="hamilton-circuits">Hamilton Circuits&lt;/h3>
&lt;ul>
&lt;li>A Hamilton path is a path that traverses each vertex in G exactly once&lt;/li>
&lt;li>A Hamilton circuit is a circuit that traverses each vertex in G exactly once.&lt;/li>
&lt;/ul>
&lt;h4 id="ores-theorem">Ore’s theorem&lt;/h4>
&lt;p>If for every pair of nonadjacent vertices u and v in the simple graph G with n vertices, deg(u) + deg(v) ≥ n ,then has a Hamilton circuit.&lt;/p>
&lt;h4 id="diracs-theorem">Dirac’s theorem&lt;/h4>
&lt;p>If the degree of each vertex is great than or equals n/2 in
the connected simple graph G with n vertices where n ≥ 3,
then G has a Hamilton circuit.&lt;/p>
&lt;h3 id="planar-graphs">Planar Graphs&lt;/h3>
&lt;p>In a planar representation of&lt;/p>
&lt;ul>
&lt;li>e: number of edges&lt;/li>
&lt;li>v: number of vertices&lt;/li>
&lt;li>r: number of regions&lt;/li>
&lt;li>$r= e – v + 2$&lt;/li>
&lt;/ul>
&lt;h4 id="eulers-formula">Euler’s Formula&lt;/h4>
&lt;blockquote>
&lt;p>G is a connected planar simple graph&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>v ≥ 3, then e ≤ 3v – 6&lt;/li>
&lt;li>G has a vertex of degree not exceeding 5&lt;/li>
&lt;li>if v&amp;gt;=3 and no circuits of length 3,then e&amp;lt;=2v-4&lt;/li>
&lt;/ul></description></item><item><title>离散数学知识速查</title><link>https://open17.github.io/CpHugo/p/dm-quick-review/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://open17.github.io/CpHugo/p/dm-quick-review/</guid><description>&lt;h2 id="topics1">Topics&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/h2>
&lt;ul>
&lt;li>Logic and proofs&lt;/li>
&lt;li>Set, functions, sequences, and summations&lt;/li>
&lt;li>Counting&lt;/li>
&lt;li>Relations&lt;/li>
&lt;li>Graph theory&lt;/li>
&lt;li>Tree&lt;/li>
&lt;li>Boolean algebra&lt;/li>
&lt;/ul>
&lt;h2 id="logic-and-proofs">Logic and Proofs&lt;/h2>
&lt;h3 id="propositional-logic">Propositional logic&lt;/h3>
&lt;h4 id="truth-table">Truth table&lt;/h4>
&lt;p>(Given a proposition, draw the truth table)&lt;/p>
&lt;h4 id="logical-operators">Logical operators&lt;/h4>
&lt;p>Conjunction ∧&lt;br>
Disjunction ∨&lt;br>
Exclusive OR ⊕
Implication $→$&lt;/p>
&lt;h3 id="propositional-equivalence">Propositional equivalence&lt;/h3>
&lt;h4 id="laws">Laws&lt;/h4>
&lt;ol>
&lt;li>De Morgan’s laws (否定拆括号取反)&lt;/li>
&lt;li>Distributive(分配) laws&lt;/li>
&lt;li>$p\rightarrow q=\neg p \vee q$&lt;/li>
&lt;/ol>
&lt;h4 id="tautology-and-contradiction">Tautology and contradiction&lt;/h4>
&lt;p>Given two propositions, prove they are equivalent&lt;/p>
&lt;h3 id="predicates">Predicates&lt;/h3>
&lt;p>Universal quantification&lt;br>
Existential quantification&lt;br>
Translate a sentence to a logical expression&lt;/p>
&lt;h3 id="proofs">Proofs&lt;/h3>
&lt;h4 id="inference-rules-推理规则">Inference rules 推理规则&lt;/h4>
&lt;p>(prove or disprove an argument)&lt;/p>
&lt;ul>
&lt;li>肯定前件推理 $p\wedge( p \rightarrow q)\Rightarrow q$&lt;/li>
&lt;li>否定后件推理 $\neg q \wedge(p\rightarrow q) \Rightarrow \neg p$&lt;/li>
&lt;li>析取三段论&lt;/li>
&lt;li>假说演绎推理&lt;/li>
&lt;li>归结推理&lt;/li>
&lt;/ul>
&lt;h4 id="argument">Argument&lt;/h4>
&lt;ul>
&lt;li>Valid argument&lt;/li>
&lt;li>Invalid argument&lt;/li>
&lt;/ul>
&lt;h3 id="proof-methods">Proof methods&lt;/h3>
&lt;h4 id="direct-proofs">direct proofs&lt;/h4>
&lt;h4 id="indirect-proofs">Indirect proofs&lt;/h4>
&lt;p>Proof by contraposition(非非反)
Proof by contradiction&lt;/p>
&lt;h4 id="existence-proof-constructive-and-non-constructive">Existence proof (constructive and non-constructive)&lt;/h4>
&lt;h4 id="uniqueness-proof-two-steps">Uniqueness proof (two steps)&lt;/h4>
&lt;p>存在且仅存在一个 &lt;br>
假设存在两个满足,然后证明两个相等&lt;/p>
&lt;h2 id="sets-functions-sequences-and-summations">Sets, Functions, Sequences and Summations&lt;/h2>
&lt;h3 id="sets">Sets&lt;/h3>
&lt;h4 id="subset">Subset&lt;/h4>
&lt;p>子集,空集,非空真子集,真子集&lt;/p>
&lt;h4 id="powerset">Powerset&lt;/h4>
&lt;p>(P(S)=A∣A⊆S)&lt;/p>
&lt;h4 id="cardinality">Cardinality&lt;/h4>
&lt;p>集合元素个数，特别有|P(S)|=$2^n$&lt;/p>
&lt;h4 id="cartesian-product笛卡尔积">Cartesian product(笛卡尔积)&lt;/h4>
&lt;p>全部组合&lt;/p>
&lt;h4 id="set-operations">Set operations&lt;/h4>
&lt;h4 id="set-identity">Set identity&lt;/h4>
&lt;p>(prove two sets are the same)&lt;/p>
&lt;ul>
&lt;li>De Morgan’s Law&lt;/li>
&lt;/ul>
&lt;h4 id="laws-and-membership-table">Laws and membership table&lt;/h4>
&lt;p>0,1表&lt;/p>
&lt;h3 id="functions">Functions&lt;/h3>
&lt;h4 id="one-to-one-functions-injection">One-to-one functions (injection)&lt;/h4>
&lt;p>单射,一一对应&lt;/p>
&lt;h4 id="onto-functions-surjection">Onto functions (surjection)&lt;/h4>
&lt;p>满射,全部y都有x&lt;/p>
&lt;h4 id="one-to-one-and-onto-functions-bijection">One-to-one and onto functions (bijection)&lt;/h4>
&lt;p>单加满&lt;/p>
&lt;h4 id="special-functions">Special functions&lt;/h4>
&lt;ul>
&lt;li>Ceiling function上&lt;/li>
&lt;li>Floor function下&lt;/li>
&lt;/ul>
&lt;h3 id="sequences-and-summations">Sequences and summations&lt;/h3>
&lt;h2 id="countings">Countings&lt;/h2>
&lt;h3 id="rules">Rules&lt;/h3>
&lt;h4 id="product-rule">Product rule&lt;/h4>
&lt;p>乘法原理&lt;/p>
&lt;h4 id="sum-rule">Sum rule&lt;/h4>
&lt;p>加法原理&lt;/p>
&lt;h4 id="隔板法">隔板法&lt;/h4>
&lt;h3 id="principles">Principles&lt;/h3>
&lt;h4 id="inclusion-exclusion-principle">Inclusion-exclusion principle&lt;/h4>
&lt;p>容斥&lt;/p>
&lt;h4 id="pigeonhole-principle">Pigeonhole principle&lt;/h4>
&lt;p>抽屉原理(ceil(n/k))&lt;/p>
&lt;h3 id="permutation-and-combination">Permutation and combination&lt;/h3>
&lt;p>$$P(n,r)=n!/(n-r)!$$&lt;/p>
&lt;h3 id="recurrence-relation">Recurrence relation&lt;/h3>
&lt;p>$$C(n,r)=n!/[(n-r)!*r!]$$&lt;/p>
&lt;h4 id="construct-a-recurrence-relation">Construct a recurrence relation&lt;/h4>
&lt;h4 id="solve-a-recurrence-relation">Solve a recurrence relation&lt;/h4>
&lt;p>$$
a_n=c_1a_{n-1}+c_2a_{n-2} \
r^2-c_1r-c_2=0 \
a_n=k_1r_1^n+k_2r_2^n
$$&lt;/p>
&lt;h2 id="relations">Relations&lt;/h2>
&lt;h3 id="representing-relations">Representing relations&lt;/h3>
&lt;p>There are several other ways to represent relations&lt;/p>
&lt;ul>
&lt;li>Tables&lt;/li>
&lt;li>Matrices&lt;/li>
&lt;li>Graphs&lt;/li>
&lt;/ul>
&lt;h3 id="relations-on-a-set">Relations on a set&lt;/h3>
&lt;p>A relation on the set is a relation from 𝐴 to 𝐴&lt;/p>
&lt;h4 id="reflexive">Reflexive&lt;/h4>
&lt;p>(a,a) belongs to R for all element in A&lt;/p>
&lt;h4 id="symmetric">Symmetric&lt;/h4>
&lt;p>对称&lt;/p>
&lt;h4 id="anti-symmetric">Anti-symmetric&lt;/h4>
&lt;p>反对称&lt;/p>
&lt;h4 id="transitive">Transitive&lt;/h4>
&lt;p>传递性&lt;/p>
&lt;h3 id="equivalence-relation">Equivalence relation&lt;/h3>
&lt;h4 id="equivalence-relation-and-partition">Equivalence relation and Partition&lt;/h4>
&lt;p>Equivalence relation ⇔ Partition&lt;/p>
&lt;h4 id="prove-a-relation-is-an-equivalence-relation">Prove a relation is an equivalence relation.&lt;/h4>
&lt;p>Reflexive Symmetric Transitive&lt;/p>
&lt;h4 id="given-an-equivalence-relation-list-equivalent-classes-give-the-partition">Given an equivalence relation, list equivalent classes (give the partition)&lt;/h4>
&lt;h2 id="graph-theory">Graph Theory&lt;/h2>
&lt;h3 id="graph">Graph&lt;/h3>
&lt;h4 id="definition">Definition&lt;/h4>
&lt;p>G=(V,E)&lt;/p>
&lt;h4 id="representing-graphs-adjacency-matrix-adjacency-list--and-sketch">Representing graphs (adjacency matrix, adjacency list, and sketch)&lt;/h4>
&lt;h4 id="isomorphism">Isomorphism&lt;/h4>
&lt;ol>
&lt;li>邻接矩阵&lt;/li>
&lt;li>$bijection f:V_1 \rightarrow V_2: \forall a,b \in V_1((a,b)\in E_1 \leftrightarrow (f(a),f(b))\in E_2) $&lt;/li>
&lt;/ol>
&lt;h3 id="eular-path-and-eular-circuit">Eular path and Eular circuit&lt;/h3>
&lt;p>containing every edge (simple path)&lt;br>
欧拉回路:each vertex has even degree&lt;br>
欧拉路径在连通multi: exactly 2 vertices of odd degree&lt;/p>
&lt;h3 id="hamilton-path-and-hamilton-circuit">Hamilton path and Hamilton circuit&lt;/h3>
&lt;p>each vertex once&lt;/p>
&lt;h4 id="ores-theorem">Ore’s theorem&lt;/h4>
&lt;p>If for every pair of nonadjacent vertices u and v in the simple graph G with n vertices, deg(u) + deg(v) ≥ n ,then has a Hamilton circuit.&lt;/p>
&lt;h4 id="diracs-theorem">Dirac’s theorem&lt;/h4>
&lt;p>If the degree of each vertex is great than or equals n/2 in the connected simple graph G with n vertices where n ≥ 3, then G has a Hamilton circuit.&lt;/p>
&lt;h3 id="planar-graphs">Planar graphs&lt;/h3>
&lt;p>r=e–v+2&lt;/p>
&lt;h4 id="eulers-formula">Euler’s Formula&lt;/h4>
&lt;blockquote>
&lt;p>G is a connected planar simple graph&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>v ≥ 3, then e ≤ 3v – 6&lt;/li>
&lt;li>G has a vertex of degree not exceeding 5&lt;/li>
&lt;li>if v&amp;gt;=3 and no circuits of length 3,then e&amp;lt;=2v-4&lt;/li>
&lt;/ul>
&lt;h2 id="trees">Trees&lt;/h2>
&lt;h3 id="tree-traversal">Tree traversal&lt;/h3>
&lt;h4 id="preorder-traversal">Preorder traversal&lt;/h4>
&lt;p>中左1右&lt;/p>
&lt;h4 id="in-order-traversal">In-order traversal&lt;/h4>
&lt;p>左1中右&lt;/p>
&lt;h4 id="post-order-traversal">Post-order traversal&lt;/h4>
&lt;p>左1右中&lt;/p>
&lt;h3 id="expression-forms-conversion-among-the-different-forms">Expression forms (conversion among the different forms)&lt;/h3>
&lt;p>关键
Internal vertices(非叶子节点) represent operations&lt;br>
Leaves(叶子节点) represent the variables or numbers&lt;/p>
&lt;h4 id="infix">Infix&lt;/h4>
&lt;h4 id="prefix">prefix&lt;/h4>
&lt;h4 id="postfix">postfix&lt;/h4>
&lt;h3 id="spanning-tree">Spanning tree&lt;/h3>
&lt;h4 id="dfs">DFS&lt;/h4>
&lt;p>回溯(字母序)&lt;/p>
&lt;h4 id="bfs">BFS&lt;/h4>
&lt;p>都走(字母序,不重复)&lt;/p>
&lt;h2 id="boolean-algebra">Boolean Algebra&lt;/h2>
&lt;h3 id="boolean-expressions">Boolean expressions&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>.&lt;/td>
&lt;td>与&lt;/td>
&lt;td>product&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>+&lt;/td>
&lt;td>或&lt;/td>
&lt;td>sum&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>-&lt;/td>
&lt;td>非&lt;/td>
&lt;td>complement&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="boolean-identities">Boolean identities&lt;/h4>
&lt;p>换成逻辑表达式再换回来记忆&lt;/p>
&lt;h4 id="min-term最小项">min-term(最小项)&lt;/h4>
&lt;p>A min-term of Boolean variables x1, x2, ⋯ ,xn is a Boolean product of literals&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> y1y2 , ⋯ , yn where yi (1 ≤ i ≤ n ) is either xi or complement of xi
Each min-term has exactly one literal for every variable.&lt;/p>
&lt;h4 id="dnf">DNF&lt;/h4>
&lt;p>任何命题公式，最终都能够化成 ( A 1 ∧ A 2 ) ∨ ( A 3 ∧ A 4 )的形式，这种先 ∧ 合 取 再 ∨ 析 取 的范式，被称为 “析取范式”。&lt;/p>
&lt;p>DNF is the unique sum of min-terms of the variables in the expression,Also called sum of products expansion&lt;/p>
&lt;p>SOP是DNF的化简，DNF是SOP的扩展&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;h4 id="maxterms最大项">Maxterms(最大项)&lt;/h4>
&lt;p>A max-term of Boolean variables x1, x2, ⋯ , is the sum of literals y1 + y2+, ⋯ ,yn + where (1 ≤ i ≤ n) is either xi or complement of xi&lt;/p>
&lt;h4 id="cnf">CNF&lt;/h4>
&lt;p>任何命题公式，最终都能够化成 ( A 1 ∨ A 2 ) ∧ ( A 3 ∨ A 4 ) 的形式，这种先 ∨ 析 取 再 ∧ 合 取 的范式，被称为 “ 合取范式”。&lt;/p>
&lt;p>POS同上&lt;/p>
&lt;blockquote>
&lt;p>If we have DNF for $\overline F $, then get CNF from $\overline{\overline F} $&lt;/p>
&lt;/blockquote>
&lt;h4 id="equivalence-of-expressions">Equivalence of expressions&lt;/h4>
&lt;h4 id="funtion-completeness">Funtion completeness&lt;/h4>
&lt;p>can represent {+ . ——} using Operate O&lt;/p>
&lt;h3 id="logic-circuits">Logic circuits&lt;/h3>
&lt;h4 id="logic-gates">Logic gates&lt;/h4>
&lt;p>&lt;img src="https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/LogicGate.PNG"
width="948"
height="748"
srcset="https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/LogicGate_hu3ae756db54a9cfe3360b55a6800b815e_59353_480x0_resize_box_3.PNG 480w, https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/LogicGate_hu3ae756db54a9cfe3360b55a6800b815e_59353_1024x0_resize_box_3.PNG 1024w"
loading="lazy"
alt="pic"
class="gallery-image"
data-flex-grow="126"
data-flex-basis="304px"
>
&lt;img src="https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/Buffer.PNG"
width="753"
height="511"
srcset="https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/Buffer_hu96baafbacbeda63a0d52d5ccad167053_46626_480x0_resize_box_3.PNG 480w, https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/Buffer_hu96baafbacbeda63a0d52d5ccad167053_46626_1024x0_resize_box_3.PNG 1024w"
loading="lazy"
alt="buf"
class="gallery-image"
data-flex-grow="147"
data-flex-basis="353px"
>&lt;/p>
&lt;h3 id="logic-circuits-1">Logic circuits&lt;/h3>
&lt;h4 id="karnaugh-maps4">Karnaugh maps&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;/h4>
&lt;p>&lt;img src="https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/KarnaughMap.PNG"
width="957"
height="581"
srcset="https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/KarnaughMap_hu0df7f2d6c3afb9a34f51855538f83e32_54009_480x0_resize_box_3.PNG 480w, https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/KarnaughMap_hu0df7f2d6c3afb9a34f51855538f83e32_54009_1024x0_resize_box_3.PNG 1024w"
loading="lazy"
alt="map"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>
1、取大不取小，圈越大，消去的变量越多，与项越简单，能画入大圈就不画入小圈；&lt;br>
2、圈数越少，化简后的与项就越少；&lt;br>
3、一个最小项可以重复使用，即只要需要，一个方格可以同时被多圈所圈&lt;/p>
&lt;h4 id="steps-in-designing-a-logic-circuit">Steps in designing a logic circuit&lt;/h4>
&lt;p>&lt;img src="https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/Step2design.PNG"
width="981"
height="689"
srcset="https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/Step2design_huca4c02c930d949363577d42a5cfc6f8b_121195_480x0_resize_box_3.PNG 480w, https://open17.github.io/CpHugo/CpHugo/p/dm-quick-review/Step2design_huca4c02c930d949363577d42a5cfc6f8b_121195_1024x0_resize_box_3.PNG 1024w"
loading="lazy"
alt="step"
class="gallery-image"
data-flex-grow="142"
data-flex-basis="341px"
>&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a class="link" href="https://blog.csdn.net/sinat_21644713/article/details/45896211" target="_blank" rel="noopener"
>推荐阅读&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>A literal is a Boolean variable or its complement.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>有些书上定义DNF为SOP，将SOP的扩展叫做CDNF，本文不采用这种定义&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>&lt;a class="link" href="http://t.csdn.cn/pUBN1" target="_blank" rel="noopener"
>可以参考&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>