<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tree on CpHugo</title><link>https://open17.github.io/CpHugo/tags/tree/</link><description>Recent content in tree on CpHugo</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 01 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://open17.github.io/CpHugo/tags/tree/index.xml" rel="self" type="application/rss+xml"/><item><title>离散数学---Tree</title><link>https://open17.github.io/CpHugo/p/dstree/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://open17.github.io/CpHugo/p/dstree/</guid><description>&lt;blockquote>
&lt;p>A tree is a connected undirected simple graph that contains no simple circuits.&lt;/p>
&lt;/blockquote>
&lt;h2 id="rooted-trees">Rooted Trees&lt;/h2>
&lt;h3 id="concept">concept&lt;/h3>
&lt;p>A &lt;strong>rooted tree&lt;/strong> is a tree in which &lt;em>one node&lt;/em> has been designated the root.&lt;br>
Every edge is &lt;em>directed&lt;/em> away from the root.&lt;br>
Given a vertex 𝑣 in a rooted tree 𝑇:&lt;/p>
&lt;ul>
&lt;li>Parent: unique vertex 𝑢 such that (𝑢,𝑣) is an edge (in the direction from root to 𝑣)&lt;/li>
&lt;li>Child: any vertex for which 𝑣 is a parent&lt;/li>
&lt;li>Siblings : vertices with the same parent(兄弟节点)&lt;/li>
&lt;li>Ancestors : all vertices from root to 𝑣 (except itself)&lt;/li>
&lt;li>Descendants : vertices with 𝑣 as an ancestors&lt;/li>
&lt;/ul>
&lt;h3 id="tips">tips&lt;/h3>
&lt;p>&lt;strong>A vertex of a tree is called a leaf if it has no children.&lt;/strong>&lt;br>
&lt;strong>Vertices that have children are called internal vertices.&lt;/strong>&lt;/p>
&lt;h2 id="gamestate-trees决策树">Game(state) Trees(决策树)&lt;/h2>
&lt;ul>
&lt;li>Vertices: positions (states) in a game&lt;/li>
&lt;li>Edges: legal moves from one position (state) to another&lt;/li>
&lt;li>Leaves: Final positions (states) of a game&lt;/li>
&lt;/ul>
&lt;h2 id="m-ary-treesm叉树">m-ary Trees(M叉树)&lt;/h2>
&lt;blockquote>
&lt;p>A rooted tree is called 𝑚-ary if every internal vertex has no more than 𝑚 children&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>It is called full if every internal (non-leaf) vertex has exactly 𝑚 children.&lt;/li>
&lt;li>A 2-ary tree is called a binary tree&lt;/li>
&lt;li>If vertex 𝑣 is in a tree 𝑇, the sub-tree with root 𝑣 is the tree consisting of 𝑣 and all its descendants.&lt;/li>
&lt;/ul>
&lt;h2 id="balanced-tree平衡树">Balanced Tree(平衡树)&lt;/h2>
&lt;h3 id="level-and-height">level and height&lt;/h3>
&lt;p>The level of a node is the length of the path from the root to the node (The level of the root is defined to be zero). &lt;br>
The height of a tree is &lt;em>maximum&lt;/em> level of node.&lt;/p>
&lt;h3 id="balanced">balanced&lt;/h3>
&lt;p>A rooted 𝑚-ary tree with height ℎ is called balanced if all leaves are at levels ℎ or ℎ−1.&lt;/p>
&lt;h2 id="binary-search-tree-二叉搜索树">Binary Search Tree (二叉搜索树)&lt;/h2>
&lt;p>左小右大&lt;/p>
&lt;h2 id="algorithms">Algorithms&lt;/h2>
&lt;p>The presentation of an algorithm (from high level to low level):&lt;/p>
&lt;ol>
&lt;li>descriptive method in a natural language&lt;/li>
&lt;li>pseudo code&lt;/li>
&lt;li>source code&lt;/li>
&lt;/ol>
&lt;h2 id="traversal-algorithm">Traversal Algorithm&lt;/h2>
&lt;h3 id="pre-order-traversal">Pre-order traversal&lt;/h3>
&lt;p>Let 𝑇 be a rooted tree with root 𝑟.
If 𝑇 consists only of 𝑟, then 𝑟 is the preorder traversal of 𝑇.
Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right.
The preorder traversal of 𝑇 will begin by visiting 𝑟, then 𝑇1 (in preorder), then 𝑇2 (in preorder), etc, until 𝑇𝑛 is traversed in preorder&lt;/p>
&lt;h3 id="in-order-traversal">In-order traversal&lt;/h3>
&lt;p>Let 𝑇 be a rooted tree with root 𝑟
If 𝑇 consists only of 𝑟, then 𝑟 is the in-order traversal of 𝑇.
Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right.
The in-order traversal of 𝑇 will begin by visiting 𝑇1 (in-order), then the root 𝑟, then 𝑇2 (in-order), etc, until 𝑇𝑛 is traversed in-order&lt;/p>
&lt;h3 id="post-order-traversal">Post-order traversal&lt;/h3>
&lt;p>Let 𝑇 be a rooted tree with root 𝑟
If 𝑇 consists only of 𝑟, then r is the post-order traversal of 𝑇.
Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right.
The post-order traversal of 𝑇 will begin by visiting 𝑇1 (in post-order), then 𝑇2 (in post-order), etc, then 𝑇𝑛 (in post-order) and finally the root 𝑟.&lt;/p>
&lt;h2 id="expression-trees">Expression Trees&lt;/h2>
&lt;p>The expression tree for an arithmetic expression consists of&lt;/p>
&lt;ul>
&lt;li>Vertices: numbers, +, −, ∗, /, ↑(↑ represents the power function)&lt;/li>
&lt;li>Edges: linking parts of an expression&lt;/li>
&lt;li>Internal vertices(非叶子节点) represent operations&lt;/li>
&lt;li>Leaves(叶子节点) represent the variables or numbers&lt;/li>
&lt;/ul>
&lt;h2 id="spanning-trees生成树">Spanning Trees(生成树)&lt;/h2>
&lt;blockquote>
&lt;p>A spanning tree of a connected undirected graph 𝐺 is a sub-graph of 𝐺 that contains all of 𝐺’s vertices and enough of its edges to form a tree.&lt;/p>
&lt;/blockquote>
&lt;h3 id="how-to-obtain">How to obtain?&lt;/h3>
&lt;p>To obtain a spanning tree from a connected undirected graph with cycles:&lt;br>
Remove edges until there are no cycles&lt;/p>
&lt;h3 id="depth-first-search">Depth-First Search&lt;/h3>
&lt;p>Depth-First Search (DFS) proceeds along a path from a vertex 𝑣 as deeply into the graph as possible before backing up (back-tracking). &lt;br>
To create a depth-first search (DFS) spanning tree: &lt;br>
Traverse the graph using a depth-first search and mark the edges that you follow. &lt;br>
After the traversal is complete, the graph’s vertices and marked edges form the spanning tree.&lt;br>
(If there are multiple choices, choose the next vertex in the alphabetical order.)&lt;/p>
&lt;h3 id="breadth-first-search">Breadth-First Search&lt;/h3>
&lt;p>Breadth-First Search (BFS) visits every vertex adjacent to a vertex v that it can before visiting any other vertex.
To create a breath-first search (BFS) spanning tree
Traverse the graph using a bread-first search and mark the edges that you follow.
When the traversal is complete, the graph’s vertices and marked edges form the spanning tree.&lt;/p>
&lt;h2 id="minimum-spanning-trees最小生成树">Minimum Spanning Trees(最小生成树)&lt;/h2>
&lt;p>A minimum spanning tree in a connected weighted graph is a spanning tree that has the smallest possible sum of weights of edges.&lt;br>
There may be several different minimum spanning trees for a particular graph. But the minimum weight is unique.&lt;/p>
&lt;h3 id="prim">Prim&lt;/h3>
&lt;ol>
&lt;li>Initially, starts from an empty (no vertices, no edges) sub minimum spanning tree 𝑇.
Randomly put a vertex 𝑣 into 𝑇.&lt;/li>
&lt;li>Among all the edges (𝑢,𝑠) such that 𝑢 is in 𝑇 and 𝑠 is not in 𝑇, find the one of the minimum weight.&lt;/li>
&lt;li>And add the edge and the endpoint to 𝑇.&lt;/li>
&lt;li>Repeat Step 3 for 𝑛−1 iterations (because a tree has 𝑛−1 edges).&lt;/li>
&lt;/ol>
&lt;h3 id="kruskal">Kruskal&lt;/h3>
&lt;ul>
&lt;li>Initially, starts from a subgraph of all vertices but no edges.&lt;/li>
&lt;li>Find the edge with the smallest weight.&lt;/li>
&lt;li>If adding the smallest edge to the subgraph does not create any cycle, add it. (To maintain the tree property.)&lt;/li>
&lt;li>Otherwise, this edge is not in the MST. So, discard the edge.&lt;/li>
&lt;li>Repeat steps 2-4 until for 𝑛−1 iterations (because a tree has 𝑛−1 edges).&lt;/li>
&lt;/ul></description></item></channel></rss>