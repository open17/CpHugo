[{"content":" ","date":"2023-06-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/tricks/","title":"技巧与套路"},{"content":"单调栈 模板1 这种思路通常用于寻找右边的数（求左边时倒叙即可） 每次stack弹出时才记录答案，因此需要维护一个数组或者哈希表 确定单调性与目标相反即可，若求右最小，单调增（方向指的是自底向顶，后面同），最大反之即可 这里以求右边NGE为代表 1 2 3 4 5 6 7 8 9 10 11 12 const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; FOR(i,1,n+1){ while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;a[i]){ b[s.top()]=i; s.pop(); } s.push(i); } } 模板2 这种思路通常用于寻找左边的数 寻找右边时，应反转列表（实际上倒叙即可）来看 这种写法每次维护后的栈顶即使答案 这里以求右边NGE为代表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; for(int i=n;i\u0026gt;0;i--){ //这里的等号要注意，不然如 5，5 的话返回的是 2，0（下标从1开始） while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;=a[i]){ s.pop(); } if(!s.empty()){ b[i]=s.top(); } s.push(i); } } 补充 常用技巧：哨兵节点 还要我发现我总结的上面的两个模板,灵神有个更本质的解释:https://leetcode.cn/problems/next-greater-node-in-linked-list/solution/tu-jie-dan-diao-zhan-liang-chong-fang-fa-v9ab/\n练习 传统单调栈系列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 //https://leetcode.cn/problems/next-greater-element-i/ //哈希+NGE class Solution { public: vector\u0026lt;int\u0026gt; nextGreaterElement(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { stack\u0026lt;int\u0026gt; a; map\u0026lt;int,int\u0026gt; m; vector\u0026lt;int\u0026gt; ans; for(int i=0;i\u0026lt;nums1.size();i++){ m[nums1[i]]=i; ans.push_back(-1); } //max=1e4 a.push(1e4+1); for(auto i:nums2){ while(a.top()\u0026lt;i){ int x=a.top(); a.pop(); if(m.count(x)){ ans[m[x]]=i; } } a.push(i); } return ans; } }; //https://leetcode.cn/problems/next-greater-element-ii/ //成环数组+NGE class Solution { public: vector\u0026lt;int\u0026gt; nextGreaterElements(vector\u0026lt;int\u0026gt;\u0026amp; nums) { stack\u0026lt;int\u0026gt; a; int s=nums.size(); vector\u0026lt;int\u0026gt; ans(s,-1); nums.push_back(1e9+1); a.push(s); for(int i=0;i\u0026lt;2*s-1;i++){ while(nums[a.top()]\u0026lt;nums[i%s]){ ans[a.top()]=nums[i%s]; a.pop(); } a.push(i%s); } return ans; } }; ST表 练习 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 //https://codeforces.com/problemset/problem/1709/D //正确理解题意-\u0026gt;贪心思考-\u0026gt;转换成RMQ问题-\u0026gt;ST表 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define For(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define _For(a,b,c) for(int a=(b);a\u0026gt;(c);a--) #define all(x) (x).begin(),x.end() #define inf 0x3f3f3f3f //对拍 #define fo1 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define fo2 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //输出数组 #define printA(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6; const int MOD=1e9+7; inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } inline void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;); x = -x; } if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } const int MAXN = 2e5 + 5; // 最大数组长度 const int MAXK = ceil(log2(MAXN)); // log2(MAXN) 向上取整 int a[MAXN]; // 输入数组 int st[MAXN][MAXK + 1]; // ST表 int Log2[MAXN]; void build(int n) { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; // 初始化第一列 } for (int j = 1; j \u0026lt;= MAXK; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = max(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); // 更新ST表 } } for (int i = 2; i \u0026lt;= n; ++i) Log2[i] = Log2[i / 2] + 1; } int query(int l, int r) { if (l \u0026gt; r) swap(l, r); int k = Log2[r - l + 1]; // 计算区间长度的对数，向下取整 return max(st[l][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); // 返回区间最小值 } int n,m; inline void hhhh(){ //todo int xs,ys,xe,ye,k; xs=read(); ys=read(); xe=read(); ye=read(); k=read(); // cout\u0026lt;\u0026lt;query(ys,ye)\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;(n-xs)/k*k+xs-1\u0026lt;\u0026lt;endl; if (xs%k!=xe%k||ys%k!=ye%k){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else if(query(ys,ye)\u0026gt;((n-xs)/k*k+xs-1)){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } else{ cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } int main() { n=read(); m=read(); For(i,1,m+1)a[i]=read(); build(m); int T; T=read(); while(T--){ hhhh(); } return 0; } DSU 练习 普通并查集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 // https://codeforces.com/problemset/problem/1411/C // 思维转换-\u0026gt;成环判断 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define For(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define _For(a,b,c) for(int a=(b);a\u0026gt;(c);a--) #define all(x) (x).begin(),x.end() #define inf 0x3f3f3f3f //对拍 #define fo1 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define fo2 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //输出数组 #define printA(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+5; const int MOD=1e9+7; inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } inline void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;); x = -x; } if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } int root[N]; int ranks[N]; int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (ranks[rootX] \u0026gt; ranks[rootY]) { root[rootY] = rootX; } else if (ranks[rootX] \u0026lt; ranks[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; ranks[rootX] += 1; } } } bool connected(int x, int y) { return find(x) == find(y); } inline void hhhh(){ int n=read(); int m=read(); For(i,0,n+2){ root[i]=i; ranks[i]=1; } int cnt=0; For(i,0,m){ int x=read(),y=read(); if(x!=y){ cnt++; if(connected(x,y))cnt++; else unionSet(x,y); } } write(cnt); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } int main() { //hhhh(); int T; T=read(); while(T--){ hhhh(); } return 0; } // https://codeforces.com/problemset/problem/371/D // 先写出直接模拟,然后思考如何优化过程-\u0026gt;并查集优化 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; // #define int long long #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define For(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define _For(a,b,c) for(int a=(b);a\u0026gt;(c);a--) #define all(x) (x).begin(),x.end() #define inf 0x3f3f3f3f //对拍 #define fo1 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define fo2 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //输出数组 #define printA(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; const int MOD=1e9+7; inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } inline void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;); x = -x; } if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } int a[N];//体积 int b[N];//水 ll root[N]; void initbuf(ll n){ for (ll i = 0; i \u0026lt;= n; i++) { root[i] = i; } } ll find(ll x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(ll x, ll y) { ll rootX = find(x); ll rootY = find(y); root[rootY] = rootX; } bool connected(ll x, ll y) { return find(x) == find(y); } inline void hhhh(){ int n=read(); For(i,1,n+1)a[i]=read(); initbuf(n); int m=read(); while(m--){ int num=read(); if(num==1){ int p=read(); int x=read(); int i=find(p); while(i\u0026lt;=n\u0026amp;\u0026amp;b[i]+x\u0026gt;=a[i]){ x-=a[i]-b[i]; b[i]=a[i]; if(p!=i)unionSet(i,i-1); i++; } if(i\u0026lt;=n){ if(p!=i)unionSet(i,i-1); b[i]+=x; } } else{ write(b[read()]); cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } } signed main() { hhhh(); return 0; } 分块 练习 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // https://codeforces.com/problemset/problem/103/D // 要维护区间离散的点用什么数据结构优化??线段树,树状数组不合适-\u0026gt;优雅暴力:分块 // DP/暴力 根号区分 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define int long long #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define For(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define _For(a,b,c) for(int a=(b);a\u0026gt;(c);a--) #define all(x) (x).begin(),x.end() #define inf 0x3f3f3f3f //对拍 #define fo1 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define fo2 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //输出数组 #define printA(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e5+5; const int MOD=1e9+7; inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } inline void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;); x = -x; } if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } int w[N]; int ans[N]; int n; int x; vector\u0026lt;pii\u0026gt; hashA[N]; int dp[N*2]; inline void hhhh(){ int p=read(); // cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; For(i,0,p){ int a=read(),b=read(); if(b\u0026gt;x){ int res=0; for(int j=a;j\u0026lt;=n;j+=b){ res+=w[j]; } ans[i]=res; } else{ hashA[b].push_back(make_pair(a,i)); } } For(i,1,x+1){ if(hashA[i].size()){ _For(j,n,0) dp[j]=dp[j+i]+w[j]; For(k,0,hashA[i].size()){ ans[hashA[i][k].second]=dp[hashA[i][k].first]; } memset(dp,0,sizeof dp); } } For(i,0,p){ cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } signed main() { n=read(); x=sqrt(n); For(i,1,n+1)w[i]=read(); hhhh(); return 0; } 线段树 练习 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 // https://codeforces.com/problemset/problem/339/D //虽然是单点修改和区间查询,但是因为要分奇数偶数层,所以不方便用树状数组 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; // #define int long long #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define For(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define _For(a,b,c) for(int a=(b);a\u0026gt;(c);a--) #define all(x) (x).begin(),x.end() #define inf 0x3f3f3f3f //对拍 #define fo1 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define fo2 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //输出数组 #define printA(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; const int MOD=1e9+7; inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } inline void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;); x = -x; } if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } const int MAXN=(1\u0026lt;\u0026lt;17)+9; //开4倍 //n 为维护的数组长度，A为维护的数组 ll tree[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; int flag=1; void push_up(int p){ //这里维护的是区间和 if(flag==1){ tree[p] = tree[p \u0026lt;\u0026lt; 1]|tree[p \u0026lt;\u0026lt; 1 | 1]; } else{ tree[p] = tree[p \u0026lt;\u0026lt; 1]^tree[p \u0026lt;\u0026lt; 1 | 1]; } flag^=1; } void build(int p = 1, int cl = 1, int cr = n) { //如果叶子节点 if (cl == cr) { tree[p] = A[cl]; flag=1; return; } //左右递归建树 int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p]=d * (cr - cl + 1); flag=1; return; } int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } inline void hhhh(){ int x=read(),m=read(); n=1\u0026lt;\u0026lt;x; For(i,1,n+1)A[i]=read(); build(); while(m--){ int p=read(),b=read(); update(p,p,b); cout\u0026lt;\u0026lt;tree[1]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } } signed main() { hhhh(); return 0; } ","date":"2023-06-04T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/dsall/","title":"数据结构学习合集"},{"content":"写在前面 难度: 中等简单中等困难 前三题均为思维题 最后一题比较板\nT1 最小化字符串长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 给你一个下标从 0 开始的字符串 s ，重复执行下述操作 任意 次： 在字符串中选出一个下标 i ，并使 c 为字符串下标 i 处的字符。并在 i 左侧（如果有）和 右侧（如果有）各 删除 一个距离 i 最近 的字符 c 。 请你通过执行上述操作任意次，使 s 的长度 最小化 。 返回一个表示 最小化 字符串的长度的整数。 示例 1： 输入：s = \u0026#34;aaabc\u0026#34; 输出：3 解释：在这个示例中，s 等于 \u0026#34;aaabc\u0026#34; 。我们可以选择位于下标 1 处的字符 \u0026#39;a\u0026#39; 开始。接着删除下标 1 左侧最近的那个 \u0026#39;a\u0026#39;（位于下标 0）以及下标 1 右侧最近的那个 \u0026#39;a\u0026#39;（位于下标 2）。执行操作后，字符串变为 \u0026#34;abc\u0026#34; 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 3 。 示例 2： 输入：s = \u0026#34;cbbd\u0026#34; 输出：3 解释：我们可以选择位于下标 1 处的字符 \u0026#39;b\u0026#39; 开始。下标 1 左侧不存在字符 \u0026#39;b\u0026#39; ，但右侧存在一个字符 \u0026#39;b\u0026#39;（位于下标 2），所以会删除位于下标 2 的字符 \u0026#39;b\u0026#39; 。执行操作后，字符串变为 \u0026#34;cbd\u0026#34; 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 3 。 示例 3： 输入：s = \u0026#34;dddaaa\u0026#34; 输出：2 解释：我们可以选择位于下标 1 处的字符 \u0026#39;d\u0026#39; 开始。接着删除下标 1 左侧最近的那个 \u0026#39;d\u0026#39;（位于下标 0）以及下标 1 右侧最近的那个 \u0026#39;d\u0026#39;（位于下标 2）。执行操作后，字符串变为 \u0026#34;daaa\u0026#34; 。继续对新字符串执行操作，可以选择位于下标 2 的字符 \u0026#39;a\u0026#39; 。接着删除下标 2 左侧最近的那个 \u0026#39;a\u0026#39;（位于下标 1）以及下标 2 右侧最近的那个 \u0026#39;a\u0026#39;（位于下标 3）。执行操作后，字符串变为 \u0026#34;da\u0026#34; 。继续对字符串执行任何操作都不会改变其长度。因此，最小化字符串的长度是 2 。 提示： 1 \u0026lt;= s.length \u0026lt;= 100 s 仅由小写英文字母组成 思路 手玩几个即可得出结论: 结果等于有多少个不同的字符\n结论的简单证明: 由于题目是删除最近的c字符,因此重新排序对结果没有影响 为了使证明更直观,我们重新排序,将所有相同字符的放在一起 要证明 结果等于有多少个不同的字符等价于证明所有相同字符无论多长都能删除到只剩下一个 当相同字符长度为1时,显然成立 当长为2时也成立 设相同字符长度为n和n-1(n-1\u0026gt;2)时,也能能删除到只剩下一个 则当相同字符长度为n+1时,由于通过定义我们可以删除第n个字符的左右,则长度变为n-1,又因为n-1可以删除到只剩下一个,所以对于长度为n+1也成立 由于4 5 6 7可知所有相同字符无论多长都能删除到只剩下一个成立 综上,结论成立 code 1 2 3 4 5 6 7 8 9 10 class Solution { public: int minimizedStringLength(string s) { set\u0026lt;char\u0026gt; ss; for(auto i:s){ ss.insert(i); } return ss.size(); } }; T2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 给你一个下标从 0 开始、长度为 n 的整数排列 nums 。 如果排列的第一个数字等于 1 且最后一个数字等于 n ，则称其为 半有序排列 。你可以执行多次下述操作，直到将 nums 变成一个 半有序排列 ： 选择 nums 中相邻的两个元素，然后交换它们。 返回使 nums 变成 半有序排列 所需的最小操作次数。 排列 是一个长度为 n 的整数序列，其中包含从 1 到 n 的每个数字恰好一次。 示例 1： 输入：nums = [2,1,4,3] 输出：2 解释：可以依次执行下述操作得到半有序排列： 1 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。 2 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。 可以证明，要让 nums 成为半有序排列，不存在执行操作少于 2 次的方案。 示例 2： 输入：nums = [2,4,1,3] 输出：3 解释： 可以依次执行下述操作得到半有序排列： 1 - 交换下标 1 和下标 2 对应元素。排列变为 [2,1,4,3] 。 2 - 交换下标 0 和下标 1 对应元素。排列变为 [1,2,4,3] 。 3 - 交换下标 2 和下标 3 对应元素。排列变为 [1,2,3,4] 。 可以证明，要让 nums 成为半有序排列，不存在执行操作少于 3 次的方案。 示例 3： 输入：nums = [1,3,4,2,5] 输出：0 解释：这个排列已经是一个半有序排列，无需执行任何操作。 提示： 2 \u0026lt;= nums.length == n \u0026lt;= 50 1 \u0026lt;= nums[i] \u0026lt;= 50 nums 是一个 排列 思路 贪心,可以看出要次数最小,1不可能往右交换,len不可能往左 那找到各个下标即可\n然后如果len在1左边,记得答案减一/下标+1即可(或者先算len,那就反过来)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution: def semiOrderedPermutation(self, nums: List[int]) -\u0026gt; int: n=len(nums) if nums[0]==1 and nums[-1]==n: return 0 p1=pn=-1 for i,j in enumerate(nums): if j==1: p1=i elif j==n: pn=i if pn\u0026lt;p1: pn+=1 return p1+n-pn-1 T3 1 2 3 4 5 6 7 8 给你一个整数 n 和一个下标从 0 开始的 二维数组 queries ，其中 queries[i] = [typei, indexi, vali] 。 一开始，给你一个下标从 0 开始的 n x n 矩阵，所有元素均为 0 。每一个查询，你需要执行以下操作之一： 如果 typei == 0 ，将第 indexi 行的元素全部修改为 vali ，覆盖任何之前的值。 如果 typei == 1 ，将第 indexi 列的元素全部修改为 vali ，覆盖任何之前的值。 请你执行完所有查询以后，返回矩阵中所有整数的和。 示例 1： 1 2 3 输入：n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]] 输出：23 解释：上图展示了每个查询以后矩阵的值。所有操作执行完以后，矩阵元素之和为 23 。 示例 2： 1 2 3 输入：n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]] 输出：17 解释：上图展示了每一个查询操作之后的矩阵。所有操作执行完以后，矩阵元素之和为 17 。 1 2 3 4 5 6 7 8 提示： 1 \u0026lt;= n \u0026lt;= 104 1 \u0026lt;= queries.length \u0026lt;= 5 * 104 queries[i].length == 3 0 \u0026lt;= typei \u0026lt;= 1 0 \u0026lt;= indexi \u0026lt; n 0 \u0026lt;= vali \u0026lt;= 105 思路 正难则反,思维题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution: def matrixSumQueries(self, n: int, queries: List[List[int]]) -\u0026gt; int: row=set() col=set() ans=0 for i in range(len(queries)-1,-1,-1): t,j,v=queries[i] if t==1: if j not in col: ans+=(n-len(row))*v col.add(j) if t==0: if j not in row: ans+=(n-len(col))*v row.add(j) return ans T4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 给你两个数字字符串 num1 和 num2 ，以及两个整数 max_sum 和 min_sum 。如果一个整数 x 满足以下条件，我们称它是一个好整数： num1 \u0026lt;= x \u0026lt;= num2 min_sum \u0026lt;= digit_sum(x) \u0026lt;= max_sum. 请你返回好整数的数目。答案可能很大，请返回答案对 109 + 7 取余后的结果。 注意，digit_sum(x) 表示 x 各位数字之和。 示例 1： 输入：num1 = \u0026#34;1\u0026#34;, num2 = \u0026#34;12\u0026#34;, min_num = 1, max_num = 8 输出：11 解释：总共有 11 个整数的数位和在 1 到 8 之间，分别是 1,2,3,4,5,6,7,8,10,11 和 12 。所以我们返回 11 。 示例 2： 输入：num1 = \u0026#34;1\u0026#34;, num2 = \u0026#34;5\u0026#34;, min_num = 1, max_num = 5 输出：5 解释：数位和在 1 到 5 之间的 5 个整数分别为 1,2,3,4 和 5 。所以我们返回 5 。 提示： 1 \u0026lt;= num1 \u0026lt;= num2 \u0026lt;= 1022 1 \u0026lt;= min_sum \u0026lt;= max_sum \u0026lt;= 400 注: 1022=$10^{22}$\n思路 数位DP,这里是直接改的板子,is_num其实不需要\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution: def S(self,s: str,min_sum: int, max_sum: int): @cache def f(i: int, mask: int, is_limit: bool, is_num: bool) -\u0026gt; int: if max_sum\u0026lt;mask: return 0 if i == len(s): return int(mask\u0026gt;=min_sum) res = 0 low = 0 if is_num else 1 up = int(s[i]) if is_limit else 9 for d in range(low, up + 1): res += f(i + 1, mask+d, is_limit and d == up, True) return res%int(1e9+7) return f(0, 0, True, True) def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -\u0026gt; int: return self.S(num2,min_sum,max_sum)-self.S(num1,min_sum,max_sum)+(min_sum \u0026lt;= sum(map(int, num1)) \u0026lt;= max_sum) ","date":"2023-06-03T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-348/","title":"lc weekly contest 348"},{"content":"既不是最小值也不是最大值 题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 给你一个整数数组 nums ，数组由 不同正整数 组成，请你找出并返回数组中 任一 既不是 最小值 也不是 最大值 的数字，如果不存在这样的数字，返回 -1 。 返回所选整数。 示例 1： 输入：nums = [3,2,1,4] 输出：2 解释：在这个示例中，最小值是 1 ，最大值是 4 。因此，2 或 3 都是有效答案。 示例 2： 输入：nums = [1,2] 输出：-1 解释：由于不存在既不是最大值也不是最小值的数字，我们无法选出满足题目给定条件的数字。因此，不存在答案，返回 -1 。 示例 3： 输入：nums = [2,1,3] 输出：2 解释：2 既不是最小值，也不是最大值，这个示例只有这一个有效答案。 提示： 1 \u0026lt;= nums.length \u0026lt;= 100 1 \u0026lt;= nums[i] \u0026lt;= 100 nums 中的所有数字互不相同 代码 模拟即可\n1 2 3 4 5 6 class Solution: def findNonMinOrMax(self, nums: List[int]) -\u0026gt; int: if len(nums)\u0026lt;=2: return -1 nums.sort() return nums[1] 执行子串操作后的字典序最小字符串 题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以完成以下行为： 选则 s 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，\u0026#39;b\u0026#39; 用 \u0026#39;a\u0026#39; 替换，\u0026#39;a\u0026#39; 用 \u0026#39;z\u0026#39; 替换。 返回执行上述操作 恰好一次 后可以获得的 字典序最小 的字符串。 子字符串 是字符串中的一个连续字符序列。 现有长度相同的两个字符串 x 和 字符串 y ，在满足 x[i] != y[i] 的第一个位置 i 上，如果 x[i] 在字母表中先于 y[i] 出现，则认为字符串 x 比字符串 y 字典序更小 。 示例 1： 输入：s = \u0026#34;cbabc\u0026#34; 输出：\u0026#34;baabc\u0026#34; 解释：我们选择从下标 0 开始、到下标 1 结束的子字符串执行操作。 可以证明最终得到的字符串是字典序最小的。 示例 2： 输入：s = \u0026#34;acbbc\u0026#34; 输出：\u0026#34;abaab\u0026#34; 解释：我们选择从下标 1 开始、到下标 4 结束的子字符串执行操作。 可以证明最终得到的字符串是字典序最小的。 示例 3： 输入：s = \u0026#34;leetcode\u0026#34; 输出：\u0026#34;kddsbncd\u0026#34; 解释：我们选择整个字符串执行操作。 可以证明最终得到的字符串是字典序最小的。 提示： 1 \u0026lt;= s.length \u0026lt;= 3 * 105 s 仅由小写英文字母组成 代码 贪心+滑窗找到第一段非a的最大字段长度 注意特判全是a的情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution: def smallestString(self, s: str) -\u0026gt; str: ans=\u0026#34;\u0026#34; flag=1 l=r=-1 size=len(s) # 找第一段非a的最大字段长度 for i in range(size): if flag and s[i]!=\u0026#39;a\u0026#39;: l=r=i # [l,r) while r\u0026lt;size and s[r]!=\u0026#39;a\u0026#39;: r+=1 flag=0 break for i in range(size): if i==size-1 and s[i]==\u0026#39;a\u0026#39; and flag: ans+=\u0026#39;z\u0026#39; break if l\u0026lt;=i\u0026lt;r: ans+=chr(ord(s[i])-1) else: ans+=s[i] return ans 收集巧克力 题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 给你一个长度为 n 、下标从 0 开始的整数数组 nums ，表示收集不同巧克力的成本。每个巧克力都对应一个不同的类型，最初，位于下标 i 的巧克力就对应第 i 个类型。 在一步操作中，你可以用成本 x 执行下述行为： 同时对于所有下标 0 \u0026lt;= i \u0026lt; n - 1 进行以下操作， 将下标 i 处的巧克力的类型更改为下标 (i + 1) 处的巧克力对应的类型。如果 i == n - 1 ，则该巧克力的类型将会变更为下标 0 处巧克力对应的类型。 假设你可以执行任意次操作，请返回收集所有类型巧克力所需的最小成本。 示例 1： 输入：nums = [20,1,15], x = 5 输出：13 解释：最开始，巧克力的类型分别是 [0,1,2] 。我们可以用成本 1 购买第 1 个类型的巧克力。 接着，我们用成本 5 执行一次操作，巧克力的类型变更为 [2,0,1] 。我们可以用成本 1 购买第 0 个类型的巧克力。 然后，我们用成本 5 执行一次操作，巧克力的类型变更为 [1,2,0] 。我们可以用成本 1 购买第 2 个类型的巧克力。 因此，收集所有类型的巧克力需要的总成本是 (1 + 5 + 1 + 5 + 1) = 13 。可以证明这是一种最优方案。 示例 2： 输入：nums = [1,2,3], x = 4 输出：6 解释：我们将会按最初的成本收集全部三个类型的巧克力，而不需执行任何操作。因此，收集所有类型的巧克力需要的总成本是 1 + 2 + 3 = 6 。 提示： 1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i] \u0026lt;= 109 1 \u0026lt;= x \u0026lt;= 109 代码 涉及全部区间操作,考虑枚举每次操作\n看数据范围O(n2)做法即可 找规律(见下)-\u0026gt;枚举每次操作-\u0026gt;转换为RMQ问题 容易看出转移方程,用DP预处理RMQ即可(也可以ST表/压为O(n)空间DP)\n事实上这里RMQ预处理转化为NGE问题(单调栈)只需要O(n)时间复杂度1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution: def minCost(self, nums: List[int], x: int) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34; 顺序影响? Y 规律: [a,b,c,d] x [0,1,2,3] 0: a x+b 2*x+c 3*x+d 1: b x+c 2*x+d 3*x+a 2: c x+d 2*x+a 3*x+b 3: d x+a 2*x+b 3*x+c 基础花费: sum(nums) 特殊花费(最高移动为cost): cost=0 a+b+c+d cost=1 min(a,b)+min(b,c)+min(c,d)+min(a,d) + x cost=2 min(a,b,c)+min(b,c,d)+min(c,d,a)+min(d,a,b)+2*x cost=3: min(a,b,c,d)*4+3*x \u0026#34;\u0026#34;\u0026#34; cost0=sum(nums) size=len(nums) dp=[[0]*size for _ in range(size)] for i in range(len(nums)): dp[0][i]=nums[i] ans=cost0 for i in range(1,len(nums)): cnt=0 for j in range(len(nums)): k=j+1 if j+1\u0026lt;len(nums) else 0 dp[i][j]=min(dp[i-1][j],dp[i-1][k]) cnt+=dp[i][j] ans=min(ans,cnt+i*x) return ans 最大和查询 题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 给你两个长度为 n 、下标从 0 开始的整数数组 nums1 和 nums2 ，另给你一个下标从 1 开始的二维数组 queries ，其中 queries[i] = [xi, yi] 。 对于第 i 个查询，在所有满足 nums1[j] \u0026gt;= xi 且 nums2[j] \u0026gt;= yi 的下标 j (0 \u0026lt;= j \u0026lt; n) 中，找出 nums1[j] + nums2[j] 的 最大值 ，如果不存在满足条件的 j 则返回 -1 。 返回数组 answer ，其中 answer[i] 是第 i 个查询的答案。 示例 1： 输入：nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]] 输出：[6,10,7] 解释： 对于第 1 个查询：xi = 4 且 yi = 1 ，可以选择下标 j = 0 ，此时 nums1[j] \u0026gt;= 4 且 nums2[j] \u0026gt;= 1 。nums1[j] + nums2[j] 等于 6 ，可以证明 6 是可以获得的最大值。 对于第 2 个查询：xi = 1 且 yi = 3 ，可以选择下标 j = 2 ，此时 nums1[j] \u0026gt;= 1 且 nums2[j] \u0026gt;= 3 。nums1[j] + nums2[j] 等于 10 ，可以证明 10 是可以获得的最大值。 对于第 3 个查询：xi = 2 且 yi = 5 ，可以选择下标 j = 3 ，此时 nums1[j] \u0026gt;= 2 且 nums2[j] \u0026gt;= 5 。nums1[j] + nums2[j] 等于 7 ，可以证明 7 是可以获得的最大值。 因此，我们返回 [6,10,7] 。 示例 2： 输入：nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]] 输出：[9,9,9] 解释：对于这个示例，我们可以选择下标 j = 2 ，该下标可以满足每个查询的限制。 示例 3： 输入：nums1 = [2,1], nums2 = [2,3], queries = [[3,3]] 输出：[-1] 解释：示例中的查询 xi = 3 且 yi = 3 。对于每个下标 j ，都只满足 nums1[j] \u0026lt; xi 或者 nums2[j] \u0026lt; yi 。因此，不存在答案。 提示： nums1.length == nums2.length n == nums1.length 1 \u0026lt;= n \u0026lt;= 105 1 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 109 1 \u0026lt;= queries.length \u0026lt;= 105 queries[i].length == 2 xi == queries[i][1] yi == queries[i][2] 1 \u0026lt;= xi, yi \u0026lt;= 109 代码 线段树维护(离散化/动态开点)\n1 2 3 4 5 class Solution { public: vector\u0026lt;int\u0026gt; maximumSumQueries(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { } }; 源自何老师的题解\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-06-03T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-349/","title":"lc weekly contest 349"},{"content":"写在前面 T1 数组能形成多少数对 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 给你一个下标从 0 开始的整数数组 nums 。在一步操作中，你可以执行以下步骤： 从 nums 选出 两个 相等的 整数 从 nums 中移除这两个整数，形成一个 数对 请你在 nums 上多次执行此操作直到无法继续执行。 返回一个下标从 0 开始、长度为 2 的整数数组 answer 作为答案，其中 answer[0] 是形成的数对数目，answer[1] 是对 nums 尽可能执行上述操作后剩下的整数数目。 示例 1： 输入：nums = [1,3,2,1,3,2,2] 输出：[3,1] 解释： nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。 nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。 nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。 无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。 示例 2： 输入：nums = [1,1] 输出：[1,0] 解释：nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [] 。 无法形成更多数对。总共形成 1 个数对，nums 中剩下 0 个数字。 示例 3： 输入：nums = [0] 输出：[0,1] 解释：无法形成数对，nums 中剩下 1 个数字。 提示： 1 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 100 思路 哈希记录数量再按照题目模拟(这里为了快用了py的Counter)\n1 2 3 4 5 6 7 8 9 10 11 class Solution: def numberOfPairs(self, nums: List[int]) -\u0026gt; List[int]: x=Counter(nums) print(x) cnt=0 p=0 for i in x.keys(): if x[i]\u0026amp;1: cnt+=x[i]%2 p+=x[i]//2 return [p,cnt] T2 数位和相等数对的最大和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 给你一个下标从 0 开始的数组 nums ，数组中的元素都是 正 整数。请你选出两个下标 i 和 j（i != j），且 nums[i] 的数位和 与 nums[j] 的数位和相等。 请你找出所有满足条件的下标 i 和 j ，找出并返回 nums[i] + nums[j] 可以得到的 最大值 。 示例 1： 输入：nums = [18,43,36,13,7] 输出：54 解释：满足条件的数对 (i, j) 为： - (0, 2) ，两个数字的数位和都是 9 ，相加得到 18 + 36 = 54 。 - (1, 4) ，两个数字的数位和都是 7 ，相加得到 43 + 7 = 50 。 所以可以获得的最大和是 54 。 示例 2： 输入：nums = [10,12,19,14] 输出：-1 解释：不存在满足条件的数对，返回 -1 。 提示： 1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 109 思路 类同leetcode第一题两数之和 哈希条件改一下即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int getS(int n){ int ans=0; while(n){ ans+=n%10; n/=10; } return ans; } int maximumSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { map\u0026lt;int,int\u0026gt; mm; int res=-1; for(auto i:nums){ int p=getS(i); if(mm.count(p)){ res=max(res,mm[p]+i); mm[p]=max(mm[p],i); } else{ mm.insert(make_pair(p,i)); } } return res; } }; T4使数组可以被整除的最少删除次数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 给你两个正整数数组 nums 和 numsDivide 。你可以从 nums 中删除任意数目的元素。 请你返回使 nums 中 最小 元素可以整除 numsDivide 中所有元素的 最少 删除次数。如果无法得到这样的元素，返回 -1 。 如果 y % x == 0 ，那么我们说整数 x 整除 y 。 示例 1： 输入：nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15] 输出：2 解释： [2,3,2,4,3] 中最小元素是 2 ，它无法整除 numsDivide 中所有元素。 我们从 nums 中删除 2 个大小为 2 的元素，得到 nums = [3,4,3] 。 [3,4,3] 中最小元素为 3 ，它可以整除 numsDivide 中所有元素。 可以证明 2 是最少删除次数。 示例 2： 输入：nums = [4,3,6], numsDivide = [8,2,6,10] 输出：-1 解释： 我们想 nums 中的最小元素可以整除 numsDivide 中的所有元素。 没有任何办法可以达到这一目的。 提示： 1 \u0026lt;= nums.length, numsDivide.length \u0026lt;= 105 1 \u0026lt;= nums[i], numsDivide[i] \u0026lt;= 109 思路 数学,先求出gcd,然后遍历一遍数组看看有没有gcd的因数即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution: def minOperations(self, nums: List[int], numsDivide: List[int]) -\u0026gt; int: nums.sort() x=numsDivide[0] for i in numsDivide: x=gcd(x,i) # print(x) p=0 while p\u0026lt;=len(nums): if p==len(nums): p=-1 break if x%nums[p]==0: break p+=1 return p ","date":"2023-06-01T00:00:00Z","image":"https://pic.lingkou.xyz/1657181817-GjoGBU-1760-360%20%E5%8D%83%E6%8C%82%E7%A7%91%E6%8A%80.png","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-302/","title":"lc weekly contest 302"},{"content":"此次教学课程为硅谷甄选运营平台项目,包含运营平台项目模板从0到1开发，以及数据大屏幕、权限等业务。\n此次教学课程涉及到技术栈包含***:vue3+TypeScript+vue-router+pinia+element-plus+axios+echarts***等技术栈。\n一、vue3组件通信方式 通信仓库地址:https://gitee.com/jch1011/vue3_communication.git\n不管是vue2还是vue3,组件通信方式很重要,不管是项目还是面试都是经常用到的知识点。\n比如:vue2组件通信方式\n**props:**可以实现父子组件、子父组件、甚至兄弟组件通信\n自定义事件:可以实现子父组件通信\n全局事件总线$bus:可以实现任意组件通信\n**pubsub:**发布订阅模式实现任意组件通信\nvuex:集中式状态管理容器，实现任意组件通信\nref:父组件获取子组件实例VC,获取子组件的响应式数据以及方法\n**slot:**插槽(默认插槽、具名插槽、作用域插槽)实现父子组件通信\u0026hellip;\u0026hellip;..\n1.1props props可以实现父子组件通信,在vue3中我们可以通过defineProps获取父组件传递的数据。且在组件内部不需要引入defineProps方法可以直接使用！\n父组件给子组件传递数据\n1 \u0026lt;Child info=\u0026#34;我爱祖国\u0026#34; :money=\u0026#34;money\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; 子组件获取父组件传递数据:方式1\n1 2 3 4 5 6 7 8 9 let props = defineProps({ info:{ type:String,//接受的数据类型 default:\u0026#39;默认参数\u0026#39;,//接受默认数据 }, money:{ type:Number, default:0 }}) 子组件获取父组件传递数据:方式2\n1 let props = defineProps([\u0026#34;info\u0026#34;,\u0026#39;money\u0026#39;]); 子组件获取到props数据就可以在模板中使用了,但是切记props是只读的(只能读取，不能修改)\n1.2自定义事件 在vue框架中事件分为两种:一种是原生的DOM事件，另外一种自定义事件。\n原生DOM事件可以让用户与网页进行交互，比如click、dbclick、change、mouseenter、mouseleave\u0026hellip;.\n自定义事件可以实现子组件给父组件传递数据\n1.2.1原生DOM事件 代码如下:\n1 2 3 \u0026lt;pre @click=\u0026#34;handler\u0026#34;\u0026gt; 我是祖国的老花骨朵 \u0026lt;/pre\u0026gt; 当前代码级给pre标签绑定原生DOM事件点击事件,默认会给事件回调注入event事件对象。当然点击事件想注入多个参数可以按照下图操作。但是切记注入的事件对象务必叫做$event.\n1 \u0026lt;div @click=\u0026#34;handler1(1,2,3,$event)\u0026#34;\u0026gt;我要传递多个参数\u0026lt;/div\u0026gt; 在vue3框架click、dbclick、change(这类原生DOM事件),不管是在标签、自定义标签上(组件标签)都是原生DOM事件。\n1.2.2自定义事件 自定义事件可以实现子组件给父组件传递数据.在项目中是比较常用的。\n比如在父组件内部给子组件(Event2)绑定一个自定义事件\n1 \u0026lt;Event2 @xxx=\u0026#34;handler3\u0026#34;\u0026gt;\u0026lt;/Event2\u0026gt; 在Event2子组件内部触发这个自定义事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;我是子组件2\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;handler\u0026#34;\u0026gt;点击我触发xxx自定义事件\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; let $emit = defineEmits([\u0026#34;xxx\u0026#34;]); const handler = () =\u0026gt; { $emit(\u0026#34;xxx\u0026#34;, \u0026#34;法拉利\u0026#34;, \u0026#34;茅台\u0026#34;); }; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 我们会发现在script标签内部,使用了defineEmits方法，此方法是vue3提供的方法,不需要引入直接使用。defineEmits方法执行，传递一个数组，数组元素即为将来组件需要触发的自定义事件类型，此方执行会返回一个$emit方法用于触发自定义事件。\n当点击按钮的时候，事件回调内部调用$emit方法去触发自定义事件,第一个参数为触发事件类型，第二个、三个、N个参数即为传递给父组件的数据。\n需要注意的是:代码如下\n1 \u0026lt;Event2 @xxx=\u0026#34;handler3\u0026#34; @click=\u0026#34;handler\u0026#34;\u0026gt;\u0026lt;/Event2\u0026gt; 正常说组件标签书写@click应该为原生DOM事件,但是如果子组件内部通过defineEmits定义就变为自定义事件了\n1 let $emit = defineEmits([\u0026#34;xxx\u0026#34;,\u0026#39;click\u0026#39;]); 1.3全局事件总线 全局事件总线可以实现任意组件通信，在vue2中可以根据VM与VC关系推出全局事件总线。\n但是在vue3中没有Vue构造函数，也就没有Vue.prototype.以及组合式API写法没有this，\n那么在Vue3想实现全局事件的总线功能就有点不现实啦，如果想在Vue3中使用全局事件总线功能\n可以使用插件mitt实现。\nmitt:官网地址:https://www.npmjs.com/package/mitt\n1.4v-model v-model指令可是收集表单数据(数据双向绑定)，除此之外它也可以实现父子组件数据同步。\n而v-model实指利用props[modelValue]与自定义事件[update:modelValue]实现的。\n下方代码:相当于给组件Child传递一个props(modelValue)与绑定一个自定义事件update:modelValue\n实现父子组件数据同步\n1 \u0026lt;Child v-model=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; 在vue3中一个组件可以通过使用多个v-model,让父子组件多个数据同步,下方代码相当于给组件Child传递两个props分别是pageNo与pageSize，以及绑定两个自定义事件update:pageNo与update:pageSize实现父子数据同步\n1 \u0026lt;Child v-model:pageNo=\u0026#34;msg\u0026#34; v-model:pageSize=\u0026#34;msg1\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; 1.5useAttrs 在Vue3中可以利用useAttrs方法获取组件的属性与事件(包含:原生DOM事件或者自定义事件),次函数功能类似于Vue2框架中$attrs属性与$listeners方法。\n比如:在父组件内部使用一个子组件my-button\n1 \u0026lt;my-button type=\u0026#34;success\u0026#34; size=\u0026#34;small\u0026#34; title=\u0026#39;标题\u0026#39; @click=\u0026#34;handler\u0026#34;\u0026gt;\u0026lt;/my-button\u0026gt; 子组件内部可以通过useAttrs方法获取组件属性与事件.因此你也发现了，它类似于props,可以接受父组件传递过来的属性与属性值。需要注意如果defineProps接受了某一个属性，useAttrs方法返回的对象身上就没有相应属性与属性值。\n1 2 3 4 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {useAttrs} from \u0026#39;vue\u0026#39;; let $attrs = useAttrs(); \u0026lt;/script\u0026gt; 1.6ref与$parent ref,提及到ref可能会想到它可以获取元素的DOM或者获取子组件实例的VC。既然可以在父组件内部通过ref获取子组件实例VC，那么子组件内部的方法与响应式数据父组件可以使用的。\n比如:在父组件挂载完毕获取组件实例\n父组件内部代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;ref与$parent\u0026lt;/h1\u0026gt; \u0026lt;Son ref=\u0026#34;son\u0026#34;\u0026gt;\u0026lt;/Son\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Son from \u0026#34;./Son.vue\u0026#34;; import { onMounted, ref } from \u0026#34;vue\u0026#34;; const son = ref(); onMounted(() =\u0026gt; { console.log(son.value); }); \u0026lt;/script\u0026gt; 但是需要注意，如果想让父组件获取子组件的数据或者方法需要通过defineExpose对外暴露,因为vue3中组件内部的数据对外“关闭的”，外部不能访问\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; //数据 let money = ref(1000); //方法 const handler = ()=\u0026gt;{ } defineExpose({ money, handler }) \u0026lt;/script\u0026gt; $parent可以获取某一个组件的父组件实例VC,因此可以使用父组件内部的数据与方法。必须子组件内部拥有一个按钮点击时候获取父组件实例，当然父组件的数据与方法需要通过defineExpose方法对外暴露\n1 \u0026lt;button @click=\u0026#34;handler($parent)\u0026#34;\u0026gt;点击我获取父组件实例\u0026lt;/button\u0026gt; 1.7provide与inject provide[提供]\ninject[注入]\nvue3提供两个方法provide与inject,可以实现隔辈组件传递参数\n组件组件提供数据:\nprovide方法用于提供数据，此方法执需要传递两个参数,分别提供数据的key与提供数据value\n1 2 3 4 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {provide} from \u0026#39;vue\u0026#39; provide(\u0026#39;token\u0026#39;,\u0026#39;admin_token\u0026#39;); \u0026lt;/script\u0026gt; 后代组件可以通过inject方法获取数据,通过key获取存储的数值\n1 2 3 4 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {inject} from \u0026#39;vue\u0026#39; let token = inject(\u0026#39;token\u0026#39;); \u0026lt;/script\u0026gt; 1.8pinia pinia官网:https://pinia.web3doc.top/\npinia也是集中式管理状态容器,类似于vuex。但是核心概念没有mutation、modules,使用方式参照官网\n1.9slot 插槽：默认插槽、具名插槽、作用域插槽可以实现父子组件通信.\n默认插槽:\n在子组件内部的模板中书写slot全局组件标签\n1 2 3 4 5 6 7 8 9 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 在父组件内部提供结构：Todo即为子组件,在父组件内部使用的时候，在双标签内部书写结构传递给子组件\n注意开发项目的时候默认插槽一般只有一个\n1 2 3 \u0026lt;Todo\u0026gt; \u0026lt;h1\u0026gt;我是默认插槽填充的结构\u0026lt;/h1\u0026gt; \u0026lt;/Todo\u0026gt; 具名插槽：\n顾名思义，此插槽带有名字在组件内部留多个指定名字的插槽。\n下面是一个子组件内部,模板中留两个插槽\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;todo\u0026lt;/h1\u0026gt; \u0026lt;slot name=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;b\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 父组件内部向指定的具名插槽传递结构。需要注意v-slot：可以替换为#\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;slot\u0026lt;/h1\u0026gt; \u0026lt;Todo\u0026gt; \u0026lt;template v-slot:a\u0026gt; //可以用#a替换 \u0026lt;div\u0026gt;填入组件A部分的结构\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:b\u0026gt;//可以用#b替换 \u0026lt;div\u0026gt;填入组件B部分的结构\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Todo\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Todo from \u0026#34;./Todo.vue\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 作用域插槽\n作用域插槽：可以理解为，子组件数据由父组件提供，但是子组件内部决定不了自身结构与外观(样式)\n子组件Todo代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;todo\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!--组件内部遍历数组--\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in todos\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;!--作用域插槽将数据回传给父组件--\u0026gt; \u0026lt;slot :$row=\u0026#34;item\u0026#34; :$index=\u0026#34;index\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; defineProps([\u0026#39;todos\u0026#39;]);//接受父组件传递过来的数据 \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 父组件内部代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;slot\u0026lt;/h1\u0026gt; \u0026lt;Todo :todos=\u0026#34;todos\u0026#34;\u0026gt; \u0026lt;template v-slot=\u0026#34;{$row,$index}\u0026#34;\u0026gt; \u0026lt;!--父组件决定子组件的结构与外观--\u0026gt; \u0026lt;span :style=\u0026#34;{color:$row.done?\u0026#39;green\u0026#39;:\u0026#39;red\u0026#39;}\u0026#34;\u0026gt;{{$row.title}}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Todo\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Todo from \u0026#34;./Todo.vue\u0026#34;; import { ref } from \u0026#34;vue\u0026#34;; //父组件内部数据 let todos = ref([ { id: 1, title: \u0026#34;吃饭\u0026#34;, done: true }, { id: 2, title: \u0026#34;睡觉\u0026#34;, done: false }, { id: 3, title: \u0026#34;打豆豆\u0026#34;, done: true }, ]); \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt; \u0026lt;/style\u0026gt; 二、搭建后台管理系统模板 2.1项目初始化 今天来带大家从0开始搭建一个vue3版本的后台管理系统。一个项目要有统一的规范，需要使用eslint+stylelint+prettier来对我们的代码质量做检测和修复，需要使用husky来做commit拦截，需要使用commitlint来统一提交规范，需要使用preinstall来统一包管理工具。\n下面我们就用这一套规范来初始化我们的项目，集成一个规范的模版。\n2.1.1环境准备 node v16.14.2 pnpm 8.0.0 2.1.2初始化项目 本项目使用vite进行构建，vite官方中文文档参考：cn.vitejs.dev/guide/\npnpm:performant npm ，意味“高性能的 npm”。pnpm由npm/yarn衍生而来，解决了npm/yarn内部潜在的bug，极大的优化了性能，扩展了使用场景。被誉为“最先进的包管理工具”\npnpm安装指令\n1 npm i -g pnpm 项目初始化命令:\n1 pnpm create vite 进入到项目根目录pnpm install安装全部依赖.安装完依赖运行程序:pnpm run dev\n运行完毕项目跑在http://127.0.0.1:5173/,可以访问你得项目啦\n2.2项目配置 一、eslint配置 eslint中文官网:http://eslint.cn/\nESLint最初是由Nicholas C. Zakas 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具\n首先安装eslint\n1 pnpm i eslint -D 生成配置文件:.eslint.cjs\n1 npx eslint --init .eslint.cjs配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 module.exports = { //运行环境 \u0026#34;env\u0026#34;: { \u0026#34;browser\u0026#34;: true,//浏览器端 \u0026#34;es2021\u0026#34;: true,//es2021 }, //规则继承 \u0026#34;extends\u0026#34;: [ //全部规则默认是关闭的,这个配置项开启推荐规则,推荐规则参照文档 //比如:函数不能重名、对象不能出现重复key \u0026#34;eslint:recommended\u0026#34;, //vue3语法规则 \u0026#34;plugin:vue/vue3-essential\u0026#34;, //ts语法规则 \u0026#34;plugin:@typescript-eslint/recommended\u0026#34; ], //要为特定类型的文件指定处理器 \u0026#34;overrides\u0026#34;: [ ], //指定解析器:解析器 //Esprima 默认解析器 //Babel-ESLint babel解析器 //@typescript-eslint/parser ts解析器 \u0026#34;parser\u0026#34;: \u0026#34;@typescript-eslint/parser\u0026#34;, //指定解析器选项 \u0026#34;parserOptions\u0026#34;: { \u0026#34;ecmaVersion\u0026#34;: \u0026#34;latest\u0026#34;,//校验ECMA最新版本 \u0026#34;sourceType\u0026#34;: \u0026#34;module\u0026#34;//设置为\u0026#34;script\u0026#34;（默认），或者\u0026#34;module\u0026#34;代码在ECMAScript模块中 }, //ESLint支持使用第三方插件。在使用插件之前，您必须使用npm安装它 //该eslint-plugin-前缀可以从插件名称被省略 \u0026#34;plugins\u0026#34;: [ \u0026#34;vue\u0026#34;, \u0026#34;@typescript-eslint\u0026#34; ], //eslint规则 \u0026#34;rules\u0026#34;: { } } 1.1vue3环境代码校验插件 1 2 3 4 5 6 7 8 9 10 # 让所有与prettier规则存在冲突的Eslint rules失效，并使用prettier进行代码检查 \u0026#34;eslint-config-prettier\u0026#34;: \u0026#34;^8.6.0\u0026#34;, \u0026#34;eslint-plugin-import\u0026#34;: \u0026#34;^2.27.5\u0026#34;, \u0026#34;eslint-plugin-node\u0026#34;: \u0026#34;^11.1.0\u0026#34;, # 运行更漂亮的Eslint，使prettier规则优先级更高，Eslint优先级低 \u0026#34;eslint-plugin-prettier\u0026#34;: \u0026#34;^4.2.1\u0026#34;, # vue.js的Eslint插件（查找vue语法错误，发现错误指令，查找违规风格指南 \u0026#34;eslint-plugin-vue\u0026#34;: \u0026#34;^9.9.0\u0026#34;, # 该解析器允许使用Eslint校验所有babel code \u0026#34;@babel/eslint-parser\u0026#34;: \u0026#34;^7.19.1\u0026#34;, 安装指令\n1 pnpm install -D eslint-plugin-import eslint-plugin-vue eslint-plugin-node eslint-plugin-prettier eslint-config-prettier eslint-plugin-node @babel/eslint-parser 1.2修改.eslintrc.cjs配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // @see https://eslint.bootcss.com/docs/rules/ module.exports = { env: { browser: true, es2021: true, node: true, jest: true, }, /* 指定如何解析语法 */ parser: \u0026#39;vue-eslint-parser\u0026#39;, /** 优先级低于 parse 的语法解析配置 */ parserOptions: { ecmaVersion: \u0026#39;latest\u0026#39;, sourceType: \u0026#39;module\u0026#39;, parser: \u0026#39;@typescript-eslint/parser\u0026#39;, jsxPragma: \u0026#39;React\u0026#39;, ecmaFeatures: { jsx: true, }, }, /* 继承已有的规则 */ extends: [ \u0026#39;eslint:recommended\u0026#39;, \u0026#39;plugin:vue/vue3-essential\u0026#39;, \u0026#39;plugin:@typescript-eslint/recommended\u0026#39;, \u0026#39;plugin:prettier/recommended\u0026#39;, ], plugins: [\u0026#39;vue\u0026#39;, \u0026#39;@typescript-eslint\u0026#39;], /* * \u0026#34;off\u0026#34; 或 0 ==\u0026gt; 关闭规则 * \u0026#34;warn\u0026#34; 或 1 ==\u0026gt; 打开的规则作为警告（不影响代码执行） * \u0026#34;error\u0026#34; 或 2 ==\u0026gt; 规则作为一个错误（代码不能执行，界面报错） */ rules: { // eslint（https://eslint.bootcss.com/docs/rules/） \u0026#39;no-var\u0026#39;: \u0026#39;error\u0026#39;, // 要求使用 let 或 const 而不是 var \u0026#39;no-multiple-empty-lines\u0026#39;: [\u0026#39;warn\u0026#39;, { max: 1 }], // 不允许多个空行 \u0026#39;no-console\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? \u0026#39;error\u0026#39; : \u0026#39;off\u0026#39;, \u0026#39;no-debugger\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? \u0026#39;error\u0026#39; : \u0026#39;off\u0026#39;, \u0026#39;no-unexpected-multiline\u0026#39;: \u0026#39;error\u0026#39;, // 禁止空余的多行 \u0026#39;no-useless-escape\u0026#39;: \u0026#39;off\u0026#39;, // 禁止不必要的转义字符 // typeScript (https://typescript-eslint.io/rules) \u0026#39;@typescript-eslint/no-unused-vars\u0026#39;: \u0026#39;error\u0026#39;, // 禁止定义未使用的变量 \u0026#39;@typescript-eslint/prefer-ts-expect-error\u0026#39;: \u0026#39;error\u0026#39;, // 禁止使用 @ts-ignore \u0026#39;@typescript-eslint/no-explicit-any\u0026#39;: \u0026#39;off\u0026#39;, // 禁止使用 any 类型 \u0026#39;@typescript-eslint/no-non-null-assertion\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;@typescript-eslint/no-namespace\u0026#39;: \u0026#39;off\u0026#39;, // 禁止使用自定义 TypeScript 模块和命名空间。 \u0026#39;@typescript-eslint/semi\u0026#39;: \u0026#39;off\u0026#39;, // eslint-plugin-vue (https://eslint.vuejs.org/rules/) \u0026#39;vue/multi-word-component-names\u0026#39;: \u0026#39;off\u0026#39;, // 要求组件名称始终为 “-” 链接的单词 \u0026#39;vue/script-setup-uses-vars\u0026#39;: \u0026#39;error\u0026#39;, // 防止\u0026lt;script setup\u0026gt;使用的变量\u0026lt;template\u0026gt;被标记为未使用 \u0026#39;vue/no-mutating-props\u0026#39;: \u0026#39;off\u0026#39;, // 不允许组件 prop的改变 \u0026#39;vue/attribute-hyphenation\u0026#39;: \u0026#39;off\u0026#39;, // 对模板中的自定义组件强制执行属性命名样式 }, } 1.3.eslintignore忽略文件 1 2 dist node_modules 1.4运行脚本 package.json新增两个运行脚本\n1 2 3 4 \u0026#34;scripts\u0026#34;: { \u0026#34;lint\u0026#34;: \u0026#34;eslint src\u0026#34;, \u0026#34;fix\u0026#34;: \u0026#34;eslint src --fix\u0026#34;, } 二、配置prettier 有了eslint，为什么还要有prettier？eslint针对的是javascript，他是一个检测工具，包含js语法以及少部分格式问题，在eslint看来，语法对了就能保证代码正常运行，格式问题属于其次；\n而prettier属于格式化工具，它看不惯格式不统一，所以它就把eslint没干好的事接着干，另外，prettier支持\n包含js在内的多种语言。\n总结起来，eslint和prettier这俩兄弟一个保证js代码质量，一个保证代码美观。\n2.1安装依赖包 1 pnpm install -D eslint-plugin-prettier prettier eslint-config-prettier 2.2.prettierrc.json添加规则 1 2 3 4 5 6 7 8 9 { \u0026#34;singleQuote\u0026#34;: true, \u0026#34;semi\u0026#34;: false, \u0026#34;bracketSpacing\u0026#34;: true, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;ignore\u0026#34;, \u0026#34;endOfLine\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;tabWidth\u0026#34;: 2 } 2.3.prettierignore忽略文件 1 2 3 4 5 6 7 /dist/* /html/* .local /node_modules/** **/*.svg **/*.sh /public/* 通过pnpm run lint去检测语法，如果出现不规范格式,通过pnpm run fix 修改\n三、配置stylelint stylelint为css的lint工具。可格式化css代码，检查css语法错误与不合理的写法，指定css书写顺序等。\n我们的项目中使用scss作为预处理器，安装以下依赖：\n1 pnpm add sass sass-loader stylelint postcss postcss-scss postcss-html stylelint-config-prettier stylelint-config-recess-order stylelint-config-recommended-scss stylelint-config-standard stylelint-config-standard-vue stylelint-scss stylelint-order stylelint-config-standard-scss -D 3.1.stylelintrc.cjs配置文件 官网:https://stylelint.bootcss.com/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // @see https://stylelint.bootcss.com/ module.exports = { extends: [ \u0026#39;stylelint-config-standard\u0026#39;, // 配置stylelint拓展插件 \u0026#39;stylelint-config-html/vue\u0026#39;, // 配置 vue 中 template 样式格式化 \u0026#39;stylelint-config-standard-scss\u0026#39;, // 配置stylelint scss插件 \u0026#39;stylelint-config-recommended-vue/scss\u0026#39;, // 配置 vue 中 scss 样式格式化 \u0026#39;stylelint-config-recess-order\u0026#39;, // 配置stylelint css属性书写顺序插件, \u0026#39;stylelint-config-prettier\u0026#39;, // 配置stylelint和prettier兼容 ], overrides: [ { files: [\u0026#39;**/*.(scss|css|vue|html)\u0026#39;], customSyntax: \u0026#39;postcss-scss\u0026#39;, }, { files: [\u0026#39;**/*.(html|vue)\u0026#39;], customSyntax: \u0026#39;postcss-html\u0026#39;, }, ], ignoreFiles: [ \u0026#39;**/*.js\u0026#39;, \u0026#39;**/*.jsx\u0026#39;, \u0026#39;**/*.tsx\u0026#39;, \u0026#39;**/*.ts\u0026#39;, \u0026#39;**/*.json\u0026#39;, \u0026#39;**/*.md\u0026#39;, \u0026#39;**/*.yaml\u0026#39;, ], /** * null =\u0026gt; 关闭该规则 * always =\u0026gt; 必须 */ rules: { \u0026#39;value-keyword-case\u0026#39;: null, // 在 css 中使用 v-bind，不报错 \u0026#39;no-descending-specificity\u0026#39;: null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器 \u0026#39;function-url-quotes\u0026#39;: \u0026#39;always\u0026#39;, // 要求或禁止 URL 的引号 \u0026#34;always(必须加上引号)\u0026#34;|\u0026#34;never(没有引号)\u0026#34; \u0026#39;no-empty-source\u0026#39;: null, // 关闭禁止空源码 \u0026#39;selector-class-pattern\u0026#39;: null, // 关闭强制选择器类名的格式 \u0026#39;property-no-unknown\u0026#39;: null, // 禁止未知的属性(true 为不允许) \u0026#39;block-opening-brace-space-before\u0026#39;: \u0026#39;always\u0026#39;, //大括号之前必须有一个空格或不能有空白符 \u0026#39;value-no-vendor-prefix\u0026#39;: null, // 关闭 属性值前缀 --webkit-box \u0026#39;property-no-vendor-prefix\u0026#39;: null, // 关闭 属性前缀 -webkit-mask \u0026#39;selector-pseudo-class-no-unknown\u0026#39;: [ // 不允许未知的选择器 true, { ignorePseudoClasses: [\u0026#39;global\u0026#39;, \u0026#39;v-deep\u0026#39;, \u0026#39;deep\u0026#39;], // 忽略属性，修改element默认样式的时候能使用到 }, ], }, } 3.2.stylelintignore忽略文件 1 2 3 4 /node_modules/* /dist/* /html/* /public/* 3.3运行脚本 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;lint:style\u0026#34;: \u0026#34;stylelint src/**/*.{css,scss,vue} --cache --fix\u0026#34; } 最后配置统一的prettier来格式化我们的js和css，html代码\n1 2 3 4 5 6 7 8 9 10 \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite --open\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vue-tsc \u0026amp;\u0026amp; vite build\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;eslint src\u0026#34;, \u0026#34;fix\u0026#34;: \u0026#34;eslint src --fix\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;prettier --write \\\u0026#34;./**/*.{html,vue,ts,js,json,md}\\\u0026#34;\u0026#34;, \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint src/**/*.{ts,vue} --cache --fix\u0026#34;, \u0026#34;lint:style\u0026#34;: \u0026#34;stylelint src/**/*.{css,scss,vue} --cache --fix\u0026#34; }, 当我们运行pnpm run format的时候，会把代码直接格式化\n四、配置husky 在上面我们已经集成好了我们代码校验工具，但是需要每次手动的去执行命令才会格式化我们的代码。如果有人没有格式化就提交了远程仓库中，那这个规范就没什么用。所以我们需要强制让开发人员按照代码规范来提交。\n要做到这件事情，就需要利用husky在代码提交之前触发git hook(git在客户端的钩子)，然后执行pnpm run format来自动的格式化我们的代码。\n安装husky\n1 pnpm install -D husky 执行\n1 npx husky-init 会在根目录下生成个一个.husky目录，在这个目录下面会有一个pre-commit文件，这个文件里面的命令在我们执行commit的时候就会执行\n在.husky/pre-commit文件添加如下命令：\n1 2 3 #!/usr/bin/env sh . \u0026#34;$(dirname -- \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; pnpm run format 当我们对代码进行commit操作的时候，就会执行命令，对代码进行格式化，然后再提交。\n五、配置commitlint 对于我们的commit信息，也是有统一规范的，不能随便写,要让每个人都按照统一的标准来执行，我们可以利用commitlint来实现。\n安装包\n1 pnpm add @commitlint/config-conventional @commitlint/cli -D 添加配置文件，新建commitlint.config.cjs(注意是cjs)，然后添加下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 module.exports = { extends: [\u0026#39;@commitlint/config-conventional\u0026#39;], // 校验规则 rules: { \u0026#39;type-enum\u0026#39;: [ 2, \u0026#39;always\u0026#39;, [ \u0026#39;feat\u0026#39;, \u0026#39;fix\u0026#39;, \u0026#39;docs\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;refactor\u0026#39;, \u0026#39;perf\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;chore\u0026#39;, \u0026#39;revert\u0026#39;, \u0026#39;build\u0026#39;, ], ], \u0026#39;type-case\u0026#39;: [0], \u0026#39;type-empty\u0026#39;: [0], \u0026#39;scope-empty\u0026#39;: [0], \u0026#39;scope-case\u0026#39;: [0], \u0026#39;subject-full-stop\u0026#39;: [0, \u0026#39;never\u0026#39;], \u0026#39;subject-case\u0026#39;: [0, \u0026#39;never\u0026#39;], \u0026#39;header-max-length\u0026#39;: [0, \u0026#39;always\u0026#39;, 72], }, } 在package.json中配置scripts命令\n1 2 3 4 5 6 # 在scrips中添加下面的代码 { \u0026#34;scripts\u0026#34;: { \u0026#34;commitlint\u0026#34;: \u0026#34;commitlint --config commitlint.config.cjs -e -V\u0026#34; }, } 配置结束，现在当我们填写commit信息的时候，前面就需要带着下面的subject\n1 2 3 4 5 6 7 8 9 10 \u0026#39;feat\u0026#39;,//新特性、新功能 \u0026#39;fix\u0026#39;,//修改bug \u0026#39;docs\u0026#39;,//文档修改 \u0026#39;style\u0026#39;,//代码格式修改, 注意不是 css 修改 \u0026#39;refactor\u0026#39;,//代码重构 \u0026#39;perf\u0026#39;,//优化相关，比如提升性能、体验 \u0026#39;test\u0026#39;,//测试用例修改 \u0026#39;chore\u0026#39;,//其他修改, 比如改变构建流程、或者增加依赖库、工具等 \u0026#39;revert\u0026#39;,//回滚到上一个版本 \u0026#39;build\u0026#39;,//编译相关的修改，例如发布版本、对项目构建或者依赖的改动 配置husky\n1 npx husky add .husky/commit-msg 在生成的commit-msg文件中添加下面的命令\n1 2 3 #!/usr/bin/env sh . \u0026#34;$(dirname -- \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; pnpm commitlint 当我们 commit 提交信息时，就不能再随意写了，必须是 git commit -m \u0026lsquo;fix: xxx\u0026rsquo; 符合类型的才可以，需要注意的是类型的后面需要用英文的 :，并且冒号后面是需要空一格的，这个是不能省略的\n六、强制使用pnpm包管理器工具 团队开发项目的时候，需要统一包管理器工具,因为不同包管理器工具下载同一个依赖,可能版本不一样,\n导致项目出现bug问题,因此包管理器工具需要统一管理！！！\n在根目录创建scritps/preinstall.js文件，添加下面的内容\n1 2 3 4 5 6 7 if (!/pnpm/.test(process.env.npm_execpath || \u0026#39;\u0026#39;)) { console.warn( `\\u001b[33mThis repository must using pnpm as the package manager ` + ` for scripts to work properly.\\u001b[39m\\n`, ) process.exit(1) } 配置命令\n1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;preinstall\u0026#34;: \u0026#34;node ./scripts/preinstall.js\u0026#34; } 当我们使用npm或者yarn来安装包的时候，就会报错了。原理就是在install的时候会触发preinstall（npm提供的生命周期钩子）这个文件里面的代码。\n三、项目集成 3.1集成element-plus 硅谷甄选运营平台,UI组件库采用的element-plus，因此需要集成element-plus插件！！！\n官网地址:https://element-plus.gitee.io/zh-CN/\n1 pnpm install element-plus @element-plus/icons-vue 入口文件main.ts全局安装element-plus,element-plus默认支持语言英语设置为中文\n1 2 3 4 5 6 7 import ElementPlus from \u0026#39;element-plus\u0026#39;; import \u0026#39;element-plus/dist/index.css\u0026#39; //@ts-ignore忽略当前文件ts类型的检测否则有红色提示(打包会失败) import zhCn from \u0026#39;element-plus/dist/locale/zh-cn.mjs\u0026#39; app.use(ElementPlus, { locale: zhCn }) Element Plus全局组件类型声明\n1 2 3 4 5 6 7 // tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { // ... \u0026#34;types\u0026#34;: [\u0026#34;element-plus/global\u0026#34;] } } 配置完毕可以测试element-plus组件与图标的使用.\n3.2src别名的配置 在开发项目的时候文件与文件关系可能很复杂，因此我们需要给src文件夹配置一个别名！！！\n1 2 3 4 5 6 7 8 9 10 11 12 // vite.config.ts import {defineConfig} from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import path from \u0026#39;path\u0026#39; export default defineConfig({ plugins: [vue()], resolve: { alias: { \u0026#34;@\u0026#34;: path.resolve(\u0026#34;./src\u0026#34;) // 相对路径别名配置，使用 @ 代替 src } } }) TypeScript 编译配置\n1 2 3 4 5 6 7 8 9 // tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, // 解析非相对模块的基地址，默认是当前目录 \u0026#34;paths\u0026#34;: { //路径映射，相对于baseUrl \u0026#34;@/*\u0026#34;: [\u0026#34;src/*\u0026#34;] } } } 3.3环境变量的配置 项目开发过程中，至少会经历开发环境、测试环境和生产环境(即正式环境)三个阶段。不同阶段请求的状态(如接口地址等)不尽相同，若手动切换接口地址是相当繁琐且易出错的。于是环境变量配置的需求就应运而生，我们只需做简单的配置，把环境状态切换的工作交给代码。\n开发环境（development） 顾名思义，开发使用的环境，每位开发人员在自己的dev分支上干活，开发到一定程度，同事会合并代码，进行联调。\n测试环境（testing） 测试同事干活的环境啦，一般会由测试同事自己来部署，然后在此环境进行测试\n生产环境（production） 生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。(正式提供给客户使用的环境。)\n注意:一般情况下，一个环境对应一台服务器,也有的公司开发与测试环境是一台服务器！！！\n项目根目录分别添加 开发、生产和测试环境的文件!\n1 2 3 .env.development .env.production .env.test 文件内容\n1 2 3 4 # 变量必须以 VITE_ 为前缀才能暴露给外部读取 NODE_ENV = \u0026#39;development\u0026#39; VITE_APP_TITLE = \u0026#39;硅谷甄选运营平台\u0026#39; VITE_APP_BASE_API = \u0026#39;/dev-api\u0026#39; 1 2 3 NODE_ENV = \u0026#39;production\u0026#39; VITE_APP_TITLE = \u0026#39;硅谷甄选运营平台\u0026#39; VITE_APP_BASE_API = \u0026#39;/prod-api\u0026#39; 1 2 3 4 # 变量必须以 VITE_ 为前缀才能暴露给外部读取 NODE_ENV = \u0026#39;test\u0026#39; VITE_APP_TITLE = \u0026#39;硅谷甄选运营平台\u0026#39; VITE_APP_BASE_API = \u0026#39;/test-api\u0026#39; 配置运行命令：package.json\n1 2 3 4 5 6 \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite --open\u0026#34;, \u0026#34;build:test\u0026#34;: \u0026#34;vue-tsc \u0026amp;\u0026amp; vite build --mode test\u0026#34;, \u0026#34;build:pro\u0026#34;: \u0026#34;vue-tsc \u0026amp;\u0026amp; vite build --mode production\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34; }, 通过import.meta.env获取环境变量\n3.4SVG图标配置 在开发项目的时候经常会用到svg矢量图,而且我们使用SVG以后，页面上加载的不再是图片资源,\n这对页面性能来说是个很大的提升，而且我们SVG文件比img要小的很多，放在项目中几乎不占用资源。\n安装SVG依赖插件\n1 pnpm install vite-plugin-svg-icons -D 在vite.config.ts中配置插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { createSvgIconsPlugin } from \u0026#39;vite-plugin-svg-icons\u0026#39; import path from \u0026#39;path\u0026#39; export default () =\u0026gt; { return { plugins: [ createSvgIconsPlugin({ // Specify the icon folder to be cached iconDirs: [path.resolve(process.cwd(), \u0026#39;src/assets/icons\u0026#39;)], // Specify symbolId format symbolId: \u0026#39;icon-[dir]-[name]\u0026#39;, }), ], } } 入口文件导入\n1 import \u0026#39;virtual:svg-icons-register\u0026#39; 3.4.1svg封装为全局组件 因为项目很多模块需要使用图标,因此把它封装为全局组件！！！\n在src/components目录下创建一个SvgIcon组件:代表如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;svg :style=\u0026#34;{ width: width, height: height }\u0026#34;\u0026gt; \u0026lt;use :xlink:href=\u0026#34;prefix + name\u0026#34; :fill=\u0026#34;color\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; defineProps({ //xlink:href属性值的前缀 prefix: { type: String, default: \u0026#39;#icon-\u0026#39; }, //svg矢量图的名字 name: String, //svg图标的颜色 color: { type: String, default: \u0026#34;\u0026#34; }, //svg宽度 width: { type: String, default: \u0026#39;16px\u0026#39; }, //svg高度 height: { type: String, default: \u0026#39;16px\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 在src文件夹目录下创建一个index.ts文件：用于注册components文件夹内部全部全局组件！！！\n1 2 3 4 5 6 7 8 9 10 import SvgIcon from \u0026#39;./SvgIcon/index.vue\u0026#39;; import type { App, Component } from \u0026#39;vue\u0026#39;; const components: { [name: string]: Component } = { SvgIcon }; export default { install(app: App) { Object.keys(components).forEach((key: string) =\u0026gt; { app.component(key, components[key]); }) } } 在入口文件引入src/index.ts文件,通过app.use方法安装自定义插件\n1 2 import gloablComponent from \u0026#39;./components/index\u0026#39;; app.use(gloablComponent); 3.5集成sass 我们目前在组件内部已经可以使用scss样式,因为在配置styleLint工具的时候，项目当中已经安装过sass sass-loader,因此我们再组件内可以使用scss语法！！！需要加上lang=\u0026ldquo;scss\u0026rdquo;\n1 \u0026lt;style scoped lang=\u0026#34;scss\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; 接下来我们为项目添加一些全局的样式\n在src/styles目录下创建一个index.scss文件，当然项目中需要用到清除默认样式，因此在index.scss引入reset.scss\n1 @import reset.scss 在入口文件引入\n1 import \u0026#39;@/styles\u0026#39; 但是你会发现在src/styles/index.scss全局样式文件中没有办法使用$变量.因此需要给项目中引入全局变量$.\n在style/variable.scss创建一个variable.scss文件！\n在vite.config.ts文件配置如下:\n1 2 3 4 5 6 7 8 9 10 11 export default defineConfig((config) =\u0026gt; { css: { preprocessorOptions: { scss: { javascriptEnabled: true, additionalData: \u0026#39;@import \u0026#34;./src/styles/variable.scss\u0026#34;;\u0026#39;, }, }, }, } } @import \u0026quot;./src/styles/variable.less\u0026quot;;后面的;不要忘记，不然会报错!\n配置完毕你会发现scss提供这些全局变量可以在组件样式中使用了！！！\n3.6mock数据 安装依赖:https://www.npmjs.com/package/vite-plugin-mock\n1 pnpm install -D vite-plugin-mock mockjs 在 vite.config.js 配置文件启用插件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { UserConfigExport, ConfigEnv } from \u0026#39;vite\u0026#39; import { viteMockServe } from \u0026#39;vite-plugin-mock\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; export default ({ command })=\u0026gt; { return { plugins: [ vue(), viteMockServe({ localEnabled: command === \u0026#39;serve\u0026#39;, }), ], } } 在根目录创建mock文件夹:去创建我们需要mock数据与接口！！！\n在mock文件夹内部创建一个user.ts文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 //用户信息数据 function createUserList() { return [ { userId: 1, avatar: \u0026#39;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif\u0026#39;, username: \u0026#39;admin\u0026#39;, password: \u0026#39;111111\u0026#39;, desc: \u0026#39;平台管理员\u0026#39;, roles: [\u0026#39;平台管理员\u0026#39;], buttons: [\u0026#39;cuser.detail\u0026#39;], routes: [\u0026#39;home\u0026#39;], token: \u0026#39;Admin Token\u0026#39;, }, { userId: 2, avatar: \u0026#39;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif\u0026#39;, username: \u0026#39;system\u0026#39;, password: \u0026#39;111111\u0026#39;, desc: \u0026#39;系统管理员\u0026#39;, roles: [\u0026#39;系统管理员\u0026#39;], buttons: [\u0026#39;cuser.detail\u0026#39;, \u0026#39;cuser.user\u0026#39;], routes: [\u0026#39;home\u0026#39;], token: \u0026#39;System Token\u0026#39;, }, ] } export default [ // 用户登录接口 { url: \u0026#39;/api/user/login\u0026#39;,//请求地址 method: \u0026#39;post\u0026#39;,//请求方式 response: ({ body }) =\u0026gt; { //获取请求体携带过来的用户名与密码 const { username, password } = body; //调用获取用户信息函数,用于判断是否有此用户 const checkUser = createUserList().find( (item) =\u0026gt; item.username === username \u0026amp;\u0026amp; item.password === password, ) //没有用户返回失败信息 if (!checkUser) { return { code: 201, data: { message: \u0026#39;账号或者密码不正确\u0026#39; } } } //如果有返回成功信息 const { token } = checkUser return { code: 200, data: { token } } }, }, // 获取用户信息 { url: \u0026#39;/api/user/info\u0026#39;, method: \u0026#39;get\u0026#39;, response: (request) =\u0026gt; { //获取请求头携带token const token = request.headers.token; //查看用户信息是否包含有次token用户 const checkUser = createUserList().find((item) =\u0026gt; item.token === token) //没有返回失败的信息 if (!checkUser) { return { code: 201, data: { message: \u0026#39;获取用户信息失败\u0026#39; } } } //如果有返回成功信息 return { code: 200, data: {checkUser} } }, }, ] 安装axios\n1 pnpm install axios 最后通过axios测试接口！！！\n3.7axios二次封装 在开发项目的时候避免不了与后端进行交互,因此我们需要使用axios插件实现发送网络请求。在开发项目的时候\n我们经常会把axios进行二次封装。\n目的:\n1:使用请求拦截器，可以在请求拦截器中处理一些业务(开始进度条、请求头携带公共参数)\n2:使用响应拦截器，可以在响应拦截器中处理一些业务(进度条结束、简化服务器返回的数据、处理http网络错误)\n在根目录下创建utils/request.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import axios from \u0026#34;axios\u0026#34;; import { ElMessage } from \u0026#34;element-plus\u0026#34;; //创建axios实例 let request = axios.create({ baseURL: import.meta.env.VITE_APP_BASE_API, timeout: 5000 }) //请求拦截器 request.interceptors.request.use(config =\u0026gt; { return config; }); //响应拦截器 request.interceptors.response.use((response) =\u0026gt; { return response.data; }, (error) =\u0026gt; { //处理网络错误 let msg = \u0026#39;\u0026#39;; let status = error.response.status; switch (status) { case 401: msg = \u0026#34;token过期\u0026#34;; break; case 403: msg = \u0026#39;无权访问\u0026#39;; break; case 404: msg = \u0026#34;请求地址错误\u0026#34;; break; case 500: msg = \u0026#34;服务器出现问题\u0026#34;; break; default: msg = \u0026#34;无网络\u0026#34;; } ElMessage({ type: \u0026#39;error\u0026#39;, message: msg }) return Promise.reject(error); }); export default request; 3.8API接口统一管理 在开发项目的时候,接口可能很多需要统一管理。在src目录下去创建api文件夹去统一管理项目的接口；\n比如:下面方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //统一管理咱们项目用户相关的接口 import request from \u0026#39;@/utils/request\u0026#39; import type { loginFormData, loginResponseData, userInfoReponseData, } from \u0026#39;./type\u0026#39; //项目用户相关的请求地址 enum API { LOGIN_URL = \u0026#39;/admin/acl/index/login\u0026#39;, USERINFO_URL = \u0026#39;/admin/acl/index/info\u0026#39;, LOGOUT_URL = \u0026#39;/admin/acl/index/logout\u0026#39;, } //登录接口 export const reqLogin = (data: loginFormData) =\u0026gt; request.post\u0026lt;any, loginResponseData\u0026gt;(API.LOGIN_URL, data) //获取用户信息 export const reqUserInfo = () =\u0026gt; request.get\u0026lt;any, userInfoReponseData\u0026gt;(API.USERINFO_URL) //退出登录 export const reqLogout = () =\u0026gt; request.post\u0026lt;any, any\u0026gt;(API.LOGOUT_URL) 四、项目的资源地址 贾成豪老师代码仓库地址:https://gitee.com/jch1011/vue3_admin_template-bj1.git\n项目在线文档:\n服务器域名:http://sph-api.atguigu.cn\nswagger文档:\nhttp://139.198.104.58:8209/swagger-ui.html\nhttp://139.198.104.58:8212/swagger-ui.html#/\necharts:国内镜像网站\nhttps://www.isqqw.com/echarts-doc/zh/option.html#title\nhttp://datav.aliyun.com/portal/school/atlas/area_selector\n","date":"2023-06-01T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/gulizhenxuan/","title":"练手项目:硅谷甄选运营平台"},{"content":" 1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\u0026#34;); return 0; } 基础知识 分号 每个语句必须以分号结束\n符号类型 一定要是英文符号\n注释 单行注释 多行注释(也可单行) 1 2 3 //单行注释 /*多行注释*/ 数据类型 TYPE BYTE MORE char 1 字节 -128 到 127 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 ——— unsigned int 2 或 4 字节 ——— short 2 字节 ——— unsigned short 2 字节 ——— long 4 字节 ——— unsigned long 4 字节 ——— float 4 字节 6 位有效位 double 8 字节 15 位有效位 long double 16 字节 19 位有效位 1 2 3 4 5 6 7 //sizeof可以获取储存字节大小 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;int 存储大小 : %lu \\n\u0026#34;,sizeof(int)); return 0; } 常量 整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。\n浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。\n字符常量 单引号内 char -\u0026gt; 1字节 转义字符 \\n 换行符号 \\b 退格 \\ (特殊符号) 本身 字符串常量 双引号中\n多行时\n定义常量 1 2 //name=value #define name value 变量 变量名可以是字母、数字和下划线的组合\n规则\n开头必须是字母或 下划线（可以下划线） 不可以是C语言关键字 不能有空格 类型转换 显示转换 1 2 3 c=1.2F b=(int)c //要注意在c中强制转换不是一个函数式转换 隐式转换 方向： 精度上升 特殊： scanf/printf 只能int-chr转换(精度上升的转换都不行？) char - int 转换(显/隐) 详见字符ascii 储存类（不考） 运算符 算数运算符 + - * / 小心隐式转换（加减也会） 除法取全舍去（负时偏向绝对值） 1 2 3 //例如 10/3==-3; 10/(-3)==-3 取模 % 在算法中常/与%使用依次去位数\n(高精度模板题)\n++\u0026ndash; 自增自减 注意Attention！\na++ 先赋值后运算\n++a 先运算后赋值\n赋值运算符 形式： (算数运算符)$=$\n如 a += 1\n关系运算符\n== != \u0026gt; \u0026lt; \u0026lt;= \u0026gt;= 注意Attention！\n在c中不能1\u0026lt;a\u0026lt;b这样判断\n逻辑运算符 与 \u0026amp;\u0026amp; 或 || 非 ! 位运算符号\n详见 位运算 输入输出 输入流 stdin 未读取的不会清空，共享\n1 2 3 4 5 6 //手动清空输入流 //通过连续读取来清空输入流 int r=getchar(); while (r!=EOF){ r=getchar() } 输出流 stdout 连续，不会自动换行 -\u0026gt; \\n的重要性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int main(){ char a; //其实getchar()返回的是int，不过由于char-int的隐式转换，也无所谓 //每当按下回车时getchar会读取stdin中第一个，并将其从stdin中弹出 a=getchar(); //putchar 接收的也是int putchar(a); //scanf 记得占位符正确和写寻地址符 //当然数组名本身即使地址，不要寻地址符 //每当按下回车时getchar会读取stdin中前n个（取决于占位符），并将其从stdin中弹出 scanf(\u0026#34;%c\u0026#34;,\u0026amp;a); //一般函数最后输出结尾都会加上\\n printf(\u0026#34;%c\\n\u0026#34;,a); return 0; } 占位符 占位符 类型 %d int %c char %s str(char[]) %f float %.3f 3位 %lf double %p pointer 字符ascii 32 空格 48-57 数字0-9 65-90 大写字母 97-122 小写字母 1 2 3 4 5 6 7 8 9 10 // 标准输入输出库 #include \u0026lt;stdio.h\u0026gt; int main(){ //隐式转换 97 a int c = \u0026#39;a\u0026#39;; printf(\u0026#34;%c %d\u0026#34;,c,c); //在c中取ascii码值可直接类型转换得出 //而由“11”(str)取得11(int)可调库，或者哈希映射（自建数组下表映射或者ascii映射(+48)) return 0; } 更多输入输出 详见字符串\n文件读写 文件打开和关闭 不要忘记关闭文件\n1 2 3 4 // open FILE *fopen( const char *filename, const char *mode ); // close fclose( FILE *fp ); filename 文件路径 mode 访问模式 mode description r read 只读 w write 只写，重写/新建(会覆盖) a add 只写，追加/新建(不会覆盖) r+ 读写 w+ 读写，重写/新建(会覆盖) a+ 读写，追加/新建(不会覆盖) 二进制模式 \u0026ldquo;rb\u0026rdquo;, \u0026ldquo;wb\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;rb+\u0026rdquo;, \u0026ldquo;r+b\u0026rdquo;, \u0026ldquo;wb+\u0026rdquo;, \u0026ldquo;w+b\u0026rdquo;, \u0026ldquo;ab+\u0026rdquo;, \u0026ldquo;a+b\u0026rdquo;\nEOF 1 2 //在c中EOF标识符实际为-1 #define EOF -1 读取文件 注意fscanf()先要传入fp，和其它相反\n1 2 3 4 //char *buf 为缓冲区（自己开一个数组） int fgetc( FILE * fp ); char *fgets( char *buf, int n, FILE *fp ); int fscanf(FILE *fp ,const char *s, char *buf); 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 \u0026lsquo;\\n\u0026rsquo; 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符 int fscanf(FILE *fp, const char *format, \u0026hellip;) 函数文件中读取字符串在遇到第一个空格和换行符时，会停止读取\n写入文件 注意fprintf()先要传入fp，和其它相反\n1 2 3 4 // 失败时返回EOF int fputc( int c, FILE *fp ); int fputs( const char *s, FILE *fp ); int fprintf(FILE * fp,const char*s); 二进制读写 1 2 fread(); fwrite(); 二进制 比特与字节 bit 二进制一个数位 1 byte = 8 bit 进制转换 10进制-\u0026gt;2进制： 除2法取余数 2进制-\u0026gt;10进制： 从右到左依次乘从$2^0$开始到$2^n$的和\n位运算 与 \u0026amp; 或 | 取反 ~ 异或 ^ 左右移 \u0026laquo;\u0026lt; \u0026raquo;\u0026gt; 1 2 3 4 5 6 int a=4; //二进制右移1位即除以2，左一乘以2 //同理，十进制则1位乘除10，注意c中左右移符号是二进制的移动 if (a\u0026gt;\u0026gt;1==a/2){ printf(\u0026#34;True\u0026#34;); } 常见性质(略) 二进制算法 二进制枚举 快速幂 基础结构 分支结构 1 2 3 4 5 6 7 8 9 10 11 12 13 //分支 if (){ } else if (){ } else{ } //三元 a==0?printf(\u0026#34;a=0\u0026#34;):printf(\u0026#34;a!=0\u0026#34;); !!!注意\n如果switch没有break则会继续执行（会触发default或者其它case）\nexpression必须是常量表达式，必须是一个整型或枚举类型\n1 2 3 4 5 6 7 8 9 10 11 12 switch(expression){ case constant-expression : statement(s); break; /* 可选的 */ case constant-expression : statement(s); break; /* 可选的 */ /* 您可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s); } 循环结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int a=10; while(1){ a--; if (a\u0026gt;5){ continue; } printf(\u0026#34;NO\u0026#34;) if (a\u0026lt;4) break; } for(a=10;a\u0026lt;3;a--){ printf(\u0026#34;%d,a\u0026#34;); } do{ printf(\u0026#34;%d\u0026#34;,a); a-=1 }while(a); 省略 如果只跟一个句子，可以省略大括号 单数字作为条件时0假其它真 如下面的句子是合法的\n1 2 3 4 5 6 7 8 9 10 for(int i=0;i\u0026lt;10;i++) for(int j=i;j\u0026lt;10;j++) printf(\u0026#34;%d\u0026#34;,j); if(a==0) printf(\u0026#34;YES!!!\u0026#34;); int a=0; if(!a){ printf(\u0026#34;a is zero\u0026#34;); } 数组与字符串 一维数组 声明格式 type arrayName [ arraySize ]; 1 int a[50]; 初始化(大括号) 1 2 3 4 5 6 7 8 9 //标准初始化 int a[2]={1,2}; //可以只初始化少初始化，但不能多初始化 //即大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目 int a[10]={1,4,3,5}; //如果没有指定数组大小，则其等于初始化个数 int a[]={1,2,4}; 两种访问 下标（索引）从0开始 指针访问（数组名指向数组第一个元素的地址，数组储存连续） 详见指针 高维数组 声明与初始化\n(要记得大小从1开始，但索引从0开始) 1 2 3 4 5 // int a[2][2][2]; // // int a[2][3]={1,2,3,2,4,6} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 - 两种访问 - 下标（索引）从0开始 - 指针访问 - 列指针与行指针 - 单指针（利用连续性） [详见指针](#指针) ### 字符串 \u0026gt;everal ways to initialize a string **一定**以 ***\u0026#39;\\0\u0026#39;*** 结尾 + char str[20] = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\0\u0026#39;}; + char str[20] = \u0026#34;Hello\u0026#34;; // \u0026#39;\\0\u0026#39; is automatically set to str[5] + char str[] = \u0026#34;Hello\u0026#34;; //str\u0026#39;s size is 6 如果已经声明，就不能进行**初始化** #### 易错练习 是否正确？ ```c //注意字符和字符串的引号 //注意隐式转换 char a[]={\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,0} 字符串相关 \u0026lt;stdio.h\u0026gt; printf() %s\nsprintf() 1 2 3 4 5 6 7 8 int sprintf( char *str, const char *format, ... ); char buffer[50]; int n, a = 5, b = 3; n = sprintf(buffer, \u0026#34;%d plus %d is %d\u0026#34;, a, b, a+b); // n 实际长度13 //buffer=\u0026#34;5 plus 3 is 8\u0026#34; puts() puts stops printing when it meets \u0026lsquo;\\0\u0026rsquo;.\nscanf() %s 读到空格停止 %ns 读到空格/读n个字符停止 gets() 读一整行，字符数组开小了可能越界\nfgets() fgets(your_line, sizeof(your_line), stdin)\n利用sizeof ，防止越界\n字符串相关 \u0026lt;string.h\u0026gt; strlen() length of str, not including \u0026lsquo;\\0\u0026rsquo;;\nstrcpy(destination,source) 字符串赋值要strcpy，别直接等于号赋值\ncopy string from source to destination(包括\u0026rsquo;\\0\u0026rsquo;)\n小心越界\nstrncpy(destination, source, n) 复制前n个字符，最后自动加上\u0026rsquo;\\0\u0026rsquo;\nstrcmp(str1, str2) 逐位比较ascii，直到某一位ascii不一样，str1\u0026gt;str2 返回 1，相等返回0，其余-1\nstrncmp(str1, str2, n) 前n个\nstrcat(destination, source); 连接，加在dest上，小心越界\n字符串相关 \u0026lt;stdlib.h\u0026gt; atoi(str) str-\u0026gt;int\n支持正负号\n取前面可以转换的，到非数字字符停止(无视空格) ex. atoi(\u0026quot;-10aaa\u0026quot;)=-10\natof(str) • Same as atoi\n• Space, +, - are acceptable\n• An E or e (exponent) is acceptable\n• A decimal point is acceptable\n相关算法（仅作了解） BF，BK，KMP，BM 前缀树 后缀树 AC自动机 其它 基础语法 函数 函数的声明 如果函数放于main函数后面/多文件，需要提前声明 声明时参数的名称并不重要，只有参数的类型是必需的，因此以下都是都是有效声明 1 2 int max(int, int); int max(int a, int b); void 无返回值 返回多个值 利用指针 形式参数 详见作用域 传递数组 传一个指针 传不定长数组(ex. int a[],如果二维需要指定第二维度，int a[][3]) 传定长数组(int a[20]) #define函数 1 2 #define MAX(a,b) a\u0026gt;b?a:b #define SQ(x) x*x 作用域 3 types 在函数或块内部的局部变量,在所有函数外部的全局变量,在形式参数的函数参数定义中\nsmall has big 小可以改大的，大不能改小的\n形参同名替代（小带大） 但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用\n递归 懂得都懂 ——佚名 自顶向下,利用系统栈\n经典题 斐波那契 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int Fibonacci(int n){ if (n\u0026lt;=2){ return 1; } return Fibonacci(n-1)+Fibonacci(n-2); } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;%d\u0026#34;,Fibonacci(n)); return 0; } 命令行参数 1 2 3 int main(int argc, char *argv[] ){ return 0; } argc 存放命令行参数的个数 *argv[] 从argv[1]开始存放每一个参数的指针，第一个即argv[0]存放程序名 多文件 构成 宏文件（xxx.h） 文件存放声明\nxxx.c 文件存放函数\n主函数里 #include\u0026quot;xxx.h\u0026quot;\n进阶语法 指针 结构体 结构体定义与初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 //一个完整结构体的example struct tag1{ int a; char b[30]; }variable1={1,\u0026#34;ssss\u0026#34;}; struct tag1 variable2; typedef struct{ float f; }tag2; tag2 variable3; ！！！注意！！！\n无论如何struct结尾必须有分号 typedef格式固定，下面不是变量而是标签 如果变量已经声明，就不能进行初始化 1 2 3 4 5 6 7 8 9 10 11 //无typedef时下面一定是变量（无标签） struct { int a; }VARIABLE; //下面一定是tag //tag 不能放上面 //实质 typedef struct{int a;} TAG; //类同 typedef unsigned char UC; typedef struct{ int a; }TAG; 结构体内部元素赋值 1 2 3 4 5 6 7 8 9 struct day{ char feeling[100]; int time; }today; today.time=222; strcpy(today.feeling,\u0026#34;dddd\u0026#34;); struct day yesterday={\u0026#34;good\u0026#34;,221}; 结构体指针 接着上文定义的结构体\n1 2 3 struct day *check; check=\u0026amp;today printf(\u0026#34;%s\u0026#34;,check-\u0026gt;feeling); 结构体数组 接着上文定义的结构体\n1 2 3 4 5 6 struct day holiday[60]; int i; for(i=0;i\u0026lt;60;i++){ strcpy(holiday[i].feeling,happy); holiday[i].time=i; } 枚举类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 enum week { MON=1, TUE, WED, THU, FRI, SAT, SUN }day; day=MON; printf(\u0026#34;%d\u0026#34;,day); //若不初始化MON，默认第一个是 0 //注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。 //如果我们把第3个枚举成员的值定义为 9，第4个就为 10，以此类推，第2个依然为1。 //可以和整形强制转化 int a=1; days=(enum week)a; //days=MON 动态内存 入门级基础算法 数学 求质数 了解朴素质数判定即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 朴素质数判定 /* 已经声明过 #define true 1 #define false 0 */ int check(int a){ if (a\u0026lt;2){ return false; } int i; for(i=2;i*i\u0026lt;a;i++){ if (a%i==0){ return false; } } return true; } 最大公约数\n了解欧几里得算法即可\n1 2 3 4 int gcd(int a,int b){ if (b==0) return a; return gcd(b, a % b); } 最小公倍数\n$lcm(a,b)gcd(a,b)=ab$\n先求出gcd即可\n高精度（了解加法减法即可）\n排序 稳定排序 不稳定排序 计数排序 桶排序 qsort() 双指针 同向 逆向 滑窗 ","date":"2023-05-30T00:00:00Z","image":"https://picx.zhimg.com/80/v2-905bb346af5546905d0eae5178eeb7ad_720w.webp?source=1940ef5c","permalink":"https://open17.github.io/CpHugo/p/cstart/","title":"C语言快速入门"},{"content":"前言 题目分布：简单，中等，中等，困难 T3思路想错坐牢，写出T4后才写出T3\nT1 字符串中最大的 3 位相同数字 给你一个字符串 num ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 优质整数 ：\n该整数是 num 的一个长度为 3 的 子字符串 。 该整数由唯一一个数字重复 3 次组成。 以字符串形式返回 最大的优质整数 。如果不存在满足要求的整数，则返回一个空字符串 \u0026quot;\u0026quot; 。\n注意：\n子字符串 是字符串中的一个连续字符序列。 num 或优质整数中可能存在 前导零 。\n示例 1：\n1 2 3 4 输入：num = \u0026#34;6777133339\u0026#34; 输出：\u0026#34;777\u0026#34; 解释：num 中存在两个优质整数：\u0026#34;777\u0026#34; 和 \u0026#34;333\u0026#34; 。 \u0026#34;777\u0026#34; 是最大的那个，所以返回 \u0026#34;777\u0026#34; 。 示例 2：\n1 2 3 输入：num = \u0026#34;2300019\u0026#34; 输出：\u0026#34;000\u0026#34; 解释：\u0026#34;000\u0026#34; 是唯一一个优质整数。 示例 3：\n1 2 3 输入：num = \u0026#34;42352338\u0026#34; 输出：\u0026#34;\u0026#34; 解释：不存在长度为 3 且仅由一个唯一数字组成的整数。因此，不存在优质整数。 提示：\n1 2 3 \u0026lt;= num.length \u0026lt;= 1000 num 仅由数字（0 - 9）组成 思路 模拟\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: string largestGoodInteger(string num) { int l=2; int p=-1; int ans=-1; while(l\u0026lt;num.size()){ if(num[l-2]==num[l-1]\u0026amp;\u0026amp;num[l-1]==num[l]){ if(p\u0026lt;(num[l]-\u0026#39;0\u0026#39;)){ p=num[l]-\u0026#39;0\u0026#39;; ans=l; } l+=3; } else{ l++; } } if(ans==-1)return \u0026#34;\u0026#34;; return num.substr(ans-2,3); } }; T22265. 统计值等于子树平均值的节点数 给你一棵二叉树的根节点 root ，找出并返回满足要求的节点数，要求节点的值等于其 子树 中值的 平均值 。\n注意：\nn 个元素的平均值可以由 n 个元素 求和 然后再除以 n ，并 向下舍入 到最近的整数。 root 的 子树 由 root 和它的所有后代组成。\n示例 1： 1 2 3 4 5 6 7 8 输入：root = [4,8,5,0,1,null,6] 输出：5 解释： 对值为 4 的节点：子树的平均值 (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4 。 对值为 5 的节点：子树的平均值 (5 + 6) / 2 = 11 / 2 = 5 。 对值为 0 的节点：子树的平均值 0 / 1 = 0 。 对值为 1 的节点：子树的平均值 1 / 1 = 1 。 对值为 6 的节点：子树的平均值 6 / 1 = 6 。 示例 2： 1 2 3 输入：root = [1] 输出：1 解释：对值为 1 的节点：子树的平均值 1 / 1 = 1。 提示：\n1 2 树中节点数目在范围 [1, 1000] 内 0 \u0026lt;= Node.val \u0026lt;= 1000 思路 按要求dfs即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ typedef pair\u0026lt;int,int\u0026gt; pii; class Solution { public: int cnt=0; int averageOfSubtree(TreeNode* root) { dfs(root); return cnt; } pii dfs(TreeNode *node){ int ans=node-\u0026gt;val; int num=1; if(node-\u0026gt;left){ pii a=dfs(node-\u0026gt;left); ans+=a.first; num+=a.second; } if(node-\u0026gt;right){ pii a=dfs(node-\u0026gt;right); ans+=a.first; num+=a.second; } if(ans/num==node-\u0026gt;val){ cnt++; } return make_pair(ans,num); } }; T3 统计打字方案数 Alice 在给 Bob 用手机打字。数字到字母的 对应 如下图所示。 为了 打出 一个字母，Alice 需要 按 对应字母 i 次，i 是该字母在这个按键上所处的位置。 比方说，为了按出字母 \u0026rsquo;s\u0026rsquo; ，Alice 需要按 \u0026lsquo;7\u0026rsquo; 四次。类似的， Alice 需要按 \u0026lsquo;5\u0026rsquo; 两次得到字母 \u0026lsquo;k\u0026rsquo; 。 注意，数字 \u0026lsquo;0\u0026rsquo; 和 \u0026lsquo;1\u0026rsquo; 不映射到任何字母，所以 Alice 不 使用它们。 但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 按键的字符串信息 。\n比方说，Alice 发出的信息为 \u0026ldquo;bob\u0026rdquo; ，Bob 将收到字符串 \u0026ldquo;2266622\u0026rdquo; 。 给你一个字符串 pressedKeys ，表示 Bob 收到的字符串，请你返回 Alice 总共可能发出多少种文字信息 。\n由于答案可能很大，将它对 109 + 7 取余 后返回。\n示例 1：\n1 2 3 4 5 6 输入：pressedKeys = \u0026#34;22233\u0026#34; 输出：8 解释： Alice 可能发出的文字信息包括： \u0026#34;aaadd\u0026#34;, \u0026#34;abdd\u0026#34;, \u0026#34;badd\u0026#34;, \u0026#34;cdd\u0026#34;, \u0026#34;aaae\u0026#34;, \u0026#34;abe\u0026#34;, \u0026#34;bae\u0026#34; 和 \u0026#34;ce\u0026#34; 。 由于总共有 8 种可能的信息，所以我们返回 8 。 示例 2：\n1 2 3 4 5 输入：pressedKeys = \u0026#34;222222222222222222222222222222222222\u0026#34; 输出：82876089 解释： 总共有 2082876103 种 Alice 可能发出的文字信息。 由于我们需要将答案对 109 + 7 取余，所以我们返回 2082876103 % (109 + 7) = 82876089 。 提示：\n1 2 1 \u0026lt;= pressedKeys.length \u0026lt;= 105 pressedKeys 只包含数字 \u0026#39;2\u0026#39; 到 \u0026#39;9\u0026#39; 。 思路 这题写完T4回来看才写出来 不难看出我们要进行分组计算(连续相同的字母化为一组)，并根据乘法原则计算最终结果 最开始一直想找出数学规律算出每一组(另外比赛还有一个错误就是没发现7，9不同有四种可能) 后来尝试记忆化搜索\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution: def countTexts(self, pressedKeys: str) -\u0026gt; int: mod=int(1e9+7) @cache def dfs(i,size,t): if i==size: return 1 elif i\u0026gt;size: return 0 s=0 for k in range(i+1,i+4+t): s+=dfs(k,size,t) return s s=pressedKeys[0] pressedKeys+=\u0026#39;1\u0026#39; cnt=0 ans=1 for i in pressedKeys: if i!=s: t=0 if s==\u0026#39;7\u0026#39; or s==\u0026#39;9\u0026#39;: t=1 ans*=dfs(0,cnt,t) #xxx cnt=1 s=i else: cnt+=1 return ans%mod 竟然MLE了，无妨改成递推形式+预处理全部\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 size=100009 a=[0]*size b=[0]*size for i in range(100000,-1,-1): if i==100000: a[i]=1 else: a[i]=a[i+1]+a[i+2]+a[i+3] for i in range(100000,-1,-1): if i==100000: b[i]=1 else: b[i]=b[i+1]+b[i+2]+b[i+3]+b[i+4] class Solution: def countTexts(self, pressedKeys: str) -\u0026gt; int: mod=int(1e9+7) s=pressedKeys[0] pressedKeys+=\u0026#39;1\u0026#39; cnt=0 ans=1 for i in pressedKeys: if i!=s: t=0 if s==\u0026#39;7\u0026#39; or s==\u0026#39;9\u0026#39;: ans*=b[100000-cnt] else: ans*=a[100000-cnt] cnt=1 s=i else: cnt+=1 return ans%mod 但是还是MLE，这是为什么呢 答案是：b中的数会很大很大，占据内存大 本来用py就是为了避免高精度，所以一直懒得分步取模，所以MLE了，这个是真的难找出来 加入分步取模AC了\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 size=10**5 mod=int(1e9+7) a=[0]*(size+4) b=[0]*(size+5) for i in range(size,-1,-1): if i==size: a[i]=1 else: a[i]=(a[i+1]+a[i+2]+a[i+3])%mod a[i]%=mod for i in range(size,-1,-1): if i==size: b[i]=1 else: b[i]=(b[i+1]+b[i+2]+b[i+3]+b[i+4])%mod b[i]%=mod class Solution: def countTexts(self, pressedKeys: str) -\u0026gt; int: s=pressedKeys[0] pressedKeys+=\u0026#39;1\u0026#39; cnt=0 ans=1 for i in pressedKeys: if i!=s: t=0 if s==\u0026#39;7\u0026#39; or s==\u0026#39;9\u0026#39;: ans*=b[size-cnt] else: ans*=a[size-cnt] cnt=1 s=i else: cnt+=1 return ans%mod T4 检查是否有合法括号字符串路径 一个括号字符串是一个 非空 且只包含 \u0026lsquo;(\u0026rsquo; 和 \u0026lsquo;)\u0026rsquo; 的字符串。如果下面 任意 条件为 真 ，那么这个括号字符串就是 合法的 。\n字符串是 () 。 字符串可以表示为 AB（A 连接 B），A 和 B 都是合法括号序列。 字符串可以表示为 (A) ，其中 A 是合法括号序列。 给你一个 m x n 的括号网格图矩阵 grid 。网格图中一个 合法括号路径 是满足以下所有条件的一条路径：\n路径开始于左上角格子 (0, 0) 。 路径结束于右下角格子 (m - 1, n - 1) 。 路径每次只会向 下 或者向 右 移动。 路径经过的格子组成的括号字符串是 合法 的。 如果网格图中存在一条 合法括号路径 ，请返回 true ，否则返回 false 。\n示例 1： 1 2 3 4 5 6 输入：grid = [[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;],[\u0026#34;)\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;)\u0026#34;],[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;)\u0026#34;],[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;)\u0026#34;]] 输出：true 解释：上图展示了两条路径，它们都是合法括号字符串路径。 第一条路径得到的合法字符串是 \u0026#34;()(())\u0026#34; 。 第二条路径得到的合法字符串是 \u0026#34;((()))\u0026#34; 。 注意可能有其他的合法括号字符串路径。 示例 2：\n1 2 3 输入：grid = [[\u0026#34;)\u0026#34;,\u0026#34;)\u0026#34;],[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;]] 输出：false 解释：两条可行路径分别得到 \u0026#34;))(\u0026#34; 和 \u0026#34;)((\u0026#34; 。由于它们都不是合法括号字符串，我们返回 false 。 提示：\n1 2 3 4 m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 100 grid[i][j] 要么是 \u0026#39;(\u0026#39; ，要么是 \u0026#39;)\u0026#39; 。 思路 一眼dp，用数值模拟括号而非栈，快速AC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution: def hasValidPath(self, grid: List[List[str]]) -\u0026gt; bool: @cache def dfs(i,j,s): # print(i,j,s) if i\u0026gt;=len(grid)-1 and j\u0026gt;=len(grid[0])-1: # print(s) return s==0 a=False if j\u0026lt;len(grid[0])-1: if grid[i][j+1]==\u0026#39;)\u0026#39; and s\u0026gt;0: a|= dfs(i,j+1,s-1) elif grid[i][j+1]==\u0026#39;(\u0026#39;: a|= dfs(i,j+1,s+1) if i\u0026lt;len(grid)-1: if grid[i+1][j]==\u0026#39;)\u0026#39; and s\u0026gt;0: a|= dfs(i+1,j,s-1) elif grid[i+1][j]==\u0026#39;(\u0026#39;: a|= dfs(i+1,j,s+1) return a if grid[0][0]!=\u0026#39;(\u0026#39;: return False return dfs(0,0,1) ","date":"2023-05-29T00:00:00Z","image":"https://pic.lingkou.xyz/1651221841-OkHrex-1760-360%20Cider.png","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-292/","title":"lc weekly contest 292"},{"content":"Topics1 Logic and proofs Set, functions, sequences, and summations Counting Relations Graph theory Tree Boolean algebra Logic and Proofs Propositional logic Truth table (Given a proposition, draw the truth table)\nLogical operators Conjunction ∧\nDisjunction ∨\nExclusive OR ⊕ Implication $→$\nPropositional equivalence Laws De Morgan’s laws (否定拆括号取反) Distributive(分配) laws $p\\rightarrow q=\\neg p \\vee q$ Tautology and contradiction Given two propositions, prove they are equivalent\nPredicates Universal quantification\nExistential quantification\nTranslate a sentence to a logical expression\nProofs Inference rules 推理规则 (prove or disprove an argument)\n肯定前件推理 $p\\wedge( p \\rightarrow q)\\Rightarrow q$ 否定后件推理 $\\neg q \\wedge(p\\rightarrow q) \\Rightarrow \\neg p$ 析取三段论 假说演绎推理 归结推理 Argument Valid argument Invalid argument Proof methods direct proofs Indirect proofs Proof by contraposition(非非反) Proof by contradiction\nExistence proof (constructive and non-constructive) Uniqueness proof (two steps) 存在且仅存在一个 假设存在两个满足,然后证明两个相等\nSets, Functions, Sequences and Summations Sets Subset 子集,空集,非空真子集,真子集\nPowerset (P(S)=A∣A⊆S)\nCardinality 集合元素个数，特别有|P(S)|=$2^n$\nCartesian product(笛卡尔积) 全部组合\nSet operations Set identity (prove two sets are the same)\nDe Morgan’s Law Laws and membership table 0,1表\nFunctions One-to-one functions (injection) 单射,一一对应\nOnto functions (surjection) 满射,全部y都有x\nOne-to-one and onto functions (bijection) 单加满\nSpecial functions Ceiling function上 Floor function下 Sequences and summations Countings Rules Product rule 乘法原理\nSum rule 加法原理\n隔板法 Principles Inclusion-exclusion principle 容斥\nPigeonhole principle 抽屉原理(ceil(n/k))\nPermutation and combination $$P(n,r)=n!/(n-r)!$$\nRecurrence relation $$C(n,r)=n!/[(n-r)!*r!]$$\nConstruct a recurrence relation Solve a recurrence relation $$ a_n=c_1a_{n-1}+c_2a_{n-2} \\ r^2-c_1r-c_2=0 \\ a_n=k_1r_1^n+k_2r_2^n $$\nRelations Representing relations There are several other ways to represent relations\nTables Matrices Graphs Relations on a set A relation on the set is a relation from 𝐴 to 𝐴\nReflexive (a,a) belongs to R for all element in A\nSymmetric 对称\nAnti-symmetric 反对称\nTransitive 传递性\nEquivalence relation Equivalence relation and Partition Equivalence relation ⇔ Partition\nProve a relation is an equivalence relation. Reflexive Symmetric Transitive\nGiven an equivalence relation, list equivalent classes (give the partition) Graph Theory Graph Definition G=(V,E)\nRepresenting graphs (adjacency matrix, adjacency list, and sketch) Isomorphism 邻接矩阵 $bijection f:V_1 \\rightarrow V_2: \\forall a,b \\in V_1((a,b)\\in E_1 \\leftrightarrow (f(a),f(b))\\in E_2) $ Eular path and Eular circuit containing every edge (simple path)\n欧拉回路:each vertex has even degree\n欧拉路径在连通multi: exactly 2 vertices of odd degree\nHamilton path and Hamilton circuit each vertex once\nOre’s theorem If for every pair of nonadjacent vertices u and v in the simple graph G with n vertices, deg(u) + deg(v) ≥ n ,then has a Hamilton circuit.\nDirac’s theorem If the degree of each vertex is great than or equals n/2 in the connected simple graph G with n vertices where n ≥ 3, then G has a Hamilton circuit.\nPlanar graphs r=e–v+2\nEuler’s Formula G is a connected planar simple graph\nv ≥ 3, then e ≤ 3v – 6 G has a vertex of degree not exceeding 5 if v\u0026gt;=3 and no circuits of length 3,then e\u0026lt;=2v-4 Trees Tree traversal Preorder traversal 中左1右\nIn-order traversal 左1中右\nPost-order traversal 左1右中\nExpression forms (conversion among the different forms) 关键 Internal vertices(非叶子节点) represent operations\nLeaves(叶子节点) represent the variables or numbers\nInfix prefix postfix Spanning tree DFS 回溯(字母序)\nBFS 都走(字母序,不重复)\nBoolean Algebra Boolean expressions . 与 product + 或 sum - 非 complement Boolean identities 换成逻辑表达式再换回来记忆\nmin-term(最小项) A min-term of Boolean variables x1, x2, ⋯ ,xn is a Boolean product of literals2 y1y2 , ⋯ , yn where yi (1 ≤ i ≤ n ) is either xi or complement of xi Each min-term has exactly one literal for every variable.\nDNF 任何命题公式，最终都能够化成 ( A 1 ∧ A 2 ) ∨ ( A 3 ∧ A 4 )的形式，这种先 ∧ 合 取 再 ∨ 析 取 的范式，被称为 “析取范式”。\nDNF is the unique sum of min-terms of the variables in the expression,Also called sum of products expansion\nSOP是DNF的化简，DNF是SOP的扩展3\nMaxterms(最大项) A max-term of Boolean variables x1, x2, ⋯ , is the sum of literals y1 + y2+, ⋯ ,yn + where (1 ≤ i ≤ n) is either xi or complement of xi\nCNF 任何命题公式，最终都能够化成 ( A 1 ∨ A 2 ) ∧ ( A 3 ∨ A 4 ) 的形式，这种先 ∨ 析 取 再 ∧ 合 取 的范式，被称为 “ 合取范式”。\nPOS同上\nIf we have DNF for $\\overline F $, then get CNF from $\\overline{\\overline F} $\nEquivalence of expressions Funtion completeness can represent {+ . ——} using Operate O\nLogic circuits Logic gates Logic circuits Karnaugh maps4 1、取大不取小，圈越大，消去的变量越多，与项越简单，能画入大圈就不画入小圈；\n2、圈数越少，化简后的与项就越少；\n3、一个最小项可以重复使用，即只要需要，一个方格可以同时被多圈所圈\nSteps in designing a logic circuit 推荐阅读\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA literal is a Boolean variable or its complement.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n有些书上定义DNF为SOP，将SOP的扩展叫做CDNF，本文不采用这种定义\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n可以参考\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-05-29T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/dm-quick-review/","title":"离散数学知识速查"},{"content":"前言 题目分布:简单,中等,困难,困难\nT3卡常坐大牢\nT1 将找到的值乘以 2 给你一个整数数组 nums ，另给你一个整数 original ，这是需要在 nums 中搜索的第一个数字。\n接下来，你需要按下述步骤操作：\n如果在 nums 中找到 original ，将 original 乘以 2 ，得到新 original（即，令 original = 2 * original）。\n否则，停止这一过程。 只要能在数组中找到新 original ，就对新 original 继续 重复 这一过程。\n返回 original 的 最终 值。\n示例 1：\n1 2 输入：nums = [5,3,6,1,12], original = 3 输出：24 解释：\n3 能在 nums 中找到。3 * 2 = 6 。 6 能在 nums 中找到。6 * 2 = 12 。 12 能在 nums 中找到。12 * 2 = 24 。 24 不能在 nums 中找到。因此，返回 24 。 示例 2：\n1 2 输入：nums = [2,7,9], original = 4 输出：4 解释：\n4 不能在 nums 中找到。因此，返回 4 。 提示：\n1 2 1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i], original \u0026lt;= 1000 思路 由于数据范围很小,所以怎么写都行\n这里的二分还可以继续优化 这道题还可以用哈希表达到近似O(n) 甚至可以用位运算达到严格O(n)1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #define debug(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; class Solution { public: int findFinalValue(vector\u0026lt;int\u0026gt;\u0026amp; nums, int original) { sort(nums.begin(),nums.end()); auto s=nums.begin(); // debug(0,nums.size()-1,nums) while(1){ int x=lower_bound(nums.begin(),nums.end(),original)-nums.begin(); if (x\u0026gt;=nums.size()||nums[x]!=original){ break; } original*=2; } return original; } }; T2 分组得分最高的所有下标 给你一个下标从 0 开始的二进制数组 nums ，数组长度为 n 。nums 可以按下标 i（ 0 \u0026lt;= i \u0026lt;= n ）拆分成两个数组（可能为空）：numsleft 和 numsright 。\nnumsleft 包含 nums 中从下标 0 到 i - 1 的所有元素（包括 0 和 i - 1 ），而 numsright 包含 nums 中从下标 i 到 n - 1 的所有元素（包括 i 和 n - 1 ）。\n如果 i == 0 ，numsleft 为 空 ，而 numsright 将包含 nums 中的所有元素。\n如果 i == n ，numsleft 将包含 nums 中的所有元素，而 numsright 为 空 。\n下标 i 的 分组得分 为 numsleft 中 0 的个数和 numsright 中 1 的个数之 和 。\n返回 分组得分 最高 的 所有不同下标 。你可以按 任意顺序 返回答案。\n示例 1：\n1 2 输入：nums = [0,0,1,0] 输出：[2,4] 解释：按下标分组\n0 ：numsleft 为 [] 。numsright 为 [0,0,1,0] 。得分为 0 + 1 = 1 。 1 ：numsleft 为 [0] 。numsright 为 [0,1,0] 。得分为 1 + 1 = 2 。 2 ：numsleft 为 [0,0] 。numsright 为 [1,0] 。得分为 2 + 1 = 3 。 3 ：numsleft 为 [0,0,1] 。numsright 为 [0] 。得分为 2 + 0 = 2 。 4 ：numsleft 为 [0,0,1,0] 。numsright 为 [] 。得分为 3 + 0 = 3 。 下标 2 和 4 都可以得到最高的分组得分 3 。 注意，答案 [4,2] 也被视为正确答案。 示例 2：\n1 2 输入：nums = [0,0,0] 输出：[3] 解释：按下标分组\n0 ：numsleft 为 [] 。numsright 为 [0,0,0] 。得分为 0 + 0 = 0 。 1 ：numsleft 为 [0] 。numsright 为 [0,0] 。得分为 1 + 0 = 1 。 2 ：numsleft 为 [0,0] 。numsright 为 [0] 。得分为 2 + 0 = 2 。 3 ：numsleft 为 [0,0,0] 。numsright 为 [] 。得分为 3 + 0 = 3 。 只有下标 3 可以得到最高的分组得分 3 。 示例 3：\n1 2 输入：nums = [1,1] 输出：[0] 解释：按下标分组\n0 ：numsleft 为 [] 。numsright 为 [1,1] 。得分为 0 + 2 = 2 。 1 ：numsleft 为 [1] 。numsright 为 [1] 。得分为 0 + 1 = 1 。 2 ：numsleft 为 [1,1] 。numsright 为 [] 。得分为 0 + 0 = 0 。 只有下标 0 可以得到最高的分组得分 2 。 提示：\n1 2 3 n == nums.length 1 \u0026lt;= n \u0026lt;= 105 nums[i] 为 0 或 1 思路 写的时候没仔细看题目,长度为n应该有n+1中选择情况,后来改动的时候没有保持不变量,调参调了半天 思路: 维护前缀和即可,由sum减去得出后缀 当然可以维护前后缀,好写一点 这里还可以压缩成一次遍历2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define debug(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; const int N=1e5+2; int b[N]; class Solution { public: vector\u0026lt;int\u0026gt; maxScoreIndices(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans=0; FOR(i,0,nums.size()){ //左边1的个数 b[i+1]=b[i]+nums[i]; ans+=nums[i]; } // debug(0,nums.size(),b) int max_=0; FOR(i,0,nums.size()+1){ max_=max(max_, i-b[i]+ans-b[i] ); } vector\u0026lt;int\u0026gt; res; FOR(i,0,nums.size()+1){ if(i-b[i]+ans-b[i]==max_)res.push_back(i); } return res; } }; T3 查找给定哈希值的子串 给定整数 p 和 m ，一个长度为 k 且下标从 0 开始的字符串 s 的哈希值按照如下函数计算：\nhash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + \u0026hellip; + val(s[k-1]) * pk-1) mod m.\n其中 val(s[i]) 表示 s[i] 在字母表中的下标，从 val(\u0026lsquo;a\u0026rsquo;) = 1 到 val(\u0026lsquo;z\u0026rsquo;) = 26 。\n给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 k 的 子串 sub ，满足 hash(sub, power, modulo) == hashValue 。\n测试数据保证一定 存在 至少一个这样的子串。\n子串 定义为一个字符串中连续非空字符组成的序列。\n示例 1：\n1 2 3 4 输入：s = \u0026#34;leetcode\u0026#34;, power = 7, modulo = 20, k = 2, hashValue = 0 输出：\u0026#34;ee\u0026#34; 解释：\u0026#34;ee\u0026#34; 的哈希值为 hash(\u0026#34;ee\u0026#34;, 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。 \u0026#34;ee\u0026#34; 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 \u0026#34;ee\u0026#34; 。 示例 2：\n1 2 3 4 5 6 输入：s = \u0026#34;fbxzaad\u0026#34;, power = 31, modulo = 100, k = 3, hashValue = 32 输出：\u0026#34;fbx\u0026#34; 解释：\u0026#34;fbx\u0026#34; 的哈希值为 hash(\u0026#34;fbx\u0026#34;, 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32 。 \u0026#34;bxz\u0026#34; 的哈希值为 hash(\u0026#34;bxz\u0026#34;, 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32 。 \u0026#34;fbx\u0026#34; 是长度为 3 的第一个哈希值为 32 的子串，所以我们返回 \u0026#34;fbx\u0026#34; 。 注意，\u0026#34;bxz\u0026#34; 的哈希值也为 32 ，但是它在字符串中比 \u0026#34;fbx\u0026#34; 更晚出现。 提示：\n1 2 3 4 5 1 \u0026lt;= k \u0026lt;= s.length \u0026lt;= 2 * 104 1 \u0026lt;= power, modulo \u0026lt;= 109 0 \u0026lt;= hashValue \u0026lt; modulo s 只包含小写英文字母。 测试数据保证一定 存在 满足条件的子串。 思路 先写一个暴力滑窗解法\n1 2 3 4 5 6 7 8 9 10 11 class Solution: def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -\u0026gt; str: def f(p,m,start,end): hashv=0 for i in range(start,end+1): hashv+=(ord(s[i])-ord(\u0026#39;a\u0026#39;)+1)*(p**(i-start)) return hashv%m for i in range(k-1,len(s)): if f(power,modulo,i-k+1,i)==hashValue: return s[i-k+1:i+1] return s 毫无悬念的T了 将f尝试改成\n1 2 3 4 5 6 def f(p,m,start,end): hashv=0 for i in range(start,end+1): hashv+=(ord(s[i])-ord(\u0026#39;a\u0026#39;)+1)*(p**(i-start))%m hashv%=m return hashv%m 还是T,不过这也很正常\n如何优化?不难看出在求f函数是可以优化的,f可以由上个一个的f转移过来 即上一个f减去第一项再除以p在加上最新一项即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution: def subStrHash(self, s: str, p: int, m: int, k: int, hashValue: int) -\u0026gt; str: hashv=0 for i in range(k-1,len(s)): if i==k-1: for j in range(i-k+1,i+1): hashv+=(ord(s[j])-ord(\u0026#39;a\u0026#39;)+1)*(p**(j-i+k-1)) else: hashv-=(ord(s[i-k])-ord(\u0026#39;a\u0026#39;)+1) hashv//=p hashv+=(ord(s[i])-ord(\u0026#39;a\u0026#39;)+1)*(p**(k-1)) if hashv%m==hashValue: return s[i-k+1:i+1] #print(hashv,i) return s 还是T? 因为除法取余不恒等,不能分步优化 那怎么改呢 倒叙即可,顺便加入点优化3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def subStrHash(self, s: str, p: int, m: int, k: int, hashValue: int) -\u0026gt; str: hashv=0 bas=p**(k-1) a=b=0 for i in range(len(s)-1,k-2,-1): if i==len(s)-1: for j in range(i-k+1,i+1): hashv+=(ord(s[j])-ord(\u0026#39;a\u0026#39;)+1)*(p**(j-i+k-1))%m hashv%=m else: hashv-=((ord(s[i+1])-ord(\u0026#39;a\u0026#39;)+1)*bas)%m hashv%=m hashv*=p hashv%=m hashv+=(ord(s[i-k+1])-ord(\u0026#39;a\u0026#39;)+1)%m hashv%=m if hashv==hashValue: a=i-k+1 b=i+1 return s[a:b] 但是,最坐牢的时刻来了,这样还是T 快速幂的时候也引入取余,最终AC了\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def subStrHash(self, s: str, p: int, m: int, k: int, hashValue: int) -\u0026gt; str: hashv=0 bas=pow(p,k - 1,m) a=b=0 for i in range(len(s)-1,k-2,-1): if i==len(s)-1: for j in range(i-k+1,i+1): hashv+=(ord(s[j])-ord(\u0026#39;a\u0026#39;)+1)*pow(p,j-i+k-1,m)%m hashv%=m else: hashv-=((ord(s[i+1])-ord(\u0026#39;a\u0026#39;)+1)*bas)%m hashv%=m hashv*=p hashv%=m hashv+=(ord(s[i-k+1])-ord(\u0026#39;a\u0026#39;)+1)%m hashv%=m if hashv==hashValue: a=i-k+1 b=i+1 return s[a:b] 其实这道题主要卡时间复杂度的在幂函数这里,所以只优化幂函数,不优化后面的转移也能卡过去(即无需倒叙)4\nT4 字符串分组 给你一个下标从 0 开始的字符串数组 words 。每个字符串都只包含 小写英文字母 。words 中任意一个子串中，每个字母都至多只出现一次。\n如果通过以下操作之一，我们可以从 s1 的字母集合得到 s2 的字母集合，那么我们称这两个字符串为 关联的 ：\n往 s1 的字母集合中添加一个字母。\n从 s1 的字母集合中删去一个字母。\n将 s1 中的一个字母替换成另外任意一个字母,也可以替换为这个字母本身。 数组 words 可以分为一个或者多个无交集的 组 。如果一个字符串与另一个字符串关联，那么它们应当属于同一个组。\n注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。\n请你返回一个长度为 2 的数组 ans ：\nans[0] 是 words 分组后的 总组数 。\nans[1] 是字符串数目最多的组所包含的字符串数目。\n示例 1：\n1 2 输入：words = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;ab\u0026#34;,\u0026#34;cde\u0026#34;] 输出：[2,3] 解释：\nwords[0] 可以得到 words[1] （将 \u0026lsquo;a\u0026rsquo; 替换为 \u0026lsquo;b\u0026rsquo;）和 words[2] （添加 \u0026lsquo;b\u0026rsquo;）。所以 words[0] 与 words[1] 和 words[2] 关联。 words[1] 可以得到 words[0] （将 \u0026lsquo;b\u0026rsquo; 替换为 \u0026lsquo;a\u0026rsquo;）和 words[2] （添加 \u0026lsquo;a\u0026rsquo;）。所以 words[1] 与 words[0] 和 words[2] 关联。 words[2] 可以得到 words[0] （删去 \u0026lsquo;b\u0026rsquo;）和 words[1] （删去 \u0026lsquo;a\u0026rsquo;）。所以 words[2] 与 words[0] 和 words[1] 关联。 words[3] 与 words 中其他字符串都不关联。 所以，words 可以分成 2 个组 [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;ab\u0026rdquo;] 和 [\u0026ldquo;cde\u0026rdquo;] 。最大的组大小为 3 。 示例 2：\n1 2 输入：words = [\u0026#34;a\u0026#34;,\u0026#34;ab\u0026#34;,\u0026#34;abc\u0026#34;] 输出：[1,3] 解释：\nwords[0] 与 words[1] 关联。 words[1] 与 words[0] 和 words[2] 关联。 words[2] 与 words[1] 关联。 由于所有字符串与其他字符串都关联，所以它们全部在同一个组内。 所以最大的组大小为 3 。 提示：\n1 2 3 4 1 \u0026lt;= words.length \u0026lt;= 2 * 104 1 \u0026lt;= words[i].length \u0026lt;= 26 words[i] 只包含小写英文字母。 words[i] 中每个字母最多只出现一次。 思路 没时间看了\n后面再补上吧 见这里\n可以参考这个帖子\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nleetcode官方解答一次遍历即可\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n当然也可以用逆元正向遍历\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n例如这个预处理幂加上其它剪枝也能AC\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-05-28T00:00:00Z","image":"https://pic.lingkou.xyz/1642577172-whzTsr-1760-360%20%E5%85%AD%E6%96%B9%E4%BA%91.png","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-278/","title":"lc weekly contest 278"},{"content":"什么是摩尔投票 摩尔投票是一种用来解决绝对众数1问题的算法 它能使用O(1)级别的空间复杂度找出绝对众数\n经典例题2 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int t=0,cnt=0; for(auto i:nums){ if(i==t)cnt++; else if(--cnt\u0026lt;0){ t=i; cnt=1; } } return t; } }; 区间绝对众数3 设计一个数据结构，有效地找到给定子数组的 多数元素 。\n子数组的 多数元素 是在子数组中出现 threshold 次数或次数以上的元素。\n实现 MajorityChecker 类:\nMajorityChecker(int[] arr) 会用给定的数组 arr 对 MajorityChecker 初始化。 int query(int left, int right, int threshold) 返回子数组中的元素 arr[left...right] 至少出现 threshold 次数，如果不存在这样的元素则返回 -1。 示例 1：\n1 2 3 4 5 6 7 8 9 10 输入: [\u0026#34;MajorityChecker\u0026#34;, \u0026#34;query\u0026#34;, \u0026#34;query\u0026#34;, \u0026#34;query\u0026#34;] [[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]] 输出： [null, 1, -1, 2] 解释： MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]); majorityChecker.query(0,5,4); // 返回 1 majorityChecker.query(0,3,3); // 返回 -1 majorityChecker.query(2,3,2); // 返回 2 提示：\n1 \u0026lt;= arr.length \u0026lt;= 2 * 104 1 \u0026lt;= arr[i] \u0026lt;= 2 * 104 0 \u0026lt;= left \u0026lt;= right \u0026lt; arr.length threshold \u0026lt;= right - left + 1 2 * threshold \u0026gt; right - left + 1 调用 query 的次数最多为 104 参考 通俗易懂摩尔投票法 算法学习笔记(78): 摩尔投票 在一个集合中，如果一个元素的出现次数比其他所有元素的出现次数之和还多，那么就称它为这个集合的绝对众数。等价地说，绝对众数的出现次数大于总元素数的一半。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n题目来源:https://leetcode.cn/problems/majority-element/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n题目来源LC1157. 子数组中占绝大多数的元素\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-05-28T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/boyermoore-majority-vote-algorithm/","title":"摩尔投票"},{"content":"天才ACM 题目描述 给定一个整数 M，对于任意一个整数集合 S，定义“校验值”如下:\n从集合 S 中取出 M 对数(即 2×M 个数，不能重复使用集合中的数，如果 S 中的整数不够 M 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 S 的“校验值”。\n现在给定一个长度为 N 的数列 A 以及一个整数 T。\n我们要把 A 分成若干段，使得每一段的“校验值”都不超过 T。\n求最少需要分成几段。\n样例 输入样例：\n2\n5 1 49\n8 2 1 7 9\n5 1 64\n8 2 1 7 9\n输出样例：\n2\n1\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;ctime\u0026gt; using namespace std; typedef long long ll; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(ll w=(a);w\u0026lt;(n);++w) #define debug(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; #define inf 0x3f typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5e6+9; ll a[N],b[N],temp[N]; ll t; ll k,m,n; inline ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } bool check(ll l,ll last,ll r){ if(l==last){ ll x=a[l]; ll y=a[r]; temp[l]=min(x,y); temp[r]=max(x,y); ll ans=(x-y)*(x-y); return ans\u0026lt;=t; } FOR(i,last+1,r+1){ b[i]=a[i]; } sort(b+last+1,b+r+1); //merge int p1=l,p2=last+1,pp=l; while(p1\u0026lt;=last\u0026amp;\u0026amp;p2\u0026lt;=r){ if(b[p1]\u0026lt;b[p2])temp[pp++]=b[p1++]; else temp[pp++]=b[p2++]; } while(p1\u0026lt;=last)temp[pp++]=b[p1++]; while(p2\u0026lt;=r)temp[pp++]=b[p2++]; //check ll num=m; ll sums=0; ll ll=l,rr=r; while(num\u0026amp;\u0026amp;l\u0026lt;r){ num--; sums+=(temp[r]-temp[l])*(temp[r]-temp[l]); l++; r--; } //cout\u0026lt;\u0026lt;\u0026#34; l:\u0026#34;\u0026lt;\u0026lt;ll\u0026lt;\u0026lt;\u0026#34; last:\u0026#34;\u0026lt;\u0026lt;last\u0026lt;\u0026lt;\u0026#34; r:\u0026#34;\u0026lt;\u0026lt;rr\u0026lt;\u0026lt;\u0026#34; sums:\u0026#34;\u0026lt;\u0026lt;sums\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; //debug(ll,rr,temp) return sums\u0026lt;=t; } int main() { // freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); // freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); k=read(); while(k--){ n=read(); m=read(); t=read(); FOR(i,1,n+1)a[i]=read(); //strat from 1 ,[l,r+size] ll cnt=0,l=1,r=1,size=1; while(r\u0026lt;n+1){ while(size){ if(r+size\u0026lt;n+1\u0026amp;\u0026amp;check(l,r,r+size)){ r+=size; size*=2; FOR(i,l,r+1)b[i]=temp[i]; //cout\u0026lt;\u0026lt;\u0026#34;ss\u0026#34;\u0026lt;\u0026lt;endl; //debug(l,r,b) //cout\u0026lt;\u0026lt;\u0026#34;ss\u0026#34;\u0026lt;\u0026lt;endl; } else{ size/=2; } } //cout\u0026lt;\u0026lt;\u0026#34;!!!!!!!!!!!\u0026#34;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cnt++; size=1; r++; l=r; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } return 0; } st表 详见st表模板\n","date":"2023-05-27T01:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue06/","title":"小蓝书0X06倍增---天才ACM"},{"content":"前言 待更新\nT1 购买两块巧克力 给你一个整数数组 prices ，它表示一个商店里若干巧克力的价格。同时给你一个整数 money ，表示你一开始拥有的钱数。\n你必须购买 恰好 两块巧克力，而且剩余的钱数必须是 非负数 。同时你想最小化购买两块巧克力的总花费。\n请你返回在购买两块巧克力后，最多能剩下多少钱。如果购买任意两块巧克力都超过了你拥有的钱，请你返回 money 。注意剩余钱数必须是非负数。\n示例 1：\n1 2 3 输入：prices = [1,2,2], money = 3 输出：0 解释：分别购买价格为 1 和 2 的巧克力。你剩下 3 - 3 = 0 块钱。所以我们返回 0 。 示例 2：\n1 2 3 输入：prices = [3,2,3], money = 3 输出：3 解释：购买任意 2 块巧克力都会超过你拥有的钱数，所以我们返回 3 。 提示：\n1 2 3 2 \u0026lt;= prices.length \u0026lt;= 50 1 \u0026lt;= prices[i] \u0026lt;= 100 1 \u0026lt;= money \u0026lt;= 100 思路 模拟\n1 2 3 4 5 class Solution: def buyChoco(self, prices: List[int], money: int) -\u0026gt; int: prices.sort() x=money-prices[0]+prices[1] return x if x\u0026gt;=0 else money T2 字符串中的额外字符 给你一个下标从 0 开始的字符串 s 和一个单词字典 dictionary 。你需要将 s 分割成若干个 互不重叠 的子字符串，每个子字符串都在 dictionary 中出现过。s 中可能会有一些 额外的字符 不在任何子字符串中。\n请你采取最优策略分割 s ，使剩下的字符 最少 。\n示例 1：\n1 2 3 输入：s = \u0026#34;leetscode\u0026#34;, dictionary = [\u0026#34;leet\u0026#34;,\u0026#34;code\u0026#34;,\u0026#34;leetcode\u0026#34;] 输出：1 解释：将 s 分成两个子字符串：下标从 0 到 3 的 \u0026#34;leet\u0026#34; 和下标从 5 到 8 的 \u0026#34;code\u0026#34; 。只有 1 个字符没有使用（下标为 4），所以我们返回 1 。 示例 2：\n1 2 3 输入：s = \u0026#34;sayhelloworld\u0026#34;, dictionary = [\u0026#34;hello\u0026#34;,\u0026#34;world\u0026#34;] 输出：3 解释：将 s 分成两个子字符串：下标从 3 到 7 的 \u0026#34;hello\u0026#34; 和下标从 8 到 12 的 \u0026#34;world\u0026#34; 。下标为 0 ，1 和 2 的字符没有使用，所以我们返回 3 。 提示：\n1 2 3 4 5 1 \u0026lt;= s.length \u0026lt;= 50 1 \u0026lt;= dictionary.length \u0026lt;= 50 1 \u0026lt;= dictionary[i].length \u0026lt;= 50 dictionary[i] 和 s 只包含小写英文字母。 dictionary 中的单词互不相同 思路 一开始没看数据大小(真的要改),死磕kmp,然后想的是贪心处理重叠选择(很明显,至少我想了好久没找出来) 后来回过头来看数据范围这么小,直接记忆化搜索AC(其实还wa了一发,用回溯偷懒没过)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution: def minExtraChar(self, s: str, dictionary: List[str]) -\u0026gt; int: ss=set(dictionary) ans=[0] @cache def dfs(i): if i\u0026gt;=len(s): return 0 res=0 for k in range(len(s)-i): if s[i:k+i+1] in ss: res=max(dfs(k+i+1)+k+1,res) else: res=max(res,dfs(k+i+1)) return res return len(s)-dfs(0) T3 一个小组的最大实力值 给你一个下标从 0 开始的整数数组 nums ，它表示一个班级中所有学生在一次考试中的成绩。老师想选出一部分同学组成一个 非空 小组，且这个小组的 实力值 最大，如果这个小组里的学生下标为 i0, i1, i2, \u0026hellip; , ik ，那么这个小组的实力值定义为 nums[i0] * nums[i1] * nums[i2] * \u0026hellip; * nums[ik​] 。\n请你返回老师创建的小组能得到的最大实力值为多少。\n示例 1：\n输入：nums = [3,-1,-5,2,5,-9]\n输出：1350\n解释：一种构成最大实力值小组的方案是选择下标为 [0,2,3,4,5] 的学生。实力值为 3 * (-5) * 2 * 5 * (-9) = 1350 ，这是可以得到的最大实力值。\n示例 2：\n输入：nums = [-4,-5,-4]\n输出：20\n解释：选择下标为 [0, 1] 的学生。得到的实力值为 20 。我们没法得到更大的实力值\n反思 很简单的一道题 这里竟然wa了三发,第一发wa在少打了一个*号,第二三发wa在没注意大小写isZero和iszero 明明本题唯一要思考的分类讨论都仔细思考了防止wa(虽然分类不够精简),却在打字上过于急躁wa\n导致排名狂掉 以后无论代码有多简单一定要记得先测试一下能不能跑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution: def maxStrength(self, nums: List[int]) -\u0026gt; int: ans=1 flag=0 p=[] res=1 isZero=False for i in nums: if i\u0026gt;0: ans*=i flag=1 elif i\u0026lt;0: p.append(i) else: isZero=True p.sort() size=(len(p)//2)*2 for i in range(size): res*=p[i] if flag: return res*ans elif size\u0026gt;=2: return res elif isZero: return 0 return p[0] T4 最大公约数遍历 给你一个下标从 0 开始的整数数组 nums ，你可以在一些下标之间遍历。对于两个下标 i 和 j（i != j），当且仅当 gcd(nums[i], nums[j]) \u0026gt; 1 时，我们可以在两个下标之间通行，其中 gcd 是两个数的 最大公约数 。\n你需要判断 nums 数组中 任意 两个满足 i \u0026lt; j 的下标 i 和 j ，是否存在若干次通行可以从 i 遍历到 j 。\n如果任意满足条件的下标对都可以遍历，那么返回 true ，否则返回 false 。\n示例 1：\n1 2 3 4 5 输入：nums = [2,3,6] 输出：true 解释：这个例子中，总共有 3 个下标对：(0, 1) ，(0, 2) 和 (1, 2) 。 从下标 0 到下标 1 ，我们可以遍历 0 -\u0026gt; 2 -\u0026gt; 1 ，我们可以从下标 0 到 2 是因为 gcd(nums[0], nums[2]) = gcd(2, 6) = 2 \u0026gt; 1 ，从下标 2 到 1 是因为 gcd(nums[2], nums[1]) = gcd(6, 3) = 3 \u0026gt; 1 。 从下标 0 到下标 2 ，我们可以直接遍历，因为 gcd(nums[0], nums[2]) = gcd(2, 6) = 2 \u0026gt; 1 。同理，我们也可以从下标 1 到 2 因为 gcd(nums[1], nums[2]) = gcd(3, 6) = 3 \u0026gt; 1 。 示例 2：\n1 2 3 输入：nums = [3,9,5] 输出：false 解释：我们没法从下标 0 到 2 ，所以返回 false 。 示例 3：\n1 2 3 输入：nums = [4,3,12,8] 输出：true 解释：总共有 6 个下标对：(0, 1) ，(0, 2) ，(0, 3) ，(1, 2) ，(1, 3) 和 (2, 3) 。所有下标对之间都存在可行的遍历，所以返回 true 。 提示：\n1 2 1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 105 思路 见评论区吧\n","date":"2023-05-27T00:00:00Z","image":"https://pic.lingkou.xyz/1683871861-YilDpq-1760-360%20%E5%AE%BD%E5%BE%B7%E6%8A%95%E8%B5%84.png","permalink":"https://open17.github.io/CpHugo/p/lc-biweekly-contest-105/","title":"lc-biweekly-contest-105"},{"content":" 痛苦T4\nT1 公因子的数目 给你两个正整数 a 和 b ，返回 a 和 b 的 公 因子的数目。\n如果 x 可以同时整除 a 和 b ，则认为 x 是 a 和 b 的一个 公因子 。\n示例 1：\n输入：a = 12, b = 6 输出：4 解释：12 和 6 的公因子是 1、2、3、6 。 示例 2：\n输入：a = 25, b = 30 输出：2 解释：25 和 30 的公因子是 1、5 。\n提示：\n1 \u0026lt;= a, b \u0026lt;= 1000\n思路 模拟即可\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int commonFactors(int a, int b) { int t=min(a,b); int cnt=0; for(int i=1;i\u0026lt;=t;i++){ if(a%i==0\u0026amp;\u0026amp;b%i==0)cnt++; } return cnt; } }; T2 沙漏的最大总和 给你一个大小为 m x n 的整数矩阵 grid 。\n按以下形式将矩阵的一部分定义为一个 沙漏 ：\n返回沙漏中元素的 最大 总和。\n注意：沙漏无法旋转且必须整个包含在矩阵中。\n示例 1：\n输入：grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]\n输出：30\n解释：上图中的单元格表示元素总和最大的沙漏：6 + 2 + 1 + 2 + 9 + 2 + 8 = 30 。\n示例 2： 输入：grid = [[1,2,3],[4,5,6],[7,8,9]] 输出：35 解释：上图中的单元格表示元素总和最大的沙漏：1 + 2 + 3 + 5 + 7 + 8 + 9 = 35 。\n提示：\n1 2 3 4 m == grid.length n == grid[i].length 3 \u0026lt;= m, n \u0026lt;= 150 0 \u0026lt;= grid[i][j] \u0026lt;= 106 思路 数据小,暴力模拟也能ac 这里用前缀和优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: long long b[153][153]; int maxSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { memset(b,0,sizeof(b)); for(int i=0;i\u0026lt;grid.size();i++){ for(int j=0;j\u0026lt;grid[0].size();j++){ b[i+1][j+1]=b[i][j+1]+b[i+1][j]+grid[i][j]-b[i][j]; } } long long ans=-1; for(int i=3;i\u0026lt;=grid.size();i++){ for(int j=3;j\u0026lt;=grid[0].size();j++){ ans=max(ans,b[i][j] - b[i-3][j] - b[i][j-3] + b[i-3][j-3]-grid[i-2][j-3]-grid[i-2][j-1]); } } return ans; } }; T3 最小 XOR 给你两个正整数 num1 和 num2 ，找出满足下述条件的整数 x ：\nx 的置位数和 num2 相同，且 x XOR num1 的值 最小 注意 XOR 是按位异或运算。\n返回整数 x 。题目保证，对于生成的测试用例， x 是 唯一确定 的。\n整数的 置位数 是其二进制表示中 1 的数目。\n示例 1：\n1 2 3 4 5 输入：num1 = 3, num2 = 5 输出：3 解释： num1 和 num2 的二进制表示分别是 0011 和 0101 。 整数 3 的置位数与 num2 相同，且 3 XOR 3 = 0 是最小的。 示例 2：\n1 2 3 4 5 输入：num1 = 1, num2 = 12 输出：3 解释： num1 和 num2 的二进制表示分别是 0001 和 1100 。 整数 3 的置位数与 num2 相同，且 3 XOR 1 = 2 是最小的。 提示：\n1 1 \u0026lt;= num1, num2 \u0026lt;= 109 思路 贪心+位运算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: int lowbit(int a){ int cnt=0; while(a){ a^=(a\u0026amp;(-a)); cnt++; } return cnt; } int minimizeXor(int num1, int num2) { int cnt=lowbit(num2); int res=lowbit(num1); if(cnt==res)return num1; if(res\u0026gt;cnt){ int dif=res-cnt; int ans=0; int p=num1; while(dif){ dif--; ans+=num1\u0026amp;(-num1); num1^=(num1\u0026amp;(-num1)); } return p-ans; } int d=-1; int t=cnt-res; int ans=0; while(d\u0026lt;31\u0026amp;\u0026amp;t\u0026gt;0){ d++; if(num1\u0026amp;(1\u0026lt;\u0026lt;d)){continue;} ans+=pow(2,d); t--; } return ans+num1; } }; 缩减版 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int minimizeXor(int num1, int num2) { int c1 = __builtin_popcount(num1); int c2 = __builtin_popcount(num2); for (; c2 \u0026lt; c1; ++c2) num1 \u0026amp;= num1 - 1; // 最低的 1 变成 0 for (; c2 \u0026gt; c1; --c2) num1 |= num1 + 1; // 最低的 0 变成 1 return num1; } }; // 作者：endlesscheng T4 对字母串可执行的最大删除数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以： 删除 整个字符串 s ，或者 对于满足 1 \u0026lt;= i \u0026lt;= s.length / 2 的任意 i ，如果 s 中的 前 i 个字母和接下来的 i 个字母 相等 ，删除 前 i 个字母。 例如，如果 s = \u0026#34;ababc\u0026#34; ，那么在一步操作中，你可以删除 s 的前两个字母得到 \u0026#34;abc\u0026#34; ，因为 s 的前两个字母和接下来的两个字母都等于 \u0026#34;ab\u0026#34; 。 返回删除 s 所需的最大操作数。 示例 1： 输入：s = \u0026#34;abcabcdabc\u0026#34; 输出：2 解释： - 删除前 3 个字母（\u0026#34;abc\u0026#34;），因为它们和接下来 3 个字母相等。现在，s = \u0026#34;abcdabc\u0026#34;。 - 删除全部字母。 一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。 注意，在第二步操作中无法再次删除 \u0026#34;abc\u0026#34; ，因为 \u0026#34;abc\u0026#34; 的下一次出现并不是位于接下来的 3 个字母。 示例 2： 输入：s = \u0026#34;aaabaab\u0026#34; 输出：4 解释： - 删除第一个字母（\u0026#34;a\u0026#34;），因为它和接下来的字母相等。现在，s = \u0026#34;aabaab\u0026#34;。 - 删除前 3 个字母（\u0026#34;aab\u0026#34;），因为它们和接下来 3 个字母相等。现在，s = \u0026#34;aab\u0026#34;。 - 删除第一个字母（\u0026#34;a\u0026#34;），因为它和接下来的字母相等。现在，s = \u0026#34;ab\u0026#34;。 - 删除全部字母。 一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。 示例 3： 输入：s = \u0026#34;aaaaa\u0026#34; 输出：5 解释：在每一步操作中，都可以仅删除 s 的第一个字母。 提示： 1 \u0026lt;= s.length \u0026lt;= 4000 s 仅由小写英文字母组成 朴素记忆化搜索(MLE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution: def deleteString(self, s: str) -\u0026gt; int: if len(set(s)) == 1: return len(s) @cache def dfs(i,start): ans=0 if i\u0026gt;=len(s): if i==start: return 0 return 1 # print(s[start:i+1],s[i+1:i+1+(i+1-start)]) if s[start:i+1]==s[i+1:i+1+(i+1-start)]: ans=dfs(i+1,i+1)+1 ans=max(ans,dfs(i+1,start)) return ans dfs.cache_clear() return dfs(0,0) 朴素动态规划(TLE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution: def deleteString(self, s: str) -\u0026gt; int: size=len(s)+1 dfs=[[0]*(size+2) for _ in range(size+2)] for j in range(size): if j==size-1: dfs[size-1][j]=0 else: dfs[size-1][j]=1 for i in range(size-1,-1,-1): for j in range(size-1,-1,-1): if s[j:i+1]==s[i+1:i+1+(i+1-j)]: dfs[i][j]=dfs[i+1][i+1]+1 dfs[i][j]=max(dfs[i][j],dfs[i+1][j]) return dfs[0][0] LCP优化朴素动态规划(TLE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def deleteString(self, s: str) -\u0026gt; int: size=len(s)+1 if len(set(s)) == 1: return size-1 dfs=[[0]*(size+2) for _ in range(size+2)] lcp=[[0]*(size+2) for _ in range(size+2)] for i in range(size-2, -1, -1): for j in range(size-2, i, -1): if s[i] == s[j]: lcp[i][j] = lcp[i + 1][j + 1] + 1 for j in range(size): if j==size-1: dfs[size-1][j]=0 else: dfs[size-1][j]=1 for i in range(size-1,-1,-1): for j in range(size-1,-1,-1): if lcp[j][i+1]\u0026gt;=i+1-j: dfs[i][j]=dfs[i+1][i+1]+1 dfs[i][j]=max(dfs[i][j],dfs[i+1][j]) return dfs[0][0] 剪枝记忆化搜索(AC) 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution: def deleteString(self, s: str) -\u0026gt; int: @cache def dfs(i): s_ = s[i:] ans = 1 for j in range(1, len(s) // 2 + 1): if s_[:j] == s_[j:j*2]: ans = max(ans, 1 + dfs(i + j)) return ans dfs.cache_clear() return dfs(0) 剪枝+LCP优化动态规划(AC) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution: def deleteString(self, s: str) -\u0026gt; int: n = len(s) if len(set(s)) == 1: return n # 特判全部相同的情况 lcp = [[0] * (n + 1) for _ in range(n + 1)] # lcp[i][j] 表示 s[i:] 和 s[j:] 的最长公共前缀 for i in range(n - 1, -1, -1): for j in range(n - 1, i, -1): if s[i] == s[j]: lcp[i][j] = lcp[i + 1][j + 1] + 1 f = [0] * n for i in range(n - 1, -1, -1): for j in range(1, (n - i) // 2 + 1): if lcp[i][i + j] \u0026gt;= j: # 说明 s[i:i+j] == s[i+j:i+2*j] f[i] = max(f[i], f[i + j]) f[i] += 1 return f[0] # endlesscheng ","date":"2023-05-26T00:00:00Z","image":"https://pic.lingkou.xyz/1664008640-fTlCRH-1760-360%20%E7%A9%BA%E4%B8%AD%E4%BA%91%E6%B1%87.png","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-313/","title":"lc weekly contest 313"},{"content":"102. 最佳牛围栏 题目描述 农夫约翰的农场由 $N$ 块田地组成，每块地里都有一定数量的牛，其数量不会少于 1 头，也不会超过 2000 头。\n约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。\n围起区域内至少需要包含 $F$ 块地，其中 $F$ 会在输入中给出。\n在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。\n输入格式 第一行输入整数 $N$ 和 $F$，数据间用空格隔开。\n接下来 $N$ 行，每行输入一个整数，第 $i+1$ 行输入的整数代表第 $i$ 片区域内包含的牛的数目。\n输出格式 输出一个整数，表示平均值的最大值乘以 1000 再向下取整之后得到的结果。\n数据范围 $1≤N≤100000$\n$1≤F≤N$\n输入样例： 1 2 3 4 5 6 7 8 9 10 11 10 6 6 4 2 10 3 8 5 9 4 1 输出样例： 1 6500 tag 思维 二分 DP/前缀和 code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f3f3f3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+2; double a[N],b[N]; int n,f; bool check(double t){ FOR(i,1,n+1){ b[i]=a[i]+b[i-1]-t; } double mins=inf; double maxs=-inf; FOR(i,f,n+1){ mins=min(mins,b[i-f]); maxs=max(maxs,b[i]-mins); } return maxs\u0026gt;=0; } int main() { ios cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;f; FOR(i,1,n+1){ cin\u0026gt;\u0026gt;a[i]; } double l=1,r=2001; double eps=1e-5; while(r-l\u0026gt;eps){ double mid=(l+r)/2; if (check(mid))l=mid; else r=mid; } cout\u0026lt;\u0026lt;int(r*1000)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } 元素排序 有 $N$ 个元素，编号 $1,2,\\dots,N$，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。元素的大小关系是 $N$ 个点与 $\\frac{N\\times(N-1)}{2}$ 条有向边构成的任意有向图。\n然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过 $10000$ 次提问来获取信息，每次提问只能了解某两个元素之间的关系。\n现在请你把这 $N$ 个元素排成一行，使得每个元素都小于右边与它相邻的元素。\n你可以通过我们预设的 bool 函数 compare 来获得两个元素之间的大小关系。\n例如，编号为 $a$ 和 $b$ 的两个元素，如果元素 $a$ 小于元素 $b$，则 compare(a,b) 返回 true，否则返回 false。\n将 $N$ 个元素排好序后，把它们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。\n数据范围 $1 \\leq N \\leq 1000$\n输入样例 1 [[0, 1, 0], [0, 0, 0], [1, 1, 0]] 输出样例 1 [3, 1, 2] code 1 2 3 4 5 6 7 8 9 10 11 12 13 //满足归并排序性质，先水过去吧 // Forward declaration of compare API. // bool compare(int a, int b); // return bool means whether a is less than b. class Solution { public: vector\u0026lt;int\u0026gt; specialSort(int N) { vector\u0026lt;int\u0026gt;a; for(int i=1;i\u0026lt;=N;++i)a.push_back(i); stable_sort(a.begin(),a.end(),compare); return a; } }; ","date":"2023-05-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue04/","title":"小蓝书0X04二分法"},{"content":"windows 对拍主程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;ctime\u0026gt; #include\u0026lt;windows.h\u0026gt; int main(){ int cnt=0; system(\u0026#34;g++ 1.cpp -o 1.exe\u0026#34;); system(\u0026#34;g++ 2.cpp -o 2.exe\u0026#34;); system(\u0026#34;g++ data.cpp -o data.exe\u0026#34;); while(1){ cnt++; system(\u0026#34;data.exe\u0026#34;); printf(\u0026#34;data create successfully\\n\u0026#34;); Sleep(1000); system(\u0026#34;1.exe\u0026#34;); system(\u0026#34;2.exe\u0026#34;); if(!system(\u0026#34;fc res.out ans.out\u0026#34;)){ printf(\u0026#34;AC test#%d\\n\u0026#34;,cnt); } else{ printf(\u0026#34;WA!\\n\u0026#34;); Sleep(2000); break; } } return 0; } 数据生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;ctime\u0026gt; using namespace std; typedef long long ll; ll random(ll mod) { ll n1, n2, n3, n4, ans; n1 = rand(); n2 = rand(); n3 = rand(); n4 = rand(); ans = n1 * n2 % mod; ans = ans * n3 % mod; ans = ans * n4 % mod; return ans; } int main(){ freopen(\u0026#34;data.in\u0026#34;,\u0026#34;w\u0026#34;,stdout); srand((unsigned)time(0)); ll i=random(10); cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return 0; } 程序对拍节点 1 2 3 4 5 6 //1.cpp freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //2.cpp freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); linux 把exe改成out,fc改成diff,Sleep改成sleep,windows.h改为unistd.h\n","date":"2023-05-23T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/duipai/","title":"对拍模板"},{"content":"","date":"2023-05-22T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/java-gui/","title":"Java Gui"},{"content":"vector 1 2 3 4 5 6 7 8 size() empy() clear() front() back() //取值 push_back() pop_back() begin() end() //迭代器 [index] 重载比较符号,字典序 string 1 2 3 4 size() empty() clear() substr(i,len) //开始下标,长度 queue 1 2 3 4 5 6 size() empty() push() front() back() pop() deque 1 2 3 4 5 6 7 8 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [index] priority_queue 1 2 3 4 5 6 7 priority_queue\u0026lt;type\u0026gt; ,默认是大根堆(在queue库) size() empty() push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 小根堆：priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt;; stack 1 2 3 4 5 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 pair 1 2 3 first second 比较,first为第一关键,second为第二关键词,字典序 set, map, multiset, multimap 1 2 3 4 size() empty() clear() begin()/end() set/multiset 1 2 3 4 5 6 7 8 9 insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap 1 2 3 4 5 insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unorderedXXXX 1 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 1 2 3 4 5 6 7 8 9 10 11 12 13 bitset\u0026lt;10000\u0026gt; s; ~, \u0026amp;, |, ^ \u0026gt;\u0026gt;, \u0026lt;\u0026lt; ==, != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 ","date":"2023-05-21T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/stl/","title":"C++ STL"},{"content":"写在前面 LC346传送门 第四题难,前三题难度较低\nT1 删除子串后的字符串最小长度 给你一个仅由 大写 英文字符组成的字符串 s 。 你可以对此字符串执行一些操作，在每一步操作中，你可以从 s 中删除 任一个 \u0026ldquo;AB\u0026rdquo; 或 \u0026ldquo;CD\u0026rdquo; 子字符串。 通过执行操作，删除所有 \u0026ldquo;AB\u0026rdquo; 和 \u0026ldquo;CD\u0026rdquo; 子串，返回可获得的最终字符串的 最小 可能长度。 注意，删除子串后，重新连接出的字符串可能会产生新的 \u0026ldquo;AB\u0026rdquo; 或 \u0026ldquo;CD\u0026rdquo; 子串\n示例 1： 输入：s = \u0026ldquo;ABFCACDB\u0026rdquo; 输出：2 解释：你可以执行下述操作：\n从 \u0026ldquo;ABFCACDB\u0026rdquo; 中删除子串 \u0026ldquo;AB\u0026rdquo;，得到 s = \u0026ldquo;FCACDB\u0026rdquo; 。 从 \u0026ldquo;FCACDB\u0026rdquo; 中删除子串 \u0026ldquo;CD\u0026rdquo;，得到 s = \u0026ldquo;FCAB\u0026rdquo; 。 从 \u0026ldquo;FCAB\u0026rdquo; 中删除子串 \u0026ldquo;AB\u0026rdquo;，得到 s = \u0026ldquo;FC\u0026rdquo; 。 最终字符串的长度为 2 。 可以证明 2 是可获得的最小长度。 示例 2： 输入：s = \u0026ldquo;ACBBD\u0026rdquo; 输出：5 解释：无法执行操作，字符串长度不变。\n思路 模拟/栈(类似括号删除)\n比赛代码(模拟) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution: def minLength(self, s: str) -\u0026gt; int: p1=0 p2=1 if len(s)==1: return 1 a=[] for i in s: a.append(i) while p2\u0026lt;len(a): if a[p1]==\u0026#34;A\u0026#34; and a[p2]==\u0026#34;B\u0026#34;: del a[p1] del a[p2-1] if p1!=0 and p2!=1: p1-=1 p2-=1 elif a[p1]==\u0026#34;C\u0026#34; and a[p2]==\u0026#34;D\u0026#34;: del a[p1] del a[p2-1] if p1!=0 and p2!=1: p1-=1 p2-=1 else: p1+=1 p2+=1 return len(a) 语法糖模拟 1 2 3 4 5 6 class Solution: def minLength(self, s: str) -\u0026gt; int: while \u0026#34;AB\u0026#34; in s or \u0026#34;CD\u0026#34; in s: s = s.replace(\u0026#34;AB\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;CD\u0026#34;, \u0026#34;\u0026#34;) return len(s) # 作者：endlesscheng 栈 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int minLength(string s) { stack\u0026lt;char\u0026gt; ss; for(auto i:s){ if(!ss.empty()\u0026amp;\u0026amp;((ss.top()==\u0026#39;A\u0026#39;\u0026amp;\u0026amp;i==\u0026#39;B\u0026#39;)||(ss.top()==\u0026#39;C\u0026#39;\u0026amp;\u0026amp;i==\u0026#39;D\u0026#39;)))ss.pop(); else ss.push(i); } return ss.size(); } }; T2 字典序最小回文串 给你一个由 小写英文字母 组成的字符串 s ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母 替换 s 中的一个字符。\n请你执行 尽可能少的操作 ，使 s 变成一个 回文串 。如果执行 最少 操作次数的方案不止一种，则只需选取 字典序最小 的方案。\n对于两个长度相同的字符串 a 和 b ，在 a 和 b 出现不同的第一个位置，如果该位置上 a 中对应字母比 b 中对应字母在字母表中出现顺序更早，则认为 a 的字典序比 b 的字典序要小。\n返回最终的回文字符串。\n示例 1：\n输入：s = \u0026ldquo;egcfe\u0026rdquo; 输出：\u0026ldquo;efcfe\u0026rdquo; 解释：将 \u0026ldquo;egcfe\u0026rdquo; 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 \u0026ldquo;efcfe\u0026rdquo;，只需将 \u0026lsquo;g\u0026rsquo; 改为 \u0026lsquo;f\u0026rsquo; 。 示例 2：\n输入：s = \u0026ldquo;abcd\u0026rdquo; 输出：\u0026ldquo;abba\u0026rdquo; 解释：将 \u0026ldquo;abcd\u0026rdquo; 变成回文字符串的最小操作次数为 2 ，修改 2 次得到的字典序最小回文字符串是 \u0026ldquo;abba\u0026rdquo; 。 示例 3：\n输入：s = \u0026ldquo;seven\u0026rdquo; 输出：\u0026ldquo;neven\u0026rdquo; 解释：将 \u0026ldquo;seven\u0026rdquo; 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 \u0026ldquo;neven\u0026rdquo; 。\n提示：\n1 \u0026lt;= s.length \u0026lt;= 1000 s 仅由小写英文字母组成\n思路 双指针\n赛时代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: string makeSmallestPalindrome(string s) { int st=0; int ed=s.size()-1; while(st\u0026lt;ed){ if(s[st]!=s[ed]){ if(s[st]-\u0026#39;a\u0026#39;\u0026gt;s[ed]-\u0026#39;a\u0026#39;){ s[st]=s[ed]; } else{ s[ed]=s[st]; } } st++; ed--; } return s; } }; T3 求一个整数的惩罚数 给你一个正整数 n ，请你返回 n 的 惩罚数 。\nn 的 惩罚数 定义为所有满足以下条件 i 的数的平方和：\n1 \u0026lt;= i \u0026lt;= n i * i 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 i 。\n示例 1：\n输入：n = 10 输出：182 解释：总共有 3 个整数 i 满足要求：\n1 ，因为 1 * 1 = 1 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。 因此，10 的惩罚数为 1 + 81 + 100 = 182\n示例 2： 输入：n = 37 输出：1478 解释：总共有 4 个整数 i 满足要求：\n1 ，因为 1 * 1 = 1 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。 36 ，因为 36 * 36 = 1296 ，且 1296 可以分割成 1 + 29 + 6 。 因此，37 的惩罚数为 1 + 81 + 100 + 1296 = 1478 提示：\n1 \u0026lt;= n \u0026lt;= 1000\n思路 比赛时看到n最大才1000,可以直接预处理 打表用的dfs, 为了节约时间没把dfs改成动态规划\n赛时代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 打表代码 # a=[] # s=\u0026#34;\u0026#34; # def check(i,v,p): # if i\u0026gt;=len(s): # if p==v: # return 1 # return 0 # x=0 # for d in range(i,len(s)): # x=x|check(d+1,v,p+int(s[i:d+1])) # return x # for i in range(1,1001): # s=str(i*i) # if check(0,i,0): # a.append(i) # print(a) class Solution: def punishmentNumber(self, n: int) -\u0026gt; int: s={1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000} cnt=0 for i in range(1,n+1): if i in s: cnt+=i*i return cnt 记忆化搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution: def punishmentNumber(self, n: int) -\u0026gt; int: @cache def check(i,v,p,s): if i\u0026gt;=len(s): if p==v: return 1 return 0 x=0 for d in range(i,len(s)): x=x|check(d+1,v,p+int(s[i:d+1]),s) return x cnt=0 for i in range(1,n+1): s=str(i*i) if check(0,i,0,s): cnt+=i*i return cnt T4修改图中的边权 给你一个 n 个节点的 无向带权连通 图，节点编号为 0 到 n - 1 ，再给你一个整数数组 edges ，其中 edges[i] = [ai, bi, wi] 表示节点 ai 和 bi 之间有一条边权为 wi 的边。\n部分边的边权为 -1（wi = -1），其他边的边权都为 正 数（wi \u0026gt; 0）。\n你需要将所有边权为 -1 的边都修改为范围 [1, 2 * 109] 中的 正整数 ，使得从节点 source 到节点 destination 的 最短距离 为整数 target 。如果有 多种 修改方案可以使 source 和 destination 之间的最短距离等于 target ，你可以返回任意一种方案。\n如果存在使 source 到 destination 最短距离为 target 的方案，请你按任意顺序返回包含所有边的数组（包括未修改边权的边）。如果不存在这样的方案，请你返回一个 空数组 。\n注意：你不能修改一开始边权为正数的边。\n示例 1：\n输入：n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5 输出：[[4,1,1],[2,0,1],[0,3,3],[4,3,1]] 解释：上图展示了一个满足题意的修改方案，从 0 到 1 的最短距离为 5 。 示例 2：\n输入：n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6 输出：[] 解释：上图是一开始的图。没有办法通过修改边权为 -1 的边，使得 0 到 2 的最短距离等于 6 ，所以返回一个空数组。 示例 3：\n输入：n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6 输出：[[1,0,4],[1,2,3],[2,3,5],[0,3,1]] 解释：上图展示了一个满足题意的修改方案，从 0 到 2 的最短距离为 6 。\n提示：\n1 2 3 4 5 6 7 8 9 10 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= edges.length \u0026lt;= n * (n - 1) / 2 edges[i].length == 3 0 \u0026lt;= ai, bi \u0026lt; n wi = -1 或者 1 \u0026lt;= wi \u0026lt;= 107 ai != bi 0 \u0026lt;= source, destination \u0026lt; n source != destination 1 \u0026lt;= target \u0026lt;= 109 输入的图是连通图，且没有自环和重边。 请见 ","date":"2023-05-21T00:00:00Z","image":"https://pic.lingkou.xyz/1684119642-NLFpUC-1760-360%20%E9%A1%BA%E4%B8%B0%E7%A7%91%E6%8A%80.png","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-346/","title":"lc weekly contest 346"},{"content":"c++ 精简模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; // #define int long long #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define For(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define _For(a,b,c) for(int a=(b);a\u0026gt;(c);a--) #define all(x) (x).begin(),x.end() #define inf 0x3f3f3f3f #define endl \u0026#39;\\n\u0026#39; //对拍 #define fo1 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define fo2 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //输出数组 #define printA(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; int read(); void write(int); const int N=5e5+5; const int MOD=1e9+7; void hhhh(){ } signed main() { // hhhh(); int T=read(); while(T--){ hhhh(); } return 0; } inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } inline void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;); x = -x; } if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } 其它模板(来源网络) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #define _USE_MATH_DEFINES // C #include \u0026lt;cassert\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;ctime\u0026gt; //io #include \u0026lt;iostream\u0026gt; //基本输入输出流 #include \u0026lt;iomanip\u0026gt; #include \u0026lt;sstream\u0026gt; //基于字符串的流 //标准异常类 #include \u0026lt;stdexcept\u0026gt; //algorithm #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;functional\u0026gt; //定义运算函数（代替运算符） #include \u0026lt;complex\u0026gt; //复数类 #include \u0026lt;random\u0026gt; //STL #include \u0026lt;string\u0026gt; //字符串类 #include \u0026lt;list\u0026gt; //线性列表容器 #include \u0026lt;vector\u0026gt; //动态数组容器 #include \u0026lt;stack\u0026gt; //堆栈容器 #include \u0026lt;queue\u0026gt; //队列容器 #include \u0026lt;deque\u0026gt; //双端队列容器 #include \u0026lt;bitset\u0026gt; //比特集合 #include \u0026lt;set\u0026gt; //集合容器 #include \u0026lt;map\u0026gt; //映射容器 #include \u0026lt;unordered_set\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; //fast ios #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define ALL(a) (a).begin(),(a).end() #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define RFOR(w, a, n) for(int w=(n)-1;w\u0026gt;=(a);--w) #define REP(w, n) for(int w=0;w\u0026lt;int(n);++w) #define RREP(w, n) for(int w=int(n)-1;w\u0026gt;=0;--w) #define IN(a, x, b) (a\u0026lt;=x \u0026amp;\u0026amp; x\u0026lt;b) #define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) template \u0026lt;typename Arg1\u0026gt; void __f(const char* name, Arg1\u0026amp;\u0026amp; arg1){ cerr \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; endl; } template \u0026lt;typename Arg1, typename... Args\u0026gt; void __f(const char* names, Arg1\u0026amp;\u0026amp; arg1, Args\u0026amp;\u0026amp;... args){ const char* comma = strchr(names + 1, \u0026#39;,\u0026#39;); cerr.write(names, comma - names) \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; \u0026#34; |\u0026#34;; __f(comma + 1, args...); } typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const double PI = acos(-1.0); const double eps = 1e-6; const int INF = 1 \u0026lt;\u0026lt; 29; const int MOD = 1e9 + 7; const int MAXN = 100; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, ACM.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys import heapq import random from math import ceil,floor,fmod,gcd,sqrt,inf from bisect import bisect_left from collections import defaultdict,Counter,deque,OrderedDict from functools import lru_cache,cmp_to_key #sys.setrecursionlimit(1000000) # 输入1 def ii(): return int(sys.stdin.readline().strip()) # 输入2 def iin(): return map(int,sys.stdin.readline().split()) def inn(): return sys.stdin.readline().strip() java go ","date":"2023-05-08T00:03:00Z","image":"https://open17.github.io/CpHugo/p/template/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://open17.github.io/CpHugo/p/template/","title":"算法输入输出模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 vector\u0026lt;int\u0026gt; get_prefix_table(string pattern) { int n = pattern.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = pi[j-1]; } if (pattern[i] == pattern[j]) { j++; } pi[i] = j; } return pi; } vector\u0026lt;int\u0026gt; kmp(string text, string pattern) { vector\u0026lt;int\u0026gt; pi = get_prefix_table(pattern); vector\u0026lt;int\u0026gt; matches; for (int i = 0, j = 0; i \u0026lt; text.length(); i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; text[i] != pattern[j]) { j = pi[j-1]; } if (text[i] == pattern[j]) { j++; } if (j == pattern.length()) { matches.push_back(i - j + 1); j = pi[j-1]; } } return matches; } 【模板】KMP字符串匹配 题目描述 给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。\n现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。\n定义一个字符串 $s$ 的 border 为 $s$ 的一个非 $s$ 本身的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。\n对于 $s_2$，你还需要求出对于其每个前缀 $s\u0026rsquo;$ 的最长 border $t\u0026rsquo;$ 的长度。\n输入格式 第一行为一个字符串，即为 $s_1$。\n第二行为一个字符串，即为 $s_2$。\n输出格式 首先输出若干行，每行一个整数，按从小到大的顺序输出 $s_2$ 在 $s_1$ 中出现的位置。\n最后一行输出 $|s_2|$ 个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。\n样例 #1 样例输入 #1 1 2 ABABABC ABA 样例输出 #1 1 2 3 1 3 0 0 1 提示 样例 1 解释 。\n对于 $s_2$ 长度为 $3$ 的前缀 ABA，字符串 A 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。\n数据规模与约定 本题采用多测试点捆绑测试，共有 3 个子任务。\nSubtask 1（30 points）：$|s_1| \\leq 15$，$|s_2| \\leq 5$。 Subtask 2（40 points）：$|s_1| \\leq 10^4$，$|s_2| \\leq 10^2$。 Subtask 3（30 points）：无特殊约定。 对于全部的测试点，保证 $1 \\leq |s_1|,|s_2| \\leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; get_prefix_table(string pattern) { int n = pattern.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = pi[j-1]; } if (pattern[i] == pattern[j]) { j++; } pi[i] = j; } return pi; } vector\u0026lt;int\u0026gt; kmp(string text, string pattern) { vector\u0026lt;int\u0026gt; pi = get_prefix_table(pattern); vector\u0026lt;int\u0026gt; matches; for (int i = 0, j = 0; i \u0026lt; text.length(); i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; text[i] != pattern[j]) { j = pi[j-1]; } if (text[i] == pattern[j]) { j++; } if (j == pattern.length()) { matches.push_back(i - j + 1); j = pi[j-1]; } } return matches; } int main() { string s1, s2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; // 使用 KMP 算法查找所有出现位置 vector\u0026lt;int\u0026gt; matches = kmp(s1, s2); // 输出出现位置 for (int i = 0; i \u0026lt; matches.size(); i++) { cout \u0026lt;\u0026lt; matches[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // 计算 s2 的前缀的最长 border 长度 vector\u0026lt;int\u0026gt; pi = get_prefix_table(s2); for (int i = 0; i \u0026lt; s2.length(); i++) { cout \u0026lt;\u0026lt; pi[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/kmp/","title":"KMP模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const int MAXN = 1e5 + 5; // 最大数组长度 const int MAXK = 25; // log2(MAXN) 向上取整 int a[MAXN]; // 输入数组 int st[MAXN][MAXK + 1]; // ST表 int Log2[MAXN]; void build(int n) { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; // 初始化第一列 } for (int j = 1; j \u0026lt;= MAXK; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = min(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); // 更新ST表 } } for (int i = 2; i \u0026lt;= n; ++i) Log2[i] = Log2[i / 2] + 1; } int query(int l, int r) { int k = Log2[r - l + 1]; // 计算区间长度的对数，向下取整 return min(st[l][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); // 返回区间最小值 } 【模板】ST 表 题目背景 这是一道 ST 表经典题——静态区间最大值\n请注意最大数据时限只有 0.8s，数据强度不低，请务必保证你的每次查询复杂度为 $O(1)$。若使用更高时间复杂度算法不保证能通过。\n如果您认为您的代码时间复杂度正确但是 TLE，可以尝试使用快速读入：\n1 2 3 4 5 6 7 inline int read() { int x=0,f=1;char ch=getchar(); while (ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if (ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while (ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-48;ch=getchar();} return x*f; } 函数返回值为读入的第一个整数。\n快速读入作用仅为加快读入，并非强制使用。\n题目描述 给定一个长度为 $N$ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。\n输入格式 第一行包含两个整数 $N,M$，分别表示数列的长度和询问的个数。\n第二行包含 $N$ 个整数（记为 $a_i$），依次表示数列的第 $i$ 项。\n接下来 $M$ 行，每行包含两个整数 $l_i,r_i$，表示查询的区间为 $[l_i,r_i]$。\n输出格式 输出包含 $M$ 行，每行一个整数，依次表示每一次询问的结果。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 8 9 10 8 8 9 3 1 7 5 6 0 8 1 6 1 5 2 7 2 6 1 8 4 8 3 7 1 8 样例输出 #1 1 2 3 4 5 6 7 8 9 9 7 7 9 8 7 9 提示 对于 $30%$ 的数据，满足 $1\\le N,M\\le 10$。\n对于 $70%$ 的数据，满足 $1\\le N,M\\le {10}^5$。\n对于 $100%$ 的数据，满足 $1\\le N\\le {10}^5$，$1\\le M\\le 2\\times{10}^6$，$a_i\\in[0,{10}^9]$，$1\\le l_i\\le r_i\\le N$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAXN = 1e5 + 5; // 最大数组长度 const int MAXK = 25; // log2(MAXN) 向上取整 int a[MAXN]; // 输入数组 int st[MAXN][MAXK + 1]; // ST表 int Log2[MAXN]; void build(int n) { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; // 初始化第一列 } for (int j = 1; j \u0026lt;= MAXK; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = max(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); // 更新ST表 } } for (int i = 2; i \u0026lt;= n; ++i) Log2[i] = Log2[i / 2] + 1; } int query(int l, int r) { int k = Log2[r - l + 1]; // 计算区间长度的对数，向下取整 return max(st[l][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); // 返回区间最小值 } inline int read() { int x=0,f=1;char ch=getchar(); while (ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if (ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while (ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-48;ch=getchar();} return x*f; } int main() { int n,m; n=read(); m=read(); for(int i=1;i\u0026lt;=n;i++){ a[i]=read(); } build(n); while(m--){ int l=read(),r=read(); printf(\u0026#34;%d\\n\u0026#34;,query(l,r)); } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/st/","title":"ST表模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 深度优先搜索，用于求每个节点的深度和祖先信息 void dfs(int u, int fa) { depth[u] = depth[fa] + 1; // 当前节点的深度为父节点的深度加一 p[u][0] = fa; // 当前节点的 2^0 级祖先为父节点 // 递推求出当前节点的 2^i 级祖先 for (int i = 1; i \u0026lt; M; i ++ ) p[u][i] = p[p[u][i - 1]][i - 1]; // 遍历当前节点的每一个儿子，递归调用 dfs 函数 for (auto v : g[u]) if (v != fa) // 避免向父节点递归 dfs(v, u); } // 求两个节点的最近公共祖先 int lca(int a, int b) { if (depth[a] \u0026lt; depth[b]) swap(a, b); // 保证 a 深度不小于 b // 先将 a 跳到和 b 同一深度 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (depth[p[a][i]] \u0026gt;= depth[b]) a = p[a][i]; if (a == b) return a; // 特判 a 和 b 在同一条链上的情况 // 一起向上跳，直到 a 和 b 的第一个不同的祖先 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (p[a][i] != p[b][i]) { a = p[a][i]; b = p[b][i]; } return p[a][0]; // 返回 a 的父节点，即为 LCA } 【模板】最近公共祖先（LCA） 题目描述 如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。\n输入格式 第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。\n接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。\n接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。\n输出格式 输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 8 9 10 5 5 4 3 1 2 4 5 1 1 4 2 4 3 2 3 5 1 2 4 5 样例输出 #1 1 2 3 4 5 4 4 1 4 4 提示 对于 $30%$ 的数据，$N\\leq 10$，$M\\leq 10$。\n对于 $70%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。\n对于 $100%$ 的数据，$1 \\leq N,M\\leq 500000$，$1 \\leq x, y,a ,b \\leq N$，不保证 $a \\neq b$。\n样例说明：\n该树结构如下：\n第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。\n第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。\n第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。\n第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。\n第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。\n故输出依次为 $4, 4, 1, 4, 4$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N = 500010, M = 20; int n, m, s; // n：节点数，m：查询次数，s：根节点编号 int depth[N], p[N][M]; // depth：每个节点的深度，p：每个节点的 2^i 级祖先 vector\u0026lt;int\u0026gt; g[N]; // g：树的邻接表表示 // 深度优先搜索，用于求每个节点的深度和祖先信息 void dfs(int u, int fa) { depth[u] = depth[fa] + 1; // 当前节点的深度为父节点的深度加一 p[u][0] = fa; // 当前节点的 2^0 级祖先为父节点 // 递推求出当前节点的 2^i 级祖先 for (int i = 1; i \u0026lt; M; i ++ ) p[u][i] = p[p[u][i - 1]][i - 1]; // 遍历当前节点的每一个儿子，递归调用 dfs 函数 for (auto v : g[u]) if (v != fa) // 避免向父节点递归 dfs(v, u); } // 求两个节点的最近公共祖先 int lca(int a, int b) { if (depth[a] \u0026lt; depth[b]) swap(a, b); // 保证 a 深度不小于 b // 先将 a 跳到和 b 同一深度 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (depth[p[a][i]] \u0026gt;= depth[b]) a = p[a][i]; if (a == b) return a; // 特判 a 和 b 在同一条链上的情况 // 一起向上跳，直到 a 和 b 的第一个不同的祖先 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (p[a][i] != p[b][i]) { a = p[a][i]; b = p[b][i]; } return p[a][0]; // 返回 a 的父节点，即为 LCA } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; // 读入节点数、查询次数和根节点编号 // 逐个读入每条边，构建树的邻接表表示 for (int i = 1; i \u0026lt; n; i ++ ) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].push_back(b); g[b].push_back(a); } dfs(s, 0); // 求每个节点的深度和祖先信息 while (m -- ) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // 读入查询 cout \u0026lt;\u0026lt; lca(a, b) \u0026lt;\u0026lt; endl; // 输出 } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/lca/","title":"倍增LCA模板"},{"content":"模板 只适用于模数为质数的情况(费马小定理) 1 2 3 4 5 6 7 vector\u0026lt;long long\u0026gt; inv_vec(long long n, long long m) { vector\u0026lt;long long\u0026gt; inv(n + 1, 1); for (long long i = 2; i \u0026lt;= n; i++) { inv[i] = (m - m / i) * inv[m % i] % m; } return inv; } 【模板】乘法逆元 题目背景 这是一道模板题\n题目描述 给定 $n,p$ 求 $1\\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。\n这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\\equiv1\\pmod p$ 的解。\n输入格式 一行两个正整数 $n,p$。\n输出格式 输出 $n$ 行，第 $i$ 行表示 $i$ 在模 $p$ 下的乘法逆元。\n样例 #1 样例输入 #1 1 10 13 样例输出 #1 1 2 3 4 5 6 7 8 9 10 1 7 9 10 8 11 2 5 3 4 提示 $ 1 \\leq n \\leq 3 \\times 10 ^ 6, n \u0026lt; p \u0026lt; 20000528 $\n输入保证 $ p $ 为质数。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;iostream\u0026gt; using namespace std; const int N=3e6+2; long long inv[N]; void inv_vec(long long n, long long m) { inv[0]=1; inv[1]=1; for (long long i = 2; i \u0026lt;= n; i++) { inv[i] = (m - m / i) * inv[m % i] % m; printf(\u0026#34;%lld\\n\u0026#34;,inv[i]); } } int main(){ int n,p; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;p); printf(\u0026#34;1\\n\u0026#34;); inv_vec(n,p); return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/inv2/","title":"乘法逆元递推模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 long long extgcd(long long a, long long b, long long \u0026amp;x, long long \u0026amp;y) { if (b == 0) { x = 1; y = 0; return a; } long long d = extgcd(b, a % b, y, x); y -= a / b * x; return d; } long long inv(long long a, long long m) { long long x, y; if (extgcd(a, m, x, y) != 1) { return -1; // 不存在乘法逆元 } return (x % m + m) % m; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/inv1/","title":"乘法逆元模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 FOR(p,0,n){ while(!maxs.empty()\u0026amp;\u0026amp;maxs.back()\u0026lt;a[p])maxs.pop_back(); while(!mins.empty()\u0026amp;\u0026amp;mins.back()\u0026gt;a[p])mins.pop_back(); maxs.push_back(a[p]); mins.push_back(a[p]); ans1[p]=maxs.front(); ans2[p]=mins.front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;maxs.front()==a[p-k+1])maxs.pop_front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;mins.front()==a[p-k+1])mins.pop_front(); } 滑动窗口 /【模板】单调队列 题目描述 有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。\n例如：\nThe array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$。\n输入格式 输入一共有两行，第一行有两个正整数 $n,k$。 第二行 $n$ 个整数，表示序列 $a$\n输出格式 输出共两行，第一行为每次窗口滑动的最小值\n第二行为每次窗口滑动的最大值\n样例 #1 样例输入 #1 1 2 8 3 1 3 -1 -3 5 3 6 7 样例输出 #1 1 2 -1 -3 -3 -3 3 3 3 3 5 5 6 7 提示 【数据范围】 对于 $50%$ 的数据，$1 \\le n \\le 10^5$；\n对于 $100%$ 的数据，$1\\le k \\le n \\le 10^6$，$a_i \\in [-2^{31},2^{31})$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int a[N],ans1[N],ans2[N]; deque\u0026lt;int\u0026gt; maxs,mins; int main() { ios int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; FOR(i,0,n){ cin\u0026gt;\u0026gt;a[i]; } FOR(p,0,n){ while(!maxs.empty()\u0026amp;\u0026amp;maxs.back()\u0026lt;a[p])maxs.pop_back(); while(!mins.empty()\u0026amp;\u0026amp;mins.back()\u0026gt;a[p])mins.pop_back(); maxs.push_back(a[p]); mins.push_back(a[p]); ans1[p]=maxs.front(); ans2[p]=mins.front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;maxs.front()==a[p-k+1])maxs.pop_front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;mins.front()==a[p-k+1])mins.pop_front(); } FOR(i,k-1,n){ cout\u0026lt;\u0026lt;ans2[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; FOR(i,k-1,n){ cout\u0026lt;\u0026lt;ans1[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/monotonicqueue/","title":"单调队列模板"},{"content":"模板1 这种思路通常用于寻找右边的数（求左边时倒叙即可） 每次stack弹出时才记录答案，因此需要维护一个数组或者哈希表 确定单调性与目标相反即可，若求右最小，单调增（方向指的是自底向顶，后面同），最大反之即可 这里以求右边NGE为代表 1 2 3 4 5 6 7 8 9 10 11 12 const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; FOR(i,1,n+1){ while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;a[i]){ b[s.top()]=i; s.pop(); } s.push(i); } } 模板2 这种思路通常用于寻找左边的数 寻找右边时，应反转列表（实际上倒叙即可）来看 这种写法每次维护后的栈顶即使答案 这里以求右边NGE为代表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; for(int i=n;i\u0026gt;0;i--){ //这里的等号要注意，不然如 5，5 的话返回的是 2，0（下标从1开始） while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;=a[i]){ s.pop(); } if(!s.empty()){ b[i]=s.top(); } s.push(i); } } 【模板】单调栈 题目背景 模板题，无背景。\n2019.12.12 更新数据，放宽时限，现在不再卡常了。\n题目描述 给出项数为 $n$ 的整数数列 $a_{1 \\dots n}$。\n定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的下标，即 $f(i)=\\min_{i\u0026lt;j\\leq n, a_j \u0026gt; a_i} {j}$。若不存在，则 $f(i)=0$。\n试求出 $f(1\\dots n)$。\n输入格式 第一行一个正整数 $n$。\n第二行 $n$ 个正整数 $a_{1\\dots n}$。\n输出格式 一行 $n$ 个整数 $f(1\\dots n)$ 的值。\n样例 #1 样例输入 #1 1 2 5 1 4 2 3 5 样例输出 #1 1 2 5 4 5 0 提示 【数据规模与约定】\n对于 $30%$ 的数据，$n\\leq 100$；\n对于 $60%$ 的数据，$n\\leq 5 \\times 10^3$ ；\n对于 $100%$ 的数据，$1 \\le n\\leq 3\\times 10^6$，$1\\leq a_i\\leq 10^9$。\nCODE1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; FOR(i,1,n+1){ while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;a[i]){ b[s.top()]=i; s.pop(); } s.push(i); } } int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,1,n+1)cin\u0026gt;\u0026gt;a[i]; NGE(n); FOR(i,1,n+1)cout\u0026lt;\u0026lt;b[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } CODE2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; for(int i=n;i\u0026gt;0;i--){ while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;=a[i]){ s.pop(); } if(!s.empty()){ b[i]=s.top(); } s.push(i); } } int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,1,n+1)cin\u0026gt;\u0026gt;a[i]; NGE(n); FOR(i,1,n+1)cout\u0026lt;\u0026lt;b[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/monotonicstack/","title":"单调栈模板"},{"content":"Basic Counting Principles The product rule 乘法原理\nExercise •Prove Theorem: $ if |S| = n, then |P(S)| = 2^n$\nThe sum rule 加法原理\nThe Inclusion-Exclusion Principle 容斥原理\nThe Pigeonhole Principle 抽屉原理\nTheorem 1: If k is a positive integer and k + 1 or more objects are placed into k boxes, then there is at least one box containing two or more of the objects.\nTheorem 2: If n objects are placed into k boxes, then there is at least one box containing at least n/k objects.\nPermutation 排列（考虑顺序） $P(n, r) = n!/(n − r)!$\nCombination 组合（不考虑顺序） $C(n, r), or (^n_r)$\n隔板法 How many solutions does the equation a + b + c = 11 have where a, b, and c are non-negative integers?\nBinomial Coefficients 二项式定理： Recurrence Relations Linear Homogeneous recurrence relation Theorem 1: Let $c_1$ and $c_2$ be real numbers. Suppose that $r^2 – c_1 – c_2 = 0$ has two distinct roots $r_1$ and $r_2$. Then the sequence ${a_n}$ is a solution of the recurrence relation $a_n= c_1a_{n-1} + c_2a_{n-2}$ if and only if $a_n= k_1r_1^n+k_2r_2^n$ for $n = 0, 1, 2, …,$ where $k_1$ and $k_2$ are constants.\n","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/counting/","title":"离散数学————Counting"},{"content":"欧拉筛 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const int N=100; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 【模板】线性筛素数 题目背景 本题已更新，从判断素数改为了查询第 $k$ 小的素数\n提示：如果你使用 cin 来读入，建议使用 std::ios::sync_with_stdio(0) 来加速。\n题目描述 如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。\n输入格式 第一行包含两个正整数 $n,q$，分别表示查询的范围和查询的个数。\n接下来 $q$ 行每行一个正整数 $k$，表示查询第 $k$ 小的素数。\n输出格式 输出 $q$ 行，每行一个正整数表示答案。\n样例 #1 样例输入 #1 1 2 3 4 5 6 100 5 1 2 3 4 5 样例输出 #1 1 2 3 4 5 2 3 5 7 11 提示 【数据范围】\n对于 $100%$ 的数据，$n = 10^8$，$1 \\le q \\le 10^6$，保证查询的素数不大于 $n$。\nData by NaCly_Fish.\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e8; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int main() { ios int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; get_primes(n); while(q--){ int x; cin\u0026gt;\u0026gt;x; cout\u0026lt;\u0026lt;primes[x-1]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/eulersieve/","title":"欧拉筛模板"},{"content":"按序合并路径压缩优化并查集 封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Buf { public: Buf(int sz) : root(sz), rank(sz) { for (int i = 0; i \u0026lt; sz; i++) { root[i] = i; rank[i] = 1; } } int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] \u0026lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(int x, int y) { return find(x) == find(y); } private: vector\u0026lt;int\u0026gt; root; vector\u0026lt;int\u0026gt; rank; }; 非封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ll root[MAXN],rank[MAXN],n; void initbuf(ll n){ for (ll i = 0; i \u0026lt; n; i++) { root[i] = i; } } ll find(ll x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(ll x, ll y) { ll rootX = find(x); ll rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) root[rootY] = rootX; else if (rank[rootX] \u0026lt; rank[rootY])root[rootX] = rootY; else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(ll x, ll y) { return find(x) == find(y); } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/buf/","title":"并查集模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 ll qpow(ll a,ll b,ll p){ ll ans=1%p; while(b){ if(b\u0026amp;1)ans=(ans*a)%p; b\u0026gt;\u0026gt;=1; a=(a*a)%p; } return ans; } 题目描述 给你三个整数 $a,b,p$，求 $a^b \\bmod p$。\n输入格式 输入只有一行三个整数，分别代表 $a,b,p$。\n输出格式 输出一行一个字符串 a^b mod p=s，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。\n样例 #1 样例输入 #1 1 2 10 9 样例输出 #1 1 2^10 mod 9=7 提示 样例解释\n$2^{10} = 1024$，$1024 \\bmod 9 = 7$。\n数据规模与约定\n对于 $100%$ 的数据，保证 $0\\le a,b \u0026lt; 2^{31}$，$a+b\u0026gt;0$，$2 \\leq p \\lt 2^{31}$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; ll qpow(ll a,ll b,ll p){ ll ans=1%p; while(b){ if(b\u0026amp;1)ans=(ans*a)%p; b\u0026gt;\u0026gt;=1; a=(a*a)%p; } return ans; } int main() { ios ll a,b,p; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; ll res=qpow(a,b,p); cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;^\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; mod \u0026#34;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#34;=\u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/qpowp/","title":"快速幂取余模板"},{"content":" A relation is a structure that is used to represent the relationships between elements\nCategory of relations Binary relations N-ary relations Binary Relations A binary relation R from the set 𝐴 to the set 𝐵 is a subset of 𝐴 × 𝐵.\nR is a set of ordered pairs in the form (𝑎, 𝑏) where 𝑎 is from 𝐴 and 𝑏 is from 𝐵.\na R b denotes (𝑎, 𝑏) ∈ 𝑅, called 𝑎 is related to 𝑏 by R\nFunctions and Relations Are all the functions relations? Yes Are all relations functions? No Relation on the Set A relation on the set is a relation from 𝐴 to 𝐴. Properties of Relations Reflexive A relation 𝑅 on a set 𝐴 is called reflexive if (𝑎, 𝑎) ∈ 𝑅 for every element 𝑎 ∈ A\nSymmetric A relation 𝑅 on a set 𝐴 is called symmetric if (𝑏, 𝑎) ∈ 𝑅 whenever (𝑎, 𝑏) ∈ R\nAnti-symmetric relation 𝑅 on a set 𝐴 is called anti-symmetric if whenever (𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑎) ∈ 𝑅, then 𝑎 = 𝑏\nTransitive A relation 𝑅 on a set 𝐴 is called transitive if whenever (𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑐) ∈ 𝑅, then (𝑎, 𝑐) ∈ 𝑅\nCombining Relations The composite of 𝑅 and 𝑆 (𝑆 ◦ 𝑅): consisting of all ordered pairs (𝑎, 𝑐) where 𝑎 ∈ 𝐴, and 𝑐 ∈ 𝐶 if there exists 𝑏 such that (𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑐) ∈ 𝑆.\nE.g.,\n▪ 𝐴 = {1}, 𝐵 = {0, 1}, 𝐶 = {2, 3}\n▪ 𝑅 = {(1, 0), (1, 1)} (a relation from 𝐴 to 𝐵)\n▪ 𝑆 = {(0, 2), (1, 3)} (a relation from 𝐵 to 𝐶)\n▪ 𝑆 ◦ 𝑅 = {(1, 2), (1, 3)}\nPowers of a Relation Let 𝑅 be a relation on the set 𝐴. The powers 𝑅𝑛 for integer 𝑛 with 𝑛 \u0026gt; 0 are defined recursively by $R^1 = R$\n$R^{n}=R^{n-1}◦R$\nTheorem: The relation 𝑅 on a set 𝐴 is transitive if and only if 𝑅^𝑛 ⊆ 𝑅 for 𝑛 = 1, 2, 3, ⋯\n𝑛-ary Relations Let 𝐴1, 𝐴2, … , 𝐴𝑛 be sets. An 𝑛-ary relation on these sets is a subset of 𝐴1 × 𝐴2 × ⋯ × 𝐴𝑛 Domain: 𝐴1 × 𝐴2 × ⋯ × 𝐴𝑛 Degree: n Relations and Database Currently, the most commonly used databases are relational databases. Each database consists of multiple relations. Each relation is presented as a table. Operations on n-ary Relations Selection operator 𝜎: 𝑛-ary relation 𝑅 condition 𝑐 Selection operator 𝜎𝑐: maps 𝑅 to an 𝑛-ary relations 𝑇, where all the tuples in 𝑇 satisfy the condition 𝑐.\ni.e. 𝜎_{𝑚𝑎𝑗𝑜𝑟}=\u0026ldquo;𝐶𝑜𝑚𝑝𝑢𝑡𝑒𝑟 𝑆𝑐𝑖𝑒𝑛𝑐𝑒\u0026rdquo; 𝐺𝑟𝑎𝑑𝑒𝑅𝑒𝑝𝑜𝑟𝑡 = {(𝐽𝑜ℎ𝑛,001,𝐶𝑜𝑚𝑝𝑢𝑡𝑒𝑟 𝑆𝑐𝑖𝑒𝑛𝑐𝑒, 3.5)} Projection operator 𝜋: the input relation is on 𝑛 tuples (𝑎1, 𝑎2, ⋯ , 𝑎𝑛) , the output relation is on 𝑚 tuples (𝑎𝑖_1,𝑎𝑖_2, ⋯ , 𝑎𝑖_𝑚), 𝑚 \u0026lt; 𝑛. Projection operator 𝜋𝑖1,𝑖2,⋯,𝑖𝑚: removes the tuples not in the 𝑚-tuple (𝑎𝑖1𝑎𝑖2, ⋯ , 𝑎𝑖𝑚) list i.e. 𝜋_{𝑛𝑎𝑚𝑒,𝐺𝑃𝐴} (𝐺𝑟𝑎𝑑𝑒𝑅𝑒𝑝𝑜𝑟𝑡) = {(𝐽𝑜ℎ𝑛, 3.5 ),( 𝑇𝑜𝑛𝑦, 3.2 ),( 𝐽𝑜𝑛𝑎𝑠, 3.3)} Equivalence Relations A relation on a set 𝐴 is called an equivalence relation if it is reflexive, symmetric, and transitive. Let 𝑅 be an equivalence relation on 𝐴. Equivalent class Equivalent class -\u0026gt; Equivalent relations\nPartition All the equivalent classes obtained from 𝐴 through an equivalent class are either same or disjoint. These disjoint classes are subsets of 𝐴. The union of these subsets is 𝐴. These subsets are called a partition of A In general, (𝐴1, 𝐴2, ⋯ , 𝐴𝑛) is a partition of 𝐴 if: 𝐴𝑖 ≠ ∅ for all 1 ≤ 𝑖 ≤ 𝑛 𝐴𝑖 ∩ 𝐴𝑗 = ∅ for all 1 ≤ 𝑖,𝑗 ≤ 𝑛 𝐴1 ∪ 𝐴2 ∪ ⋯ ∪ 𝐴𝑛 = A Theorem: Let 𝑅 be an equivalence relation on a nonempty set 𝐴. The following statements are equivalent:\na R b [𝑎] = [𝑏] 𝑎 ∩ [𝑏] ≠ ∅ ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/distcreterelations/","title":"离散数学——Relations"},{"content":"Sets A set is a collection of objects Sets are used to group objects together Three ways to express the members in a set - List all the members - Use predicates - Use suspension(省略号)points(must be inferred) universal set $ℕ$ : the set of all natural numbers $ℤ$ : the set of integers $ℤ^+$ : the set of all the positive integers $ℚ$: the set of all rational numbers $ℝ$: the set of all the real numbers $ℂ$: the set of all complex numbers Venn Diagrams two basic shapes A rectangle: indicates the universal set Circles or other shapes: indicate normal sets Elements and Sets $A∈B$ : A is in or is an element of B $A∉B$ : A is not in or is not an element of B Subsets Subsets Proper subsets(真子集) Empty sets Cardinality number of distinct elements in a set\nThe cardinality of a set s is denoted as |s|\nPower Sets $P(S) = {A|A ⊆ S}$\nTheorem of Power Sets: $ if |S| = n, then |P(S)| = 2^n$\nOrdered n-tuple The form (1, 2, … , ) or \u0026lt; 1, 2, … , \u0026gt; (1,2) not equal to (2,1) Cartesian Product(笛卡尔乘积) Cartesian product of $S_1, S_2, ⋯ ,S_n (denoted S_1 × S_2 × ⋯ ×S_n )$ $S_1 × S_2 × ⋯ ×S_n = {(a1, a2, … ,an )|a_1 ∈ S_1 ∧ a_2 ∈ S_2 ∧⋯ ∧ a_n ∈ S_n}$\nDisjoint Sets If A ∩ B = ∅ then A and B are disjoint. If A ∩ B ≠ ∅ then A and B are overlapped. function conditions A function from to is a subset of × which satisfies the following two conditions\n1.$ ∀ x(x ∈ A → ∃ y(y ∈ B ∧ (x,y) ∈f)) $\n2. $ (((x_1,y_1 ) ∈ f ∧ (x_1,y_2 ) ∈ f) → y_1 = y_2)$\nImage, Pre-image and Range(值域) If $y = f(x)$ from set A to set B, then\ny is called the image of x under f x is called a pre-image of y the set of all the images of the elements in the domain under is called the range of f, f(A) = {f(x)|x ∈ A} injective function（单射） f is one-to-one\nurjective function (满射) Onto function :$∀y ∈ B (∃x(x ∈A ∧f (x) =y ))$\nbijective function (双射) [One-to-One and onto function] is also called bijective function\nFloor functions Denoted $\\lfloor x \\rfloor$ The largest integer less than or equivalent to x Ceiling functions Denoted $\\lceil x \\rceil$ The smallest integer greater than or equivalent to x Sequences 数列 Sequences are ordered lists of elements • A sequence is a function from a subset of the set of integers ({0, 1, 2, 3, … } or {1, 2, 3, … }) to a set , denoted {$a_n$}. The integers determine the positions of the elements in the list\nSummations 求和 A summation is the value of the sum of the terms of a sequence.\nSpecial Summations Geometric series 等比数列和 $\\sum^n_{j=0}ar^j$\nharmonic series $\\sum^n_{j=1} \\frac{1}{j}$\n","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/sfss/","title":"离散数学——SFSS"},{"content":"【模板】并查集 题目描述 如题，现在有一个并查集，你需要完成合并和查询操作。\n输入格式 第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。\n接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。\n当 $Z_i=1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。\n当 $Z_i=2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出 Y ；否则输出 N 。\n输出格式 对于每一个 $Z_i=2$ 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 8 4 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 样例输出 #1 1 2 3 4 N Y N Y 提示 对于 $30%$ 的数据，$N \\le 10$，$M \\le 20$。\n对于 $70%$ 的数据，$N \\le 100$，$M \\le 10^3$。\n对于 $100%$ 的数据，$1\\le N \\le 10^4$，$1\\le M \\le 2\\times 10^5$，$1 \\le X_i, Y_i \\le N$，$Z_i \\in { 1, 2 }$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; class Buf { public: Buf(int sz) : root(sz), rank(sz) { for (int i = 0; i \u0026lt; sz; i++) { root[i] = i; rank[i] = 1; } } int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] \u0026lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(int x, int y) { return find(x) == find(y); } private: vector\u0026lt;int\u0026gt; root; vector\u0026lt;int\u0026gt; rank; }; int main() { ios int n,m,y,x,z; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; Buf a=Buf(n+1); while(m--){ cin\u0026gt;\u0026gt;z\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(z==1){ a.unionSet(x,y); } else{ if(a.connected(x,y))cout\u0026lt;\u0026lt;\u0026#34;Y\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; cout\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0003/","title":"洛谷0003——并查集"},{"content":"[TJOI2009] 开关 题目描述 现有 $n$ 盏灯排成一排，从左到右依次编号为：$1$，$2$，……，$n$。然后依次执行 $m$ 项操作。\n操作分为两种：\n指定一个区间 $[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）； 指定一个区间 $[a,b]$，要求你输出这个区间内有多少盏灯是打开的。 灯在初始时都是关着的。\n输入格式 第一行有两个整数 $n$ 和 $m$，分别表示灯的数目和操作的数目。\n接下来有 $m$ 行，每行有三个整数，依次为：$c$、$a$、$b$。其中 $c$ 表示操作的种类。\n当 $c$ 的值为 $0$ 时，表示是第一种操作。 当 $c$ 的值为 $1$ 时，表示是第二种操作。 $a$ 和 $b$ 则分别表示了操作区间的左右边界。\n输出格式 每当遇到第二种操作时，输出一行，包含一个整数，表示此时在查询的区间中打开的灯的数目。\n样例 #1 样例输入 #1 1 2 3 4 5 6 4 5 0 1 2 0 2 4 1 2 3 0 2 4 1 1 4 样例输出 #1 1 2 1 2 提示 数据规模与约定 对于全部的测试点，保证 $2\\le n\\le 10^5$，$1\\le m\\le 10^5$，$1\\le a,b\\le n$，$c\\in{0,1}$。\\\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e5+9; //开4倍 //n 为维护的数组长度，A为维护的数组 ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //叶子节点可以不更新 if (len \u0026lt;= 1) return; //向下传递lazy标记 if(mark[p]%2)tree[p \u0026lt;\u0026lt; 1] = (len - len / 2)-tree[p\u0026lt;\u0026lt;1]; mark[p \u0026lt;\u0026lt; 1] += mark[p]%2; if(mark[p]%2)tree[p \u0026lt;\u0026lt; 1 | 1] = (len / 2)-tree[p\u0026lt;\u0026lt;1|1]; mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]%2; //向下传递了，自然清除自身的tag mark[p] = 0; } void push_up(int p){ //这里维护的是区间和 tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //如果叶子节点 if (cl == cr) return void(tree[p] = A[cl]); //左右递归建树 int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] = d * (cr - cl + 1)-tree[p]; mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } int main() { ios int m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; build(); int op,x,y; while(m--){ cin\u0026gt;\u0026gt;op; if(op==0){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; update(x,y,1); } else{ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll res=query(x,y); cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0004/","title":"洛谷0004——[TJOI2009] 开关"},{"content":"【模板】线段树 1 题目描述 如题，已知一个数列，你需要进行下面两种操作：\n将某区间每一个数加上 $k$。 求出某区间每一个数的和。 输入格式 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。\n第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。\n接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：\n1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 输出格式 输出包含若干行整数，即为所有操作 2 的结果。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 1 2 3 11 8 20 提示 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。\n对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。\n对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。\n保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。\n【样例解释】\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e5+9; //开4倍 //n 为维护的数组长度，A为维护的数组 ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //叶子节点可以不更新 if (len \u0026lt;= 1) return; //向下传递lazy标记 tree[p \u0026lt;\u0026lt; 1] += mark[p] * (len - len / 2); mark[p \u0026lt;\u0026lt; 1] += mark[p]; tree[p \u0026lt;\u0026lt; 1 | 1] += mark[p] * (len / 2); mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]; //向下传递了，自然清除自身的tag mark[p] = 0; } void push_up(int p){ //这里维护的是区间和 tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //如果叶子节点 if (cl == cr) return void(tree[p] = A[cl]); //左右递归建树 int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] += d * (cr - cl + 1); mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } int main() { ios int m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; FOR(i,1,n+1){ cin\u0026gt;\u0026gt;A[i]; } build(); int op,x,y,k; while(m--){ cin\u0026gt;\u0026gt;op; if(op==1){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;k; update(x,y,k); } else{ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll res=query(x,y); cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0005/","title":"洛谷0005——【模板】线段树 1"},{"content":"封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class FenwickTree{ public: int n; vector\u0026lt;int\u0026gt; tree; FenwickTree(int i): n(i),tree(i+1){ for(int a=0;a\u0026lt;=i;a++){ tree[a]=0; } } void update(int i,int val){ while(i\u0026lt;=n){ tree[i]+=val; i+=i\u0026amp;(-i); } } int query(int i){ int res=0; while(i\u0026gt;0){ res+=tree[i]; i-=i\u0026amp;(-i); } return res; } } 非封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //n为实际长度 ll tree[MAXN],n; void update(int i,int val){ while(i\u0026lt;=n){ tree[i]+=val; i+=i\u0026amp;(-i); } } int query(int i){ int res=0; while(i\u0026gt;0){ res+=tree[i]; i-=i\u0026amp;(-i); } return res; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/fenwicktree/","title":"树状数组模板"},{"content":"lazy线段树模板 区间修改logn 区间查询logn （维护存在交换律的信息） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 const int MAXN=1e5+9; //开4倍 //n 为维护的数组长度，A为维护的数组 ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //叶子节点可以不更新 if (len \u0026lt;= 1) return; //向下传递lazy标记 tree[p \u0026lt;\u0026lt; 1] += mark[p] * (len - len / 2); mark[p \u0026lt;\u0026lt; 1] += mark[p]; tree[p \u0026lt;\u0026lt; 1 | 1] += mark[p] * (len / 2); mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]; //向下传递了，自然清除自身的tag mark[p] = 0; } void push_up(int p){ //这里维护的是区间和 tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //如果叶子节点 if (cl == cr) return void(tree[p] = A[cl]); //左右递归建树 int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] += d * (cr - cl + 1); mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/segmenttree/","title":"线段树模板"},{"content":"【深进1.例1】求区间和 题目描述 给定 $n$ 个正整数组成的数列 $a_1, a_2, \\cdots, a_n$ 和 $m$ 个区间 $[l_i,r_i]$，分别求这 $m$ 个区间的区间和。对于所有测试数据，$n,m\\le10^5,a_i\\le 10^4$\n输入格式 共 $n+m+2$ 行。\n第一行，为一个正整数 $n$ 。\n第二行，为 $n$ 个正整数 $a_1,a_2, \\cdots ,a_n$\n第三行，为一个正整数 $m$ 。\n第 $4$ 到第 $n+m+2$ 行，每行为两个正整数 $l_i,r_i$ ，满足$1\\le l_i\\le r_i\\le n$\n输出格式 共 $m$ 行。\n第 $i$ 行为第 $i$ 组答案的询问。\n样例 #1 样例输入 #1 1 2 3 4 5 4 4 3 2 1 2 1 4 2 3 样例输出 #1 1 2 10 5 提示 样例解释：第 1 到第 4 个数加起来和为 10。第 2 个数到第 3 个数加起来和为5。\n对于 50% 的数据：$n,m\\le 1000$ ；\n对于100% 的数据：$n.m\\le 10^5,a_i\\le 10^4$\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+3; int a[N]; int b[N]; int main() { ios int n,m; cin\u0026gt;\u0026gt;n; FOR(i,0,n){ cin\u0026gt;\u0026gt;a[i]; } FOR(i,1,n+1){ b[i]=b[i-1]+a[i-1]; } cin\u0026gt;\u0026gt;m; int l,r; FOR(i,0,m){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;b[r]-b[l-1]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0001/","title":"洛谷0001——求区间和"},{"content":"最大加权矩形 题目描述 为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。\n校长先给他们一个 $n\\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如\n1 2 3 4 0 –2 –7 0 9 2 –6 2 -4 1 –4 1 -1 8 0 –2 在左下角：\n1 2 3 9 2 -4 1 -1 8 和为 $15$。\n几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？\n输入格式 第一行：$n$，接下来是 $n$ 行 $n$ 列的矩阵。\n输出格式 最大矩形（子矩阵）的和。\n样例 #1 样例输入 #1 1 2 3 4 5 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 样例输出 #1 1 15 提示 $1 \\leq n\\le 120$\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=123; int a[N][N]; int b[N][N]; int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,0,n){ FOR(j,0,n){ cin\u0026gt;\u0026gt;a[i][j]; } } FOR(i,1,n+1){ FOR(j,1,n+1){ b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i-1][j-1]; } } int ans=-inf; FOR(x1,1,n+1){ FOR(y1,1,n+1){ FOR(x2,x1,n+1){ FOR(y2,y1,n+1){ ans=max(ans,b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1]); } } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0002/","title":"洛谷0002——最大加权矩形"},{"content":"Topic OOP Introduction \u0026amp; UML Java Programming Essentials Creating Java Classes Inheritance Abstract and Interface Exception Handling Array and Generics 概念 object is an instanceof a class a class is a blueprint from which objects are made Objects have data(instance fileds) and behavior(medthods) UML \u0026amp;\u0026amp; Class Relationship association aggregation(关系更加紧密,但可分开) composition(不可分开) inheritance Java Programming Essentials 变量名 字母数字$_\n数字不能开头\n变量类型 Local Variables 方法体内\nInstance Variables 成员变量,类中方法体外\nClass Variables 类变量,静态成员变量,同一种类只有一份拷贝\nParameters 传参\n常量 final修饰,不能更改\nStandard input and output (I/O) System.out Scanner float float类型如果含有小数的话一定要加上后缀f/F(不加默认是double)\nchar 在java里同样区分单引号双引号\n隐式转换 在java中只能向上转换 特别的,char转int但int不能隐式转化char\nswitch 1 2 3 4 5 6 7 8 9 10 11 switch(expression){ case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句 } Creating Java Classes Constructor the same name as the class no type return often overloaed default constructor Memory analysis 访问修饰符 见修饰符\n修饰符1 访问修饰符 default(什么也不写): 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\nprivate : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）\npublic : 对所有类可见。使用对象：类、接口、变量、方法\nprotected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）\n非访问修饰符 static 修饰符 用来修饰类方法和类变量。\n静态变量 static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。\n静态方法 static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。\nfinal 修饰符 用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\nfinal变量 final 修饰符通常和 static 修饰符一起使用来创建类常量。\nfinal方法 父类中的 final 方法可以被子类继承，但是不能被子类重写 abstract 修饰符，用来创建抽象类和抽象方法。\nabstract修饰符 详见抽象\n继承 Subclass automatically has all the non-private instance variables and methods of the superclass\n关键词 extends 调用父类方法 super 我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。\n在构造中子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。2\n记得super放在构造器的第一行\n关键词this this关键字：指向自己的引用。 另外参数变量名和成员变量名重复的时候常使用this关键词区分\nOverride 与 Overload 重写方法 返回值和形参不能改 抛出的异常不能变得比父类广泛 重载方法 访问权限不能更小 入参不能改 返回值可以不同(但是必须是父类返回值的派生类) 抛出的异常可以改变 Object toString() equals(\u0026hellip;) upcase 和 downcase upcase:子类可以转为父类类型 downcase: 只有由子类转成父类的父类才可以转为子类 关键词instanceof A istanseof Class,其中 A 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果都返回 true，否则返回false。\n注意 java中不能多继承\n抽象 关键词abstract 特点 不能实例化对象\n抽象方法特点 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法 1 2 3 public abstract class A{ public abstract void ToDo(); } 接口 特点 都为抽象方法 不支持非final/static修饰的变量(不写默认为static final) 不需要写出abstract 继承 接口继承接口:extends3 接口允许多继承\n接口的实现 关键词:implements 类可以实现多个接口\n异常处理 unchecked exceptions and checked exceptions RuntimeException: don\u0026rsquo;t know Else: checked\n异常捕获 1 2 3 4 5 6 7 8 9 10 11 try{ // 程序代码 }catch(异常类型1 异常的变量名1){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 }catch(异常类型3 异常的变量名3){ // 程序代码 }finally{ //to-do } finally无论是否try/catch都会触发\ntry 代码后不能既没catch也没finally\nthrow throw new Exception(\u0026quot;aaa\u0026quot;);\nthrows 表明可能抛出异常\n常用 e.getMessage() 获取e中的字符串\n自定义异常 这里只处理检测性异常\n模板 1 2 3 4 5 public class A extends Exception{ public A(String s){ super(s); } } 泛型 泛型标记符 E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ？ - 表示不确定的 java 类型\n泛型上限/下限 \u0026lt;T extends/implements B\u0026gt; 表示泛型应为B或B的子类\n\u0026lt;T super B\u0026gt; 表示泛型应为B或B的父类\n泛型类与泛型方法 1 2 3 4 5 6 7 public class A\u0026lt;T\u0026gt;{ //todo } public \u0026lt;T\u0026gt; void ff(T t1,T t2){ //todo } 字符串 字符串相等 equals()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //源自菜鸟教程 String s1 = \u0026#34;Hello\u0026#34;; // String 直接创建 String s2 = \u0026#34;Hello\u0026#34;; // String 直接创建 String s3 = s1; // 相同引用 String s4 = new String(\u0026#34;Hello\u0026#34;); // String 对象创建 String s5 = new String(\u0026#34;Hello\u0026#34;); // String 对象创建 s1 == s1; // true, 相同引用 s1 == s2; // true, s1 和 s2 都在公共池中，引用相同 s1 == s3; // true, s3 与 s1 引用相同 s1 == s4; // false, 不同引用地址 s4 == s5; // false, 堆中不同引用地址 s1.equals(s3); // true, 相同内容 s1.equals(s4); // true, 相同内容 s4.equals(s5); // true, 相同内容 数组 array a.length A[] a; a=new A(1)[10];\narraylist 1 import java.util.ArrayList; ArrayList\u0026lt;String\u0026gt; sites = new ArrayList\u0026lt;String\u0026gt;(); get()访问元素 set(i,\u0026ldquo;xxx\u0026rdquo;)修改元素 add()添加元素 remove(i)删除下标为i的元素 removeAll()删除所有元素 size()大小\n摘自菜鸟教程\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n摘自菜鸟教程\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n请与接口的实现区分\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/oop-java/","title":"面向对象与Java"},{"content":"一维前缀和 1 2 3 // S[i] = a[1] + a[2] + ... a[i] // a[l] + ... + a[r] = S[r] - S[l - 1] S[r] - S[l - 1] 二维前缀和 1 2 3 4 // S[i, j] = 第i行j列格子左上部分所有元素的和 b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j] // 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1] 一维差分 1 2 // 给区间[l, r]中的每个数加上c： B[l] += c, B[r + 1] -= c 二维差分 1 2 // 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1][y1] += c, S[x2 + 1][y1] -= c, S[x1][y2 + 1] -= c, S[x2 + 1][y2 + 1] += c tips 从1开始，0开大，防特判 ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/presum/","title":"前缀和与差分模板"},{"content":"H 签到题 题目概述 如长度为7的字母三角形如下: ABCDEFG\nHIJKLM\nNOPQR\nSTUV\nWXY\nZA\nB\n问长为n的字母三角形第a行第b个是什么字母?\n输入 一行 n a b 输出 一个字符\n例 in: 4 2 3\nout: G\nin: 7 7 1\nout: B\n思路 不难找出规律这个字母为(n+n-1+..+(n-a+2)+b)%26\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define For(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define _For(a,b,c) for(int a=(b);a\u0026gt;(c);a--) #define all(x) (x).begin(),x.end() #define inf 0x3f3f3f3f //对拍 #define fo1 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define fo2 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //输出数组 #define printA(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6; const int MOD=26; inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } inline void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;); x = -x; } if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } inline void hhhh(){ ll n,a,b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; //ABCD EFG HI J //n+n-1+..+(n-a+2) +b ll x=(n-a+2+n)*(a-1)/2; x%=MOD; x+=b%MOD; x%=MOD; cout\u0026lt;\u0026lt;char(x+\u0026#39;A\u0026#39;-1)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } int main() { hhhh(); // int T; // T.read(); // while(T--){ // hhhh(); // } return 0; } J 签到题 题目 Given a tree with n nodes numbered from 1 to n. Alice wants to know the number of connected components with a size of three in the tree.\n输入 第一行n节点数(1≤n≤$10^5$) n-1行每行两个节点表示u,v表示u,v连通(1\u0026lt;=u,v\u0026lt;=n)\n输出 大小为3的连通子图的数量\ntest 1 2 3 3 1 2 2 3 ans:1\n1 2 3 4 5 5 1 2 1 3 1 4 2 5 ans:4\n思路 错误1:没有估计好大小,实际上int不够\n错误2:以为u\u0026lt;v,建图的时候没有考虑到 找规律:\n1 2 3 4 5 6 7 8 9 10 11 12 /* 1 2 3 4 5 6 层数\u0026gt;=3 都加上1 从第2层 C(n,2) */ bfs遍历一遍按照规律计算即可\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define For(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define _For(a,b,c) for(int a=(b);a\u0026gt;(c);a--) #define all(x) (x).begin(),x.end() #define inf 0x3f3f3f3f //对拍 #define fo1 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define fo2 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //输出数组 #define printA(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6; const int MOD=1e9+7; inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } inline void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;); x = -x; } if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } ll n; ll cb(ll n){ if(n\u0026lt;2)return 0; if(n==2)return 1; return n*(n-1)/2; } vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; G; set\u0026lt;ll\u0026gt; visited; inline void hhhh(){ cin\u0026gt;\u0026gt;n; G.resize(n+3); ll u,v; For(i,1,n){ cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].push_back(v); G[v].push_back(u); } queue\u0026lt;ll\u0026gt; q; q.push(1); visited.insert(1); ll depth=0; ll ans=0; while(!q.empty()){ ll sizes=q.size(); if(depth\u0026gt;=2){ ans+=sizes; } For(i,0,sizes){ ll node=q.front(); q.pop(); ll num=0; for(auto x:G[node]){ if(visited.count(x))continue; num++; q.push(x); visited.insert(x); } ans+=cb(num); } depth++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } int main() { hhhh(); return 0; } E签到题 题目 给你一个长为n的正数数组A,给出它的对应正数数组B\nB数组要满足以下条件:\n元素不在A中 与A中对应(You can specify the correspondence relationship arbitrarily, but the relationship must be consistent and unique.For example, if you specify that the number 3 in the first line corresponds to the number 1 in the second line, then another non-3 number in the first line cannot correspond to the number 1, and all 3s in the first line must correspond to 1.) 输入 第一行n长度[1,$10^5$] 第二行n个数字,[1,$10^9$]\n输出 B数组,如有多个输出字典序最小的那个\n样例 1 2 6 3 3 4 2 4 7 ans:1 1 5 6 5 8 解释:\nLet 3 correspond to 1, 4 correspond to 5, 2 correspond to 6, and 7 correspond to 8, then the second line is [1, 1, 5, 6, 5, 8]. This is the smallest in lexicographic order. If we let 3 correspond to 9, the second line would be [9, 9, 5, 6, 5, 8], which is also a valid second line, but not the smallest one required by the problem.\n思路 维护一个set去重A,然后再遍历一遍A并同时维护一个哈希表即可\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define For(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define _For(a,b,c) for(int a=(b);a\u0026gt;(c);a--) #define all(x) (x).begin(),x.end() #define inf 0x3f3f3f3f //对拍 #define fo1 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define fo2 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //输出数组 #define printA(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+4; const int MOD=1e9+7; inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } inline void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;); x = -x; } if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } int a[N]; set\u0026lt;int\u0026gt; b; map\u0026lt;int,int\u0026gt; ans; inline void hhhh(){ int n; n=read(); For(i,0,n){ a[i]=read(); b.insert(a[i]); } int s=1; For(i,0,n){ if(!ans.count(a[i])){ while(b.count(s))s++; ans[a[i]]=s++; } cout\u0026lt;\u0026lt;ans[a[i]]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } //todo } int main() { hhhh(); // int T; // T.read(); // while(T--){ // hhhh(); // } return 0; } ","date":"2023-05-01T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/nowcoder-acm-contest-59433/","title":"2023年国际大学生程序设计竞赛（ACM-ICPC）新疆赛区(重现赛)"},{"content":" A tree is a connected undirected simple graph that contains no simple circuits.\nRooted Trees concept A rooted tree is a tree in which one node has been designated the root.\nEvery edge is directed away from the root.\nGiven a vertex 𝑣 in a rooted tree 𝑇:\nParent: unique vertex 𝑢 such that (𝑢,𝑣) is an edge (in the direction from root to 𝑣) Child: any vertex for which 𝑣 is a parent Siblings : vertices with the same parent(兄弟节点) Ancestors : all vertices from root to 𝑣 (except itself) Descendants : vertices with 𝑣 as an ancestors tips A vertex of a tree is called a leaf if it has no children.\nVertices that have children are called internal vertices.\nGame(state) Trees(决策树) Vertices: positions (states) in a game Edges: legal moves from one position (state) to another Leaves: Final positions (states) of a game m-ary Trees(M叉树) A rooted tree is called 𝑚-ary if every internal vertex has no more than 𝑚 children\nIt is called full if every internal (non-leaf) vertex has exactly 𝑚 children. A 2-ary tree is called a binary tree If vertex 𝑣 is in a tree 𝑇, the sub-tree with root 𝑣 is the tree consisting of 𝑣 and all its descendants. Balanced Tree(平衡树) level and height The level of a node is the length of the path from the root to the node (The level of the root is defined to be zero). The height of a tree is maximum level of node.\nbalanced A rooted 𝑚-ary tree with height ℎ is called balanced if all leaves are at levels ℎ or ℎ−1.\nBinary Search Tree (二叉搜索树) 左小右大\nAlgorithms The presentation of an algorithm (from high level to low level):\ndescriptive method in a natural language pseudo code source code Traversal Algorithm Pre-order traversal Let 𝑇 be a rooted tree with root 𝑟. If 𝑇 consists only of 𝑟, then 𝑟 is the preorder traversal of 𝑇. Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right. The preorder traversal of 𝑇 will begin by visiting 𝑟, then 𝑇1 (in preorder), then 𝑇2 (in preorder), etc, until 𝑇𝑛 is traversed in preorder\nIn-order traversal Let 𝑇 be a rooted tree with root 𝑟 If 𝑇 consists only of 𝑟, then 𝑟 is the in-order traversal of 𝑇. Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right. The in-order traversal of 𝑇 will begin by visiting 𝑇1 (in-order), then the root 𝑟, then 𝑇2 (in-order), etc, until 𝑇𝑛 is traversed in-order\nPost-order traversal Let 𝑇 be a rooted tree with root 𝑟 If 𝑇 consists only of 𝑟, then r is the post-order traversal of 𝑇. Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right. The post-order traversal of 𝑇 will begin by visiting 𝑇1 (in post-order), then 𝑇2 (in post-order), etc, then 𝑇𝑛 (in post-order) and finally the root 𝑟.\nExpression Trees The expression tree for an arithmetic expression consists of\nVertices: numbers, +, −, ∗, /, ↑(↑ represents the power function) Edges: linking parts of an expression Internal vertices(非叶子节点) represent operations Leaves(叶子节点) represent the variables or numbers Spanning Trees(生成树) A spanning tree of a connected undirected graph 𝐺 is a sub-graph of 𝐺 that contains all of 𝐺’s vertices and enough of its edges to form a tree.\nHow to obtain? To obtain a spanning tree from a connected undirected graph with cycles:\nRemove edges until there are no cycles\nDepth-First Search Depth-First Search (DFS) proceeds along a path from a vertex 𝑣 as deeply into the graph as possible before backing up (back-tracking). To create a depth-first search (DFS) spanning tree: Traverse the graph using a depth-first search and mark the edges that you follow. After the traversal is complete, the graph’s vertices and marked edges form the spanning tree.\n(If there are multiple choices, choose the next vertex in the alphabetical order.)\nBreadth-First Search Breadth-First Search (BFS) visits every vertex adjacent to a vertex v that it can before visiting any other vertex. To create a breath-first search (BFS) spanning tree Traverse the graph using a bread-first search and mark the edges that you follow. When the traversal is complete, the graph’s vertices and marked edges form the spanning tree.\nMinimum Spanning Trees(最小生成树) A minimum spanning tree in a connected weighted graph is a spanning tree that has the smallest possible sum of weights of edges.\nThere may be several different minimum spanning trees for a particular graph. But the minimum weight is unique.\nPrim Initially, starts from an empty (no vertices, no edges) sub minimum spanning tree 𝑇. Randomly put a vertex 𝑣 into 𝑇. Among all the edges (𝑢,𝑠) such that 𝑢 is in 𝑇 and 𝑠 is not in 𝑇, find the one of the minimum weight. And add the edge and the endpoint to 𝑇. Repeat Step 3 for 𝑛−1 iterations (because a tree has 𝑛−1 edges). Kruskal Initially, starts from a subgraph of all vertices but no edges. Find the edge with the smallest weight. If adding the smallest edge to the subgraph does not create any cycle, add it. (To maintain the tree property.) Otherwise, this edge is not in the MST. So, discard the edge. Repeat steps 2-4 until for 𝑛−1 iterations (because a tree has 𝑛−1 edges). ","date":"2023-05-01T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/dstree/","title":"离散数学---Tree"},{"content":"Graph Theory Graph concepts Definition1 A graph G = (V,E) is a pair and consists of two sets V and such that:\nV is the set of vertices(顶点) E is the set of edges(边) Remember V cannot be empty,but E can(endpoint/node) Each edge have 1 or 2 vertices(1 is a ring) Definition2 (u,v) is an edge connetcing vettices u and v u and v are neighbors (adjacent). (u,v) connects u and v ((u,v) is incident on u and v). Simple graphs each edge connects two different vertices and where no two edges connect the same pair of vertices. Multigraph A multigraph is a graph that may have multiple edges connecting the same pair of vertices. If there are m different edges associated to the same unordered pair of vertices u and v, (u, v) is an edge of multiplicity. Loops(自环) A loop is an edge that connects one vertex to itself. Graphs that may include loops, and possibly multiples edges connecting the same pair of vertices are called pseudo-graphs. Directed Graph(有向图) A directed graph (V,E) consists of a nonempty set V and a set of directed edges E\ntips The edge (u,v) in a directed graph starts at u and ends at v.\nDegree(度) The degree of a vertex in an undirected graph is the number of edges connected with it except that a loop at a vertex(自环算2)contribute twice to the degree of that vertex.\nIn-Degree and Out-Degree(入度、出度) $In:def^-(v)$\n$Out:def^+(v)$\nHandshaking Theorem For an undirected graph G= (V,E):\n$$2|E|=\\sum_{v \\in V}deg(v)$$\nOdd Degree Theorem In a directed graph G = (V,E) $$|E|=\\sum_{v \\in V}deg^-(v)=\\sum_{v \\in V}deg^+(v)$$\nSpecial graphs Complete graphs(完全图) A complete graph is a simple graph in which there is an edge between each pair of distinct vertices, denoted by $K_n$ where n is the number of nodes in the graph\nCycles A cycle is a graph that contains (n ≥ 3) vertices {V1, V2, … ,Vn } and n edges (V1, V2), (V2, V3), …, (Vn, V1), denoted by $C_n$ where is the number of nodes in the graph.\nWheels $Cn$加上中间一个点以及连边，记做$W_n$\nCubes A cube of dimension n($Q_n$)is a simple graph of $2^n$ vertices, where each vertex represents a bit string of length n. Two vertices are adjacent if and only if they differ by one bit.\nBipartite Graphs(二分图) A simple graph G = (V,E ) is called bipartite if its vertex set V can be partitioned into two disjoint set V1 and V2 such that every edge in the graph connects a vertex in V1 and a vertex in V2. V1 and V2 are called a bipartite of the vertex set V of G Theorem(染色法) 前置知识：二分图不存在奇数环\nA simple graph G= (V,E) is bipartite if and only if it is possible to color each vertex with one of two colors so that no adjacent vertices have the same color.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i \u0026lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } //source：https://www.acwing.com/blog/content/405/ Complete Bipartite Graphs(完全二分图) $K_{m,n} $\nIn a complete bipartite graph, for any vertex in a subset,there is an edge between it and each vertex in another set.\nOutline Subgraphs and Proper Subgraphs A subgraph H = (W,F) of graph G = (V,E) is made up of vertices W ⊆ V and edges F ⊆ E. A subgraph H of G is a proper subgraph if H ≠ G. Union of Simple Graphs The union of two simple graphs G1 = (V1, E1) and G2 = (V2, E2) is the simple graph G = (V, E) such that V = V1 ∪ V2 and E = E1 ∪ E2\nRepresenting Graphs Adjacency matrix(邻接矩阵):dense graph Adjacency table(邻接表):sparse graph Graph Isomorphism(同构图) 判断同构：推荐使用邻接矩阵判断\nGraph Connectivity Path path of length m from vertexu to vertex v is a sequence of edges e1, e2, … , $e_n$ such that e1 starts at u and $e_n$ ends at v.\nCircuit A circuit is a path that begins and ends at the same vertex in graph.\nSimple path or circuit A simple path or circuit does not pass through the same edge twice or more.\nGraph Connectedness An undirected graph is connected if there is a path between every pair of distinct vertices A directed graph is strongly connected if there is a path from a to b and from b to a whenever a and b are vertices in the graph Euler Paths An Euler path in G is a simple path containing every edge of G An Euler circuit in a graph G is a simple circuit containing every edge of G THEOREM A connected multi-graph has an Euler circuit if and only if each vertex has even degree.\nHamilton Circuits A Hamilton path is a path that traverses each vertex in G exactly once A Hamilton circuit is a circuit that traverses each vertex in G exactly once. Ore’s theorem If for every pair of nonadjacent vertices u and v in the simple graph G with n vertices, deg(u) + deg(v) ≥ n ,then has a Hamilton circuit.\nDirac’s theorem If the degree of each vertex is great than or equals n/2 in the connected simple graph G with n vertices where n ≥ 3, then G has a Hamilton circuit.\nPlanar Graphs In a planar representation of\ne: number of edges v: number of vertices r: number of regions $r= e – v + 2$ Euler’s Formula G is a connected planar simple graph\nv ≥ 3, then e ≤ 3v – 6 G has a vertex of degree not exceeding 5 if v\u0026gt;=3 and no circuits of length 3,then e\u0026lt;=2v-4 ","date":"2023-05-01T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/dmgraph/","title":"离散数学————Graph"},{"content":"a的b次方对p取模 前置知识 qpow math:$(a+b)%p=(a%p+b%p)%p$ code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 求 a的 b次方对 p取模的值。 // 输入格式 // 三个整数 a,b,p，在同一行用空格隔开。 // 输出格式 // 输出一个整数，表示a^b mod p的值。 // 数据范围 // 0≤a,b≤10^9 // 1≤p≤109 // 输入样例： // 3 2 7 // 输出样例： // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; // 防止当b=0，p=1时被卡 res=1%p; while(b){ if(b\u0026amp;1)res=(res*a)%p; a*=a; a%=p; b\u0026gt;\u0026gt;=1; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } a*b对p取模 前置知识 qpow math:(a+b)%p=(a%p+b%p)%p code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 求 a // 乘 b // 对 p // 取模的值。 // 输入格式 // 第一行输入整数a // ，第二行输入整数b // ，第三行输入整数p // 。 // 输出格式 // 输出一个整数，表示a*b mod p的值。 // 数据范围 // 1≤a,b,p≤1018 // 输入样例： // 3 // 4 // 5 // 输出样例： // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res=0; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; while(b){ if(b\u0026amp;1)res=(res+a)%p; b\u0026gt;\u0026gt;=1; a*=2; a%=p; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } 最短Hamilton路径 前置知识\n旅行商问题:NP完全,没有多项式时间解法 位运算 状压DP bitset:STL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // 给定一张 n个点的带权无向图，点从 0∼n−1标号，求起点 0到终点 n−1的最短 Hamilton 路径。 // Hamilton 路径的定义是从 0到 n−1不重不漏地经过每个点恰好一次。输入格式 // 第一行输入整数 n。 // 接下来 n行每行 n个整数，其中第 i行第 j个整数表示点 i到 j的距离（记为 a[i,j]）。 // 对于任意的 x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x]并且 a[x,y]+a[y,z]≥a[x,z]。 // 输出格式 // 输出一个整数，表示最短 Hamilton 路径的长度。 // 数据范围 // 1≤n≤20 // 0≤a[i,j]≤107 // 输入样例： // 5 // 0 2 4 5 1 // 2 0 6 5 3 // 4 6 0 8 3 // 5 5 8 0 5 // 1 3 3 5 0 // 输出样例： // 18 #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) #define inf 0x3f const int N=20,M=1\u0026lt;\u0026lt;20; int n; //大数组开到全局里，防止爆栈 //f[i][j]: i:经过状态，j:j点最短路 int f[M][N],w[N][N]; int main(){ cin\u0026gt;\u0026gt;n; For(i,0,n){ For(j,0,n){ cin\u0026gt;\u0026gt;w[i][j]; } } memset(f,inf,sizeof(f)); f[1][0]=0; For(i,0,1\u0026lt;\u0026lt;n){ For(j,0,n){ if(i\u0026gt;\u0026gt;j\u0026amp;1){ //int p=i^(1\u0026lt;\u0026lt;j) int p=i-(1\u0026lt;\u0026lt;j); For(k,0,n){ if(p\u0026amp;(1\u0026lt;\u0026lt;k)) // if(p\u0026gt;\u0026gt;k\u0026amp;1) f[i][j]=min(f[i][j],f[p][k]+w[k][j]); } } } } cout\u0026lt;\u0026lt;f[(1\u0026lt;\u0026lt;n)-1][n-1]\u0026lt;\u0026lt;endl; return 0; } 起床困难综合症 前置知识 位运算性质 :与或非运算在二进制表示下不进位，也就是说每个bit之间独立位运算 贪心 题目描述 21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 正是由于 drd 的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。 为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。 历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。 drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。\n具体说来，drd 的防御战线由 n扇防御门组成。 每扇防御门包括一个运算 op和一个参数 t ，其中运算一定是 OR,XOR,AND中的一种，参数则一定为非负整数。\n如果还未通过防御门时攻击力为 x 则其通过这扇防御门后攻击力将变为 x op t\n最终 drd 受到的伤害为对方初始攻击力 x 依次经过所有 n扇防御门后转变得到的攻击力。\n由于 atm 水平有限，他的初始攻击力只能为 0 到 m之间的一个整数（即他的初始攻击力只能在 0,1,…,m中任选， 但在通过防御门之后的攻击力不受 m的限制）。\n为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。\n输入格式 第 1行包含 2个整数，依次为 n,m，表示 drd 有 n扇防御门，atm 的初始攻击力为 0到 m之间的整数。\n接下来 n 行，依次表示每一扇防御门。每行包括一个字符串 op 和一个非负整数 t ，两者由一个空格隔开，且 op 在前，t 在后，op 表示该防御门所对应的操作，t 表示对应的参数。\n输出格式 输出一个整数，表示 atm 的一次攻击最多使 drd 受到多少伤害。\n数据范围 输入样例： 3 10\nAND 5\nOR 6\nXOR 7\n输出样例： 1\n样例解释 atm可以选择的初始攻击力为 0,1,…,10\n假设初始攻击力为 4，最终攻击力经过了如下计算\n4 AND 5 = 4\n4 OR 6 = 6 6 XOR 7 = 1 类似的，我们可以计算出初始攻击力为 1,3,5,7,9 时最终攻击力为 0 ，初始攻击力为 0,2,4,6,8,10 时最终攻击力为 1 ，因此 atm 的一次攻击最多使 drd 受到的伤害值为 1\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) const int N=1e6; vector\u0026lt;pair\u0026lt;string,int\u0026gt;\u0026gt; a(N); string op; int t; int n,m; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int change(int p,int q){ For(i,0,n){ int x=a[i].second\u0026gt;\u0026gt;p\u0026amp;1; if(a[i].first==\u0026#34;AND\u0026#34;)q\u0026amp;=x; else if(a[i].first==\u0026#34;OR\u0026#34;)q|=x; else {q^=x;} } return q; } int main(){ ios cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; For(i,0,n){ cin\u0026gt;\u0026gt;a[i].first; cin\u0026gt;\u0026gt;a[i].second; } int pre=0,aft=0; For(i,0,30){ int p=29-i; int pos1=change(p,0); int pos2=change(p,1); if(pre+(1\u0026lt;\u0026lt;p)\u0026lt;=m \u0026amp;\u0026amp; pos2\u0026gt;pos1){ pre+=1\u0026lt;\u0026lt;p; aft+=pos2\u0026lt;\u0026lt;p; } else aft+=pos1\u0026lt;\u0026lt;p; } cout\u0026lt;\u0026lt;aft\u0026lt;\u0026lt;endl; } XOR成对变换 1 2 3 4 if n\u0026amp;1: n^1==n-1 else: n^1==n+1 lowbit n\u0026amp;(-n)\n","date":"2023-04-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue01/","title":"小蓝书0X01位运算"},{"content":"激光炸弹 题目 地图上有 $N$ 个目标，用整数 $X_i,Y_i$ 表示目标在地图上的位置，每个目标都有一个价值 $W_i$。\n注意：不同目标可能在同一位置。\n现在有一种新型的激光炸弹，可以摧毁一个包含 $R \\times R$ 个位置的正方形内的所有目标。\n激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 $x,y$ 轴平行。\n求一颗炸弹最多能炸掉地图上总价值为多少的目标。\n输入格式\n第一行输入正整数 $N$ 和 $R$，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。\n接下来 $N$ 行，每行输入一组数据，每组数据包括三个整数 $X_i,Y_i,W_i$，分别代表目标的 $x$ 坐标，$y$ 坐标和价值，数据用空格隔开。\n输出格式\n输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。\n数据范围\n$0 \\le R \\le 10^9$\n$0 \u0026lt; N \\le 10^4, 0 \\le X_i, Y_i \\le 5000, 0 \\le W_i \\le 1000$\n输入样例：\n2 1\n0 0 1\n1 1 1\n输出样例：\n1\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5000+3; int b[N][N]; int main() { ios int r,x,y,w,t; cin\u0026gt;\u0026gt;t\u0026gt;\u0026gt;r; while(t--){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;w; //标准开大一格 b[x+1][y+1]+=w; } FOR(i,1,N) FOR(j,1,N) //题目卡内存，只能开一个数组，原地修改 b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+b[i][j]; int ans=0; // 注意细节 r=min(N-1,r); FOR(i,r,N){ FOR(j,r,N){ ans=max(b[i][j]-b[i-r][j]-b[i][j-r]+b[i-r][j-r],ans); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } IncDec序列 很多时候，我们将区间操作转换为差分序列的单点操作，以降低难度\n题目描述 给定一个长度为 $n$ 的数列 $a_1,a_2,\\dots,a_n$，每次可以选择一个区间 $[l,r]$，使下标在这个区间内的数都加一或者都减一。\n求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。\n输入格式\n第一行输入正整数 $n$。\n接下来 $n$ 行，每行输入一个整数，第 $i+1$ 行的整数代表 $a_i$。\n输出格式\n第一行输出最少操作次数。\n第二行输出最终能得到多少种结果。\n数据范围\n$0\u0026lt;n\\le 10^5$, $0\\le a_i\u0026lt;2^{31}$\n输入样例：\n4\n1\n1\n2\n2\n输出样例：\n1\n2\ntag 思维 贪心 code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+3; ll a[N]; int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,1,n+1){ cin\u0026gt;\u0026gt;a[i]; } // 注意这里倒着 for(int i=n;i\u0026gt;0;i--)a[i]-=a[i-1]; ll cnt=0,cnt2=0; FOR(i,2,n+1){ if(a[i]\u0026gt;0)cnt+=a[i]; else cnt2-=a[i]; } cout\u0026lt;\u0026lt;max(cnt,cnt2)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;abs(cnt2-cnt)+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } 最高的牛 题目 有 N 头牛站成一行，被编队为 1、2、3…N，每头牛的身高都为整数。\n当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。\n现在，我们只知道其中最高的牛是第 P 头，它的身高是 H，剩余牛的身高未知。\n但是，我们还知道这群牛之中存在着 M 对关系，每对关系都指明了某两头牛 A 和 B 可以相互看见。\n求每头牛的身高的最大可能值是多少。\n输入格式\n第一行输入整数 N,P,H,M，数据用空格隔开。\n接下来 M 行，每行输出两个整数 A 和 B，代表牛 A 和牛 B 可以相互看见，数据用空格隔开。\n输出格式\n一共输出 N 行数据，每行输出一个整数。\n第 i 行输出的整数代表第 i 头牛可能的最大身高。\n数据范围\n$1≤N≤5000$，$1≤H≤1000000$，$1≤A,B≤10000$，$0≤M≤10000$\n输入样例：\n1 2 3 4 5 6 9 3 5 5 1 3 5 3 4 3 3 7 9 8 输出样例：\n1 2 3 4 5 6 7 8 9 5 4 5 3 4 4 5 5 5 注意：此题中给出的关系对可能存在重复。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5000+3; set\u0026lt;pii\u0026gt; used; int d[N]; int main() { ios int n,p,h,m,a,b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;p\u0026gt;\u0026gt;h\u0026gt;\u0026gt;m; while(m--){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(a\u0026gt;b)swap(a,b); if(used.count(make_pair(a,b)))continue; d[a+1]--; d[b]++; used.insert(make_pair(a,b)); } d[0]=h; FOR(i,1,n+1){ d[i]+=d[i-1]; cout\u0026lt;\u0026lt;d[i]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } ","date":"2023-04-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue03/","title":"小蓝书0X03前缀和与差分"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/message/","title":"🎗️下面已经空空如也啦~"}]