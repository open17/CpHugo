[{"content":" 1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\u0026#34;); return 0; } åŸºç¡€çŸ¥è¯† åˆ†å· æ¯ä¸ªè¯­å¥å¿…é¡»ä»¥åˆ†å·ç»“æŸ\nç¬¦å·ç±»å‹ ä¸€å®šè¦æ˜¯è‹±æ–‡ç¬¦å·\næ³¨é‡Š å•è¡Œæ³¨é‡Š å¤šè¡Œæ³¨é‡Š(ä¹Ÿå¯å•è¡Œ) 1 2 3 //å•è¡Œæ³¨é‡Š /*å¤šè¡Œæ³¨é‡Š*/ æ•°æ®ç±»å‹ TYPE BYTE MORE char 1 å­—èŠ‚ -128 åˆ° 127 unsigned char 1 å­—èŠ‚ 0 åˆ° 255 signed char 1 å­—èŠ‚ -128 åˆ° 127 int 2 æˆ– 4 å­—èŠ‚ â€”â€”â€” unsigned int 2 æˆ– 4 å­—èŠ‚ â€”â€”â€” short 2 å­—èŠ‚ â€”â€”â€” unsigned short 2 å­—èŠ‚ â€”â€”â€” long 4 å­—èŠ‚ â€”â€”â€” unsigned long 4 å­—èŠ‚ â€”â€”â€” float 4 å­—èŠ‚ 6 ä½æœ‰æ•ˆä½ double 8 å­—èŠ‚ 15 ä½æœ‰æ•ˆä½ long double 16 å­—èŠ‚ 19 ä½æœ‰æ•ˆä½ 1 2 3 4 5 6 7 //sizeofå¯ä»¥è·å–å‚¨å­˜å­—èŠ‚å¤§å° #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;int å­˜å‚¨å¤§å° : %lu \\n\u0026#34;,sizeof(int)); return 0; } å¸¸é‡ æ•´æ•°å¸¸é‡ æ•´æ•°å¸¸é‡å¯ä»¥æ˜¯åè¿›åˆ¶ã€å…«è¿›åˆ¶æˆ–åå…­è¿›åˆ¶çš„å¸¸é‡ã€‚å‰ç¼€æŒ‡å®šåŸºæ•°ï¼š0x æˆ– 0X è¡¨ç¤ºåå…­è¿›åˆ¶ï¼Œ0 è¡¨ç¤ºå…«è¿›åˆ¶ï¼Œä¸å¸¦å‰ç¼€åˆ™é»˜è®¤è¡¨ç¤ºåè¿›åˆ¶ã€‚\næ•´æ•°å¸¸é‡ä¹Ÿå¯ä»¥å¸¦ä¸€ä¸ªåç¼€ï¼Œåç¼€æ˜¯ U å’Œ L çš„ç»„åˆï¼ŒU è¡¨ç¤ºæ— ç¬¦å·æ•´æ•°ï¼ˆunsignedï¼‰ï¼ŒL è¡¨ç¤ºé•¿æ•´æ•°ï¼ˆlongï¼‰ã€‚åç¼€å¯ä»¥æ˜¯å¤§å†™ï¼Œä¹Ÿå¯ä»¥æ˜¯å°å†™ï¼ŒU å’Œ L çš„é¡ºåºä»»æ„ã€‚\næµ®ç‚¹å¸¸é‡ æµ®ç‚¹å¸¸é‡ç”±æ•´æ•°éƒ¨åˆ†ã€å°æ•°ç‚¹ã€å°æ•°éƒ¨åˆ†å’ŒæŒ‡æ•°éƒ¨åˆ†ç»„æˆã€‚æ‚¨å¯ä»¥ä½¿ç”¨å°æ•°å½¢å¼æˆ–è€…æŒ‡æ•°å½¢å¼æ¥è¡¨ç¤ºæµ®ç‚¹å¸¸é‡ã€‚\nå½“ä½¿ç”¨å°æ•°å½¢å¼è¡¨ç¤ºæ—¶ï¼Œå¿…é¡»åŒ…å«æ•´æ•°éƒ¨åˆ†ã€å°æ•°éƒ¨åˆ†ï¼Œæˆ–åŒæ—¶åŒ…å«ä¸¤è€…ã€‚å½“ä½¿ç”¨æŒ‡æ•°å½¢å¼è¡¨ç¤ºæ—¶ï¼Œ å¿…é¡»åŒ…å«å°æ•°ç‚¹ã€æŒ‡æ•°ï¼Œæˆ–åŒæ—¶åŒ…å«ä¸¤è€…ã€‚å¸¦ç¬¦å·çš„æŒ‡æ•°æ˜¯ç”¨ e æˆ– E å¼•å…¥çš„ã€‚\nå­—ç¬¦å¸¸é‡ å•å¼•å·å†… char -\u0026gt; 1å­—èŠ‚ è½¬ä¹‰å­—ç¬¦ \\n æ¢è¡Œç¬¦å· \\b é€€æ ¼ \\ (ç‰¹æ®Šç¬¦å·) æœ¬èº« å­—ç¬¦ä¸²å¸¸é‡ åŒå¼•å·ä¸­\nå¤šè¡Œæ—¶\nå®šä¹‰å¸¸é‡ 1 2 //name=value #define name value å˜é‡ å˜é‡åå¯ä»¥æ˜¯å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿çš„ç»„åˆ\nè§„åˆ™\nå¼€å¤´å¿…é¡»æ˜¯å­—æ¯æˆ– ä¸‹åˆ’çº¿ï¼ˆå¯ä»¥ä¸‹åˆ’çº¿ï¼‰ ä¸å¯ä»¥æ˜¯Cè¯­è¨€å…³é”®å­— ä¸èƒ½æœ‰ç©ºæ ¼ ç±»å‹è½¬æ¢ æ˜¾ç¤ºè½¬æ¢ 1 2 3 c=1.2F b=(int)c //è¦æ³¨æ„åœ¨cä¸­å¼ºåˆ¶è½¬æ¢ä¸æ˜¯ä¸€ä¸ªå‡½æ•°å¼è½¬æ¢ éšå¼è½¬æ¢ æ–¹å‘ï¼š ç²¾åº¦ä¸Šå‡ ç‰¹æ®Šï¼š scanf/printf åªèƒ½int-chrè½¬æ¢(ç²¾åº¦ä¸Šå‡çš„è½¬æ¢éƒ½ä¸è¡Œï¼Ÿ) char - int è½¬æ¢(æ˜¾/éš) è¯¦è§å­—ç¬¦ascii å‚¨å­˜ç±»ï¼ˆä¸è€ƒï¼‰ è¿ç®—ç¬¦ ç®—æ•°è¿ç®—ç¬¦ + - * / å°å¿ƒéšå¼è½¬æ¢ï¼ˆåŠ å‡ä¹Ÿä¼šï¼‰ é™¤æ³•å–å…¨èˆå»ï¼ˆè´Ÿæ—¶åå‘ç»å¯¹å€¼ï¼‰ 1 2 3 //ä¾‹å¦‚ 10/3==-3; 10/(-3)==-3 å–æ¨¡ % åœ¨ç®—æ³•ä¸­å¸¸/ä¸%ä½¿ç”¨ä¾æ¬¡å»ä½æ•°\n(é«˜ç²¾åº¦æ¨¡æ¿é¢˜)\n++\u0026ndash; è‡ªå¢è‡ªå‡ æ³¨æ„Attentionï¼\na++ å…ˆèµ‹å€¼åè¿ç®—\n++a å…ˆè¿ç®—åèµ‹å€¼\nèµ‹å€¼è¿ç®—ç¬¦ å½¢å¼ï¼š (ç®—æ•°è¿ç®—ç¬¦)$=$\nå¦‚ a += 1\nå…³ç³»è¿ç®—ç¬¦\n== != \u0026gt; \u0026lt; \u0026lt;= \u0026gt;= æ³¨æ„Attentionï¼\nåœ¨cä¸­ä¸èƒ½1\u0026lt;a\u0026lt;bè¿™æ ·åˆ¤æ–­\né€»è¾‘è¿ç®—ç¬¦ ä¸ \u0026amp;\u0026amp; æˆ– || é ! ä½è¿ç®—ç¬¦å·\nè¯¦è§ ä½è¿ç®— è¾“å…¥è¾“å‡º è¾“å…¥æµ stdin æœªè¯»å–çš„ä¸ä¼šæ¸…ç©ºï¼Œå…±äº«\n1 2 3 4 5 6 //æ‰‹åŠ¨æ¸…ç©ºè¾“å…¥æµ //é€šè¿‡è¿ç»­è¯»å–æ¥æ¸…ç©ºè¾“å…¥æµ int r=getchar(); while (r!=EOF){ r=getchar() } è¾“å‡ºæµ stdout è¿ç»­ï¼Œä¸ä¼šè‡ªåŠ¨æ¢è¡Œ -\u0026gt; \\nçš„é‡è¦æ€§\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int main(){ char a; //å…¶å®getchar()è¿”å›çš„æ˜¯intï¼Œä¸è¿‡ç”±äºchar-intçš„éšå¼è½¬æ¢ï¼Œä¹Ÿæ— æ‰€è°“ //æ¯å½“æŒ‰ä¸‹å›è½¦æ—¶getcharä¼šè¯»å–stdinä¸­ç¬¬ä¸€ä¸ªï¼Œå¹¶å°†å…¶ä»stdinä¸­å¼¹å‡º a=getchar(); //putchar æ¥æ”¶çš„ä¹Ÿæ˜¯int putchar(a); //scanf è®°å¾—å ä½ç¬¦æ­£ç¡®å’Œå†™å¯»åœ°å€ç¬¦ //å½“ç„¶æ•°ç»„åæœ¬èº«å³ä½¿åœ°å€ï¼Œä¸è¦å¯»åœ°å€ç¬¦ //æ¯å½“æŒ‰ä¸‹å›è½¦æ—¶getcharä¼šè¯»å–stdinä¸­å‰nä¸ªï¼ˆå–å†³äºå ä½ç¬¦ï¼‰ï¼Œå¹¶å°†å…¶ä»stdinä¸­å¼¹å‡º scanf(\u0026#34;%c\u0026#34;,\u0026amp;a); //ä¸€èˆ¬å‡½æ•°æœ€åè¾“å‡ºç»“å°¾éƒ½ä¼šåŠ ä¸Š\\n printf(\u0026#34;%c\\n\u0026#34;,a); return 0; } å ä½ç¬¦ å ä½ç¬¦ ç±»å‹ %d int %c char %s str(char[]) %f float %.3f 3ä½ %lf double %p pointer å­—ç¬¦ascii 32 ç©ºæ ¼ 48-57 æ•°å­—0-9 65-90 å¤§å†™å­—æ¯ 97-122 å°å†™å­—æ¯ 1 2 3 4 5 6 7 8 9 10 // æ ‡å‡†è¾“å…¥è¾“å‡ºåº“ #include \u0026lt;stdio.h\u0026gt; int main(){ //éšå¼è½¬æ¢ 97 a int c = \u0026#39;a\u0026#39;; printf(\u0026#34;%c %d\u0026#34;,c,c); //åœ¨cä¸­å–asciiç å€¼å¯ç›´æ¥ç±»å‹è½¬æ¢å¾—å‡º //è€Œç”±â€œ11â€(str)å–å¾—11(int)å¯è°ƒåº“ï¼Œæˆ–è€…å“ˆå¸Œæ˜ å°„ï¼ˆè‡ªå»ºæ•°ç»„ä¸‹è¡¨æ˜ å°„æˆ–è€…asciiæ˜ å°„(+48)) return 0; } æ›´å¤šè¾“å…¥è¾“å‡º è¯¦è§å­—ç¬¦ä¸²\næ–‡ä»¶è¯»å†™ æ–‡ä»¶æ‰“å¼€å’Œå…³é—­ ä¸è¦å¿˜è®°å…³é—­æ–‡ä»¶\n1 2 3 4 // open FILE *fopen( const char *filename, const char *mode ); // close fclose( FILE *fp ); filename æ–‡ä»¶è·¯å¾„ mode è®¿é—®æ¨¡å¼ mode description r read åªè¯» w write åªå†™ï¼Œé‡å†™/æ–°å»º(ä¼šè¦†ç›–) a add åªå†™ï¼Œè¿½åŠ /æ–°å»º(ä¸ä¼šè¦†ç›–) r+ è¯»å†™ w+ è¯»å†™ï¼Œé‡å†™/æ–°å»º(ä¼šè¦†ç›–) a+ è¯»å†™ï¼Œè¿½åŠ /æ–°å»º(ä¸ä¼šè¦†ç›–) äºŒè¿›åˆ¶æ¨¡å¼ \u0026ldquo;rb\u0026rdquo;, \u0026ldquo;wb\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;rb+\u0026rdquo;, \u0026ldquo;r+b\u0026rdquo;, \u0026ldquo;wb+\u0026rdquo;, \u0026ldquo;w+b\u0026rdquo;, \u0026ldquo;ab+\u0026rdquo;, \u0026ldquo;a+b\u0026rdquo;\nEOF 1 2 //åœ¨cä¸­EOFæ ‡è¯†ç¬¦å®é™…ä¸º-1 #define EOF -1 è¯»å–æ–‡ä»¶ æ³¨æ„fscanf()å…ˆè¦ä¼ å…¥fpï¼Œå’Œå…¶å®ƒç›¸å\n1 2 3 4 //char *buf ä¸ºç¼“å†²åŒºï¼ˆè‡ªå·±å¼€ä¸€ä¸ªæ•°ç»„ï¼‰ int fgetc( FILE * fp ); char *fgets( char *buf, int n, FILE *fp ); int fscanf(FILE *fp ,const char *s, char *buf); å‡½æ•° fgets() ä» fp æ‰€æŒ‡å‘çš„è¾“å…¥æµä¸­è¯»å– n - 1 ä¸ªå­—ç¬¦ã€‚å®ƒä¼šæŠŠè¯»å–çš„å­—ç¬¦ä¸²å¤åˆ¶åˆ°ç¼“å†²åŒº bufï¼Œå¹¶åœ¨æœ€åè¿½åŠ ä¸€ä¸ª null å­—ç¬¦æ¥ç»ˆæ­¢å­—ç¬¦ä¸²ã€‚å¦‚æœè¿™ä¸ªå‡½æ•°åœ¨è¯»å–æœ€åä¸€ä¸ªå­—ç¬¦ä¹‹å‰å°±é‡åˆ°ä¸€ä¸ªæ¢è¡Œç¬¦ \u0026lsquo;\\n\u0026rsquo; æˆ–æ–‡ä»¶çš„æœ«å°¾ EOFï¼Œåˆ™åªä¼šè¿”å›è¯»å–åˆ°çš„å­—ç¬¦ï¼ŒåŒ…æ‹¬æ¢è¡Œç¬¦ int fscanf(FILE *fp, const char *format, \u0026hellip;) å‡½æ•°æ–‡ä»¶ä¸­è¯»å–å­—ç¬¦ä¸²åœ¨é‡åˆ°ç¬¬ä¸€ä¸ªç©ºæ ¼å’Œæ¢è¡Œç¬¦æ—¶ï¼Œä¼šåœæ­¢è¯»å–\nå†™å…¥æ–‡ä»¶ æ³¨æ„fprintf()å…ˆè¦ä¼ å…¥fpï¼Œå’Œå…¶å®ƒç›¸å\n1 2 3 4 // å¤±è´¥æ—¶è¿”å›EOF int fputc( int c, FILE *fp ); int fputs( const char *s, FILE *fp ); int fprintf(FILE * fp,const char*s); äºŒè¿›åˆ¶è¯»å†™ 1 2 fread(); fwrite(); äºŒè¿›åˆ¶ æ¯”ç‰¹ä¸å­—èŠ‚ bit äºŒè¿›åˆ¶ä¸€ä¸ªæ•°ä½ 1 byte = 8 bit è¿›åˆ¶è½¬æ¢ 10è¿›åˆ¶-\u0026gt;2è¿›åˆ¶ï¼š é™¤2æ³•å–ä½™æ•° 2è¿›åˆ¶-\u0026gt;10è¿›åˆ¶ï¼š ä»å³åˆ°å·¦ä¾æ¬¡ä¹˜ä»$2^0$å¼€å§‹åˆ°$2^n$çš„å’Œ\nä½è¿ç®— ä¸ \u0026amp; æˆ– | å–å ~ å¼‚æˆ– ^ å·¦å³ç§» \u0026laquo;\u0026lt; \u0026raquo;\u0026gt; 1 2 3 4 5 6 int a=4; //äºŒè¿›åˆ¶å³ç§»1ä½å³é™¤ä»¥2ï¼Œå·¦ä¸€ä¹˜ä»¥2 //åŒç†ï¼Œåè¿›åˆ¶åˆ™1ä½ä¹˜é™¤10ï¼Œæ³¨æ„cä¸­å·¦å³ç§»ç¬¦å·æ˜¯äºŒè¿›åˆ¶çš„ç§»åŠ¨ if (a\u0026gt;\u0026gt;1==a/2){ printf(\u0026#34;True\u0026#34;); } å¸¸è§æ€§è´¨(ç•¥) äºŒè¿›åˆ¶ç®—æ³• äºŒè¿›åˆ¶æšä¸¾ å¿«é€Ÿå¹‚ åŸºç¡€ç»“æ„ åˆ†æ”¯ç»“æ„ 1 2 3 4 5 6 7 8 9 10 11 12 13 //åˆ†æ”¯ if (){ } else if (){ } else{ } //ä¸‰å…ƒ a==0?printf(\u0026#34;a=0\u0026#34;):printf(\u0026#34;a!=0\u0026#34;); !!!æ³¨æ„\nå¦‚æœswitchæ²¡æœ‰breakåˆ™ä¼šç»§ç»­æ‰§è¡Œï¼ˆä¼šè§¦å‘defaultæˆ–è€…å…¶å®ƒcaseï¼‰\nexpressionå¿…é¡»æ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Œå¿…é¡»æ˜¯ä¸€ä¸ªæ•´å‹æˆ–æšä¸¾ç±»å‹\n1 2 3 4 5 6 7 8 9 10 11 12 switch(expression){ case constant-expression : statement(s); break; /* å¯é€‰çš„ */ case constant-expression : statement(s); break; /* å¯é€‰çš„ */ /* æ‚¨å¯ä»¥æœ‰ä»»æ„æ•°é‡çš„ case è¯­å¥ */ default : /* å¯é€‰çš„ */ statement(s); } å¾ªç¯ç»“æ„ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int a=10; while(1){ a--; if (a\u0026gt;5){ continue; } printf(\u0026#34;NO\u0026#34;) if (a\u0026lt;4) break; } for(a=10;a\u0026lt;3;a--){ printf(\u0026#34;%d,a\u0026#34;); } do{ printf(\u0026#34;%d\u0026#34;,a); a-=1 }while(a); çœç•¥ å¦‚æœåªè·Ÿä¸€ä¸ªå¥å­ï¼Œå¯ä»¥çœç•¥å¤§æ‹¬å· å•æ•°å­—ä½œä¸ºæ¡ä»¶æ—¶0å‡å…¶å®ƒçœŸ å¦‚ä¸‹é¢çš„å¥å­æ˜¯åˆæ³•çš„\n1 2 3 4 5 6 7 8 9 10 for(int i=0;i\u0026lt;10;i++) for(int j=i;j\u0026lt;10;j++) printf(\u0026#34;%d\u0026#34;,j); if(a==0) printf(\u0026#34;YES!!!\u0026#34;); int a=0; if(!a){ printf(\u0026#34;a is zero\u0026#34;); } æ•°ç»„ä¸å­—ç¬¦ä¸² ä¸€ç»´æ•°ç»„ å£°æ˜æ ¼å¼ type arrayName [ arraySize ]; 1 int a[50]; åˆå§‹åŒ–(å¤§æ‹¬å·) 1 2 3 4 5 6 7 8 9 //æ ‡å‡†åˆå§‹åŒ– int a[2]={1,2}; //å¯ä»¥åªåˆå§‹åŒ–å°‘åˆå§‹åŒ–ï¼Œä½†ä¸èƒ½å¤šåˆå§‹åŒ– //å³å¤§æ‹¬å· { } ä¹‹é—´çš„å€¼çš„æ•°ç›®ä¸èƒ½å¤§äºæˆ‘ä»¬åœ¨æ•°ç»„å£°æ˜æ—¶åœ¨æ–¹æ‹¬å· [ ] ä¸­æŒ‡å®šçš„å…ƒç´ æ•°ç›® int a[10]={1,4,3,5}; //å¦‚æœæ²¡æœ‰æŒ‡å®šæ•°ç»„å¤§å°ï¼Œåˆ™å…¶ç­‰äºåˆå§‹åŒ–ä¸ªæ•° int a[]={1,2,4}; ä¸¤ç§è®¿é—® ä¸‹æ ‡ï¼ˆç´¢å¼•ï¼‰ä»0å¼€å§‹ æŒ‡é’ˆè®¿é—®ï¼ˆæ•°ç»„åæŒ‡å‘æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ çš„åœ°å€ï¼Œæ•°ç»„å‚¨å­˜è¿ç»­ï¼‰ è¯¦è§æŒ‡é’ˆ é«˜ç»´æ•°ç»„ å£°æ˜ä¸åˆå§‹åŒ–\n(è¦è®°å¾—å¤§å°ä»1å¼€å§‹ï¼Œä½†ç´¢å¼•ä»0å¼€å§‹) 1 2 3 4 5 // int a[2][2][2]; // // int a[2][3]={1,2,3,2,4,6} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 - ä¸¤ç§è®¿é—® - ä¸‹æ ‡ï¼ˆç´¢å¼•ï¼‰ä»0å¼€å§‹ - æŒ‡é’ˆè®¿é—® - åˆ—æŒ‡é’ˆä¸è¡ŒæŒ‡é’ˆ - å•æŒ‡é’ˆï¼ˆåˆ©ç”¨è¿ç»­æ€§ï¼‰ [è¯¦è§æŒ‡é’ˆ](#æŒ‡é’ˆ) ### å­—ç¬¦ä¸² \u0026gt;everal ways to initialize a string **ä¸€å®š**ä»¥ ***\u0026#39;\\0\u0026#39;*** ç»“å°¾ + char str[20] = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\0\u0026#39;}; + char str[20] = \u0026#34;Hello\u0026#34;; // \u0026#39;\\0\u0026#39; is automatically set to str[5] + char str[] = \u0026#34;Hello\u0026#34;; //str\u0026#39;s size is 6 å¦‚æœå·²ç»å£°æ˜ï¼Œå°±ä¸èƒ½è¿›è¡Œ**åˆå§‹åŒ–** #### æ˜“é”™ç»ƒä¹  æ˜¯å¦æ­£ç¡®ï¼Ÿ ```c //æ³¨æ„å­—ç¬¦å’Œå­—ç¬¦ä¸²çš„å¼•å· //æ³¨æ„éšå¼è½¬æ¢ char a[]={\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,0} å­—ç¬¦ä¸²ç›¸å…³ \u0026lt;stdio.h\u0026gt; printf() %s\nsprintf() 1 2 3 4 5 6 7 8 int sprintf( char *str, const char *format, ... ); char buffer[50]; int n, a = 5, b = 3; n = sprintf(buffer, \u0026#34;%d plus %d is %d\u0026#34;, a, b, a+b); // n å®é™…é•¿åº¦13 //buffer=\u0026#34;5 plus 3 is 8\u0026#34; puts() puts stops printing when it meets \u0026lsquo;\\0\u0026rsquo;.\nscanf() %s è¯»åˆ°ç©ºæ ¼åœæ­¢ %ns è¯»åˆ°ç©ºæ ¼/è¯»nä¸ªå­—ç¬¦åœæ­¢ gets() è¯»ä¸€æ•´è¡Œï¼Œå­—ç¬¦æ•°ç»„å¼€å°äº†å¯èƒ½è¶Šç•Œ\nfgets() fgets(your_line, sizeof(your_line), stdin)\nåˆ©ç”¨sizeof ï¼Œé˜²æ­¢è¶Šç•Œ\nå­—ç¬¦ä¸²ç›¸å…³ \u0026lt;string.h\u0026gt; strlen() length of str, not including \u0026lsquo;\\0\u0026rsquo;;\nstrcpy(destination,source) å­—ç¬¦ä¸²èµ‹å€¼è¦strcpyï¼Œåˆ«ç›´æ¥ç­‰äºå·èµ‹å€¼\ncopy string from source to destination(åŒ…æ‹¬\u0026rsquo;\\0\u0026rsquo;)\nå°å¿ƒè¶Šç•Œ\nstrncpy(destination, source, n) å¤åˆ¶å‰nä¸ªå­—ç¬¦ï¼Œæœ€åè‡ªåŠ¨åŠ ä¸Š\u0026rsquo;\\0\u0026rsquo;\nstrcmp(str1, str2) é€ä½æ¯”è¾ƒasciiï¼Œç›´åˆ°æŸä¸€ä½asciiä¸ä¸€æ ·ï¼Œstr1\u0026gt;str2 è¿”å› 1ï¼Œç›¸ç­‰è¿”å›0ï¼Œå…¶ä½™-1\nstrncmp(str1, str2, n) å‰nä¸ª\nstrcat(destination, source); è¿æ¥ï¼ŒåŠ åœ¨destä¸Šï¼Œå°å¿ƒè¶Šç•Œ\nå­—ç¬¦ä¸²ç›¸å…³ \u0026lt;stdlib.h\u0026gt; atoi(str) str-\u0026gt;int\næ”¯æŒæ­£è´Ÿå·\nå–å‰é¢å¯ä»¥è½¬æ¢çš„ï¼Œåˆ°éæ•°å­—å­—ç¬¦åœæ­¢(æ— è§†ç©ºæ ¼) ex. atoi(\u0026quot;-10aaa\u0026quot;)=-10\natof(str) â€¢ Same as atoi\nâ€¢ Space, +, - are acceptable\nâ€¢ An E or e (exponent) is acceptable\nâ€¢ A decimal point is acceptable\nç›¸å…³ç®—æ³•ï¼ˆä»…ä½œäº†è§£ï¼‰ BFï¼ŒBKï¼ŒKMPï¼ŒBM å‰ç¼€æ ‘ åç¼€æ ‘ ACè‡ªåŠ¨æœº å…¶å®ƒ åŸºç¡€è¯­æ³• å‡½æ•° å‡½æ•°çš„å£°æ˜ å¦‚æœå‡½æ•°æ”¾äºmainå‡½æ•°åé¢/å¤šæ–‡ä»¶ï¼Œéœ€è¦æå‰å£°æ˜ å£°æ˜æ—¶å‚æ•°çš„åç§°å¹¶ä¸é‡è¦ï¼Œåªæœ‰å‚æ•°çš„ç±»å‹æ˜¯å¿…éœ€çš„ï¼Œå› æ­¤ä»¥ä¸‹éƒ½æ˜¯éƒ½æ˜¯æœ‰æ•ˆå£°æ˜ 1 2 int max(int, int); int max(int a, int b); void æ— è¿”å›å€¼ è¿”å›å¤šä¸ªå€¼ åˆ©ç”¨æŒ‡é’ˆ å½¢å¼å‚æ•° è¯¦è§ä½œç”¨åŸŸ ä¼ é€’æ•°ç»„ ä¼ ä¸€ä¸ªæŒ‡é’ˆ ä¼ ä¸å®šé•¿æ•°ç»„(ex. int a[],å¦‚æœäºŒç»´éœ€è¦æŒ‡å®šç¬¬äºŒç»´åº¦ï¼Œint a[][3]) ä¼ å®šé•¿æ•°ç»„(int a[20]) #defineå‡½æ•° 1 2 #define MAX(a,b) a\u0026gt;b?a:b #define SQ(x) x*x ä½œç”¨åŸŸ 3 types åœ¨å‡½æ•°æˆ–å—å†…éƒ¨çš„å±€éƒ¨å˜é‡,åœ¨æ‰€æœ‰å‡½æ•°å¤–éƒ¨çš„å…¨å±€å˜é‡,åœ¨å½¢å¼å‚æ•°çš„å‡½æ•°å‚æ•°å®šä¹‰ä¸­\nsmall has big å°å¯ä»¥æ”¹å¤§çš„ï¼Œå¤§ä¸èƒ½æ”¹å°çš„\nå½¢å‚åŒåæ›¿ä»£ï¼ˆå°å¸¦å¤§ï¼‰ ä½†æ˜¯åœ¨å‡½æ•°å†…ï¼Œå¦‚æœä¸¤ä¸ªåå­—ç›¸åŒï¼Œä¼šä½¿ç”¨å±€éƒ¨å˜é‡å€¼ï¼Œå…¨å±€å˜é‡ä¸ä¼šè¢«ä½¿ç”¨\né€’å½’ æ‡‚å¾—éƒ½æ‡‚ â€”â€”ä½šå è‡ªé¡¶å‘ä¸‹,åˆ©ç”¨ç³»ç»Ÿæ ˆ\nç»å…¸é¢˜ æ–æ³¢é‚£å¥‘ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int Fibonacci(int n){ if (n\u0026lt;=2){ return 1; } return Fibonacci(n-1)+Fibonacci(n-2); } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;%d\u0026#34;,Fibonacci(n)); return 0; } å‘½ä»¤è¡Œå‚æ•° 1 2 3 int main(int argc, char *argv[] ){ return 0; } argc å­˜æ”¾å‘½ä»¤è¡Œå‚æ•°çš„ä¸ªæ•° *argv[] ä»argv[1]å¼€å§‹å­˜æ”¾æ¯ä¸€ä¸ªå‚æ•°çš„æŒ‡é’ˆï¼Œç¬¬ä¸€ä¸ªå³argv[0]å­˜æ”¾ç¨‹åºå å¤šæ–‡ä»¶ æ„æˆ å®æ–‡ä»¶ï¼ˆxxx.hï¼‰ æ–‡ä»¶å­˜æ”¾å£°æ˜\nxxx.c æ–‡ä»¶å­˜æ”¾å‡½æ•°\nä¸»å‡½æ•°é‡Œ #include\u0026quot;xxx.h\u0026quot;\nè¿›é˜¶è¯­æ³• æŒ‡é’ˆ ç»“æ„ä½“ ç»“æ„ä½“å®šä¹‰ä¸åˆå§‹åŒ– 1 2 3 4 5 6 7 8 9 10 11 12 13 //ä¸€ä¸ªå®Œæ•´ç»“æ„ä½“çš„example struct tag1{ int a; char b[30]; }variable1={1,\u0026#34;ssss\u0026#34;}; struct tag1 variable2; typedef struct{ float f; }tag2; tag2 variable3; ï¼ï¼ï¼æ³¨æ„ï¼ï¼ï¼\næ— è®ºå¦‚ä½•structç»“å°¾å¿…é¡»æœ‰åˆ†å· typedefæ ¼å¼å›ºå®šï¼Œä¸‹é¢ä¸æ˜¯å˜é‡è€Œæ˜¯æ ‡ç­¾ å¦‚æœå˜é‡å·²ç»å£°æ˜ï¼Œå°±ä¸èƒ½è¿›è¡Œåˆå§‹åŒ– 1 2 3 4 5 6 7 8 9 10 11 //æ— typedefæ—¶ä¸‹é¢ä¸€å®šæ˜¯å˜é‡ï¼ˆæ— æ ‡ç­¾ï¼‰ struct { int a; }VARIABLE; //ä¸‹é¢ä¸€å®šæ˜¯tag //tag ä¸èƒ½æ”¾ä¸Šé¢ //å®è´¨ typedef struct{int a;} TAG; //ç±»åŒ typedef unsigned char UC; typedef struct{ int a; }TAG; ç»“æ„ä½“å†…éƒ¨å…ƒç´ èµ‹å€¼ 1 2 3 4 5 6 7 8 9 struct day{ char feeling[100]; int time; }today; today.time=222; strcpy(today.feeling,\u0026#34;dddd\u0026#34;); struct day yesterday={\u0026#34;good\u0026#34;,221}; ç»“æ„ä½“æŒ‡é’ˆ æ¥ç€ä¸Šæ–‡å®šä¹‰çš„ç»“æ„ä½“\n1 2 3 struct day *check; check=\u0026amp;today printf(\u0026#34;%s\u0026#34;,check-\u0026gt;feeling); ç»“æ„ä½“æ•°ç»„ æ¥ç€ä¸Šæ–‡å®šä¹‰çš„ç»“æ„ä½“\n1 2 3 4 5 6 struct day holiday[60]; int i; for(i=0;i\u0026lt;60;i++){ strcpy(holiday[i].feeling,happy); holiday[i].time=i; } æšä¸¾ç±»å‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 enum week { MON=1, TUE, WED, THU, FRI, SAT, SUN }day; day=MON; printf(\u0026#34;%d\u0026#34;,day); //è‹¥ä¸åˆå§‹åŒ–MONï¼Œé»˜è®¤ç¬¬ä¸€ä¸ªæ˜¯ 0 //æ³¨æ„ï¼šç¬¬ä¸€ä¸ªæšä¸¾æˆå‘˜çš„é»˜è®¤å€¼ä¸ºæ•´å‹çš„ 0ï¼Œåç»­æšä¸¾æˆå‘˜çš„å€¼åœ¨å‰ä¸€ä¸ªæˆå‘˜ä¸ŠåŠ  1ã€‚ //å¦‚æœæˆ‘ä»¬æŠŠç¬¬3ä¸ªæšä¸¾æˆå‘˜çš„å€¼å®šä¹‰ä¸º 9ï¼Œç¬¬4ä¸ªå°±ä¸º 10ï¼Œä»¥æ­¤ç±»æ¨ï¼Œç¬¬2ä¸ªä¾ç„¶ä¸º1ã€‚ //å¯ä»¥å’Œæ•´å½¢å¼ºåˆ¶è½¬åŒ– int a=1; days=(enum week)a; //days=MON åŠ¨æ€å†…å­˜ å…¥é—¨çº§åŸºç¡€ç®—æ³• æ•°å­¦ æ±‚è´¨æ•° äº†è§£æœ´ç´ è´¨æ•°åˆ¤å®šå³å¯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // æœ´ç´ è´¨æ•°åˆ¤å®š /* å·²ç»å£°æ˜è¿‡ #define true 1 #define false 0 */ int check(int a){ if (a\u0026lt;2){ return false; } int i; for(i=2;i*i\u0026lt;a;i++){ if (a%i==0){ return false; } } return true; } æœ€å¤§å…¬çº¦æ•°\näº†è§£æ¬§å‡ é‡Œå¾—ç®—æ³•å³å¯\n1 2 3 4 int gcd(int a,int b){ if (b==0) return a; return gcd(b, a % b); } æœ€å°å…¬å€æ•°\n$lcm(a,b)gcd(a,b)=ab$\nå…ˆæ±‚å‡ºgcdå³å¯\né«˜ç²¾åº¦ï¼ˆäº†è§£åŠ æ³•å‡æ³•å³å¯ï¼‰\næ’åº ç¨³å®šæ’åº ä¸ç¨³å®šæ’åº è®¡æ•°æ’åº æ¡¶æ’åº qsort() åŒæŒ‡é’ˆ åŒå‘ é€†å‘ æ»‘çª— ","date":"2023-05-30T00:00:00Z","image":"https://picx.zhimg.com/80/v2-905bb346af5546905d0eae5178eeb7ad_720w.webp?source=1940ef5c","permalink":"https://open17.github.io/CpHugo/p/cstart/","title":"Cè¯­è¨€å¿«é€Ÿå…¥é—¨"},{"content":"å‰è¨€ é¢˜ç›®åˆ†å¸ƒï¼šç®€å•ï¼Œä¸­ç­‰ï¼Œä¸­ç­‰ï¼Œå›°éš¾ T3æ€è·¯æƒ³é”™åç‰¢ï¼Œå†™å‡ºT4åæ‰å†™å‡ºT3\nT1 å­—ç¬¦ä¸²ä¸­æœ€å¤§çš„ 3 ä½ç›¸åŒæ•°å­— ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² num ï¼Œè¡¨ç¤ºä¸€ä¸ªå¤§æ•´æ•°ã€‚å¦‚æœä¸€ä¸ªæ•´æ•°æ»¡è¶³ä¸‹è¿°æ‰€æœ‰æ¡ä»¶ï¼Œåˆ™è®¤ä¸ºè¯¥æ•´æ•°æ˜¯ä¸€ä¸ª ä¼˜è´¨æ•´æ•° ï¼š\nè¯¥æ•´æ•°æ˜¯ num çš„ä¸€ä¸ªé•¿åº¦ä¸º 3 çš„ å­å­—ç¬¦ä¸² ã€‚ è¯¥æ•´æ•°ç”±å”¯ä¸€ä¸€ä¸ªæ•°å­—é‡å¤ 3 æ¬¡ç»„æˆã€‚ ä»¥å­—ç¬¦ä¸²å½¢å¼è¿”å› æœ€å¤§çš„ä¼˜è´¨æ•´æ•° ã€‚å¦‚æœä¸å­˜åœ¨æ»¡è¶³è¦æ±‚çš„æ•´æ•°ï¼Œåˆ™è¿”å›ä¸€ä¸ªç©ºå­—ç¬¦ä¸² \u0026quot;\u0026quot; ã€‚\næ³¨æ„ï¼š\nå­å­—ç¬¦ä¸² æ˜¯å­—ç¬¦ä¸²ä¸­çš„ä¸€ä¸ªè¿ç»­å­—ç¬¦åºåˆ—ã€‚ num æˆ–ä¼˜è´¨æ•´æ•°ä¸­å¯èƒ½å­˜åœ¨ å‰å¯¼é›¶ ã€‚\nç¤ºä¾‹ 1ï¼š\n1 2 3 4 è¾“å…¥ï¼šnum = \u0026#34;6777133339\u0026#34; è¾“å‡ºï¼š\u0026#34;777\u0026#34; è§£é‡Šï¼šnum ä¸­å­˜åœ¨ä¸¤ä¸ªä¼˜è´¨æ•´æ•°ï¼š\u0026#34;777\u0026#34; å’Œ \u0026#34;333\u0026#34; ã€‚ \u0026#34;777\u0026#34; æ˜¯æœ€å¤§çš„é‚£ä¸ªï¼Œæ‰€ä»¥è¿”å› \u0026#34;777\u0026#34; ã€‚ ç¤ºä¾‹ 2ï¼š\n1 2 3 è¾“å…¥ï¼šnum = \u0026#34;2300019\u0026#34; è¾“å‡ºï¼š\u0026#34;000\u0026#34; è§£é‡Šï¼š\u0026#34;000\u0026#34; æ˜¯å”¯ä¸€ä¸€ä¸ªä¼˜è´¨æ•´æ•°ã€‚ ç¤ºä¾‹ 3ï¼š\n1 2 3 è¾“å…¥ï¼šnum = \u0026#34;42352338\u0026#34; è¾“å‡ºï¼š\u0026#34;\u0026#34; è§£é‡Šï¼šä¸å­˜åœ¨é•¿åº¦ä¸º 3 ä¸”ä»…ç”±ä¸€ä¸ªå”¯ä¸€æ•°å­—ç»„æˆçš„æ•´æ•°ã€‚å› æ­¤ï¼Œä¸å­˜åœ¨ä¼˜è´¨æ•´æ•°ã€‚ æç¤ºï¼š\n1 2 3 \u0026lt;= num.length \u0026lt;= 1000 num ä»…ç”±æ•°å­—ï¼ˆ0 - 9ï¼‰ç»„æˆ æ€è·¯ æ¨¡æ‹Ÿ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: string largestGoodInteger(string num) { int l=2; int p=-1; int ans=-1; while(l\u0026lt;num.size()){ if(num[l-2]==num[l-1]\u0026amp;\u0026amp;num[l-1]==num[l]){ if(p\u0026lt;(num[l]-\u0026#39;0\u0026#39;)){ p=num[l]-\u0026#39;0\u0026#39;; ans=l; } l+=3; } else{ l++; } } if(ans==-1)return \u0026#34;\u0026#34;; return num.substr(ans-2,3); } }; T22265. ç»Ÿè®¡å€¼ç­‰äºå­æ ‘å¹³å‡å€¼çš„èŠ‚ç‚¹æ•° ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ‰¾å‡ºå¹¶è¿”å›æ»¡è¶³è¦æ±‚çš„èŠ‚ç‚¹æ•°ï¼Œè¦æ±‚èŠ‚ç‚¹çš„å€¼ç­‰äºå…¶ å­æ ‘ ä¸­å€¼çš„ å¹³å‡å€¼ ã€‚\næ³¨æ„ï¼š\nn ä¸ªå…ƒç´ çš„å¹³å‡å€¼å¯ä»¥ç”± n ä¸ªå…ƒç´  æ±‚å’Œ ç„¶åå†é™¤ä»¥ n ï¼Œå¹¶ å‘ä¸‹èˆå…¥ åˆ°æœ€è¿‘çš„æ•´æ•°ã€‚ root çš„ å­æ ‘ ç”± root å’Œå®ƒçš„æ‰€æœ‰åä»£ç»„æˆã€‚\nç¤ºä¾‹ 1ï¼š 1 2 3 4 5 6 7 8 è¾“å…¥ï¼šroot = [4,8,5,0,1,null,6] è¾“å‡ºï¼š5 è§£é‡Šï¼š å¯¹å€¼ä¸º 4 çš„èŠ‚ç‚¹ï¼šå­æ ‘çš„å¹³å‡å€¼ (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4 ã€‚ å¯¹å€¼ä¸º 5 çš„èŠ‚ç‚¹ï¼šå­æ ‘çš„å¹³å‡å€¼ (5 + 6) / 2 = 11 / 2 = 5 ã€‚ å¯¹å€¼ä¸º 0 çš„èŠ‚ç‚¹ï¼šå­æ ‘çš„å¹³å‡å€¼ 0 / 1 = 0 ã€‚ å¯¹å€¼ä¸º 1 çš„èŠ‚ç‚¹ï¼šå­æ ‘çš„å¹³å‡å€¼ 1 / 1 = 1 ã€‚ å¯¹å€¼ä¸º 6 çš„èŠ‚ç‚¹ï¼šå­æ ‘çš„å¹³å‡å€¼ 6 / 1 = 6 ã€‚ ç¤ºä¾‹ 2ï¼š 1 2 3 è¾“å…¥ï¼šroot = [1] è¾“å‡ºï¼š1 è§£é‡Šï¼šå¯¹å€¼ä¸º 1 çš„èŠ‚ç‚¹ï¼šå­æ ‘çš„å¹³å‡å€¼ 1 / 1 = 1ã€‚ æç¤ºï¼š\n1 2 æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ [1, 1000] å†… 0 \u0026lt;= Node.val \u0026lt;= 1000 æ€è·¯ æŒ‰è¦æ±‚dfså³å¯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ typedef pair\u0026lt;int,int\u0026gt; pii; class Solution { public: int cnt=0; int averageOfSubtree(TreeNode* root) { dfs(root); return cnt; } pii dfs(TreeNode *node){ int ans=node-\u0026gt;val; int num=1; if(node-\u0026gt;left){ pii a=dfs(node-\u0026gt;left); ans+=a.first; num+=a.second; } if(node-\u0026gt;right){ pii a=dfs(node-\u0026gt;right); ans+=a.first; num+=a.second; } if(ans/num==node-\u0026gt;val){ cnt++; } return make_pair(ans,num); } }; T3 ç»Ÿè®¡æ‰“å­—æ–¹æ¡ˆæ•° Alice åœ¨ç»™ Bob ç”¨æ‰‹æœºæ‰“å­—ã€‚æ•°å­—åˆ°å­—æ¯çš„ å¯¹åº” å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ ä¸ºäº† æ‰“å‡º ä¸€ä¸ªå­—æ¯ï¼ŒAlice éœ€è¦ æŒ‰ å¯¹åº”å­—æ¯ i æ¬¡ï¼Œi æ˜¯è¯¥å­—æ¯åœ¨è¿™ä¸ªæŒ‰é”®ä¸Šæ‰€å¤„çš„ä½ç½®ã€‚ æ¯”æ–¹è¯´ï¼Œä¸ºäº†æŒ‰å‡ºå­—æ¯ \u0026rsquo;s\u0026rsquo; ï¼ŒAlice éœ€è¦æŒ‰ \u0026lsquo;7\u0026rsquo; å››æ¬¡ã€‚ç±»ä¼¼çš„ï¼Œ Alice éœ€è¦æŒ‰ \u0026lsquo;5\u0026rsquo; ä¸¤æ¬¡å¾—åˆ°å­—æ¯ \u0026lsquo;k\u0026rsquo; ã€‚ æ³¨æ„ï¼Œæ•°å­— \u0026lsquo;0\u0026rsquo; å’Œ \u0026lsquo;1\u0026rsquo; ä¸æ˜ å°„åˆ°ä»»ä½•å­—æ¯ï¼Œæ‰€ä»¥ Alice ä¸ ä½¿ç”¨å®ƒä»¬ã€‚ ä½†æ˜¯ï¼Œç”±äºä¼ è¾“çš„é”™è¯¯ï¼ŒBob æ²¡æœ‰æ”¶åˆ° Alice æ‰“å­—çš„å­—æ¯ä¿¡æ¯ï¼Œåè€Œæ”¶åˆ°äº† æŒ‰é”®çš„å­—ç¬¦ä¸²ä¿¡æ¯ ã€‚\næ¯”æ–¹è¯´ï¼ŒAlice å‘å‡ºçš„ä¿¡æ¯ä¸º \u0026ldquo;bob\u0026rdquo; ï¼ŒBob å°†æ”¶åˆ°å­—ç¬¦ä¸² \u0026ldquo;2266622\u0026rdquo; ã€‚ ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² pressedKeys ï¼Œè¡¨ç¤º Bob æ”¶åˆ°çš„å­—ç¬¦ä¸²ï¼Œè¯·ä½ è¿”å› Alice æ€»å…±å¯èƒ½å‘å‡ºå¤šå°‘ç§æ–‡å­—ä¿¡æ¯ ã€‚\nç”±äºç­”æ¡ˆå¯èƒ½å¾ˆå¤§ï¼Œå°†å®ƒå¯¹ 109 + 7 å–ä½™ åè¿”å›ã€‚\nç¤ºä¾‹ 1ï¼š\n1 2 3 4 5 6 è¾“å…¥ï¼špressedKeys = \u0026#34;22233\u0026#34; è¾“å‡ºï¼š8 è§£é‡Šï¼š Alice å¯èƒ½å‘å‡ºçš„æ–‡å­—ä¿¡æ¯åŒ…æ‹¬ï¼š \u0026#34;aaadd\u0026#34;, \u0026#34;abdd\u0026#34;, \u0026#34;badd\u0026#34;, \u0026#34;cdd\u0026#34;, \u0026#34;aaae\u0026#34;, \u0026#34;abe\u0026#34;, \u0026#34;bae\u0026#34; å’Œ \u0026#34;ce\u0026#34; ã€‚ ç”±äºæ€»å…±æœ‰ 8 ç§å¯èƒ½çš„ä¿¡æ¯ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å› 8 ã€‚ ç¤ºä¾‹ 2ï¼š\n1 2 3 4 5 è¾“å…¥ï¼špressedKeys = \u0026#34;222222222222222222222222222222222222\u0026#34; è¾“å‡ºï¼š82876089 è§£é‡Šï¼š æ€»å…±æœ‰ 2082876103 ç§ Alice å¯èƒ½å‘å‡ºçš„æ–‡å­—ä¿¡æ¯ã€‚ ç”±äºæˆ‘ä»¬éœ€è¦å°†ç­”æ¡ˆå¯¹ 109 + 7 å–ä½™ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å› 2082876103 % (109 + 7) = 82876089 ã€‚ æç¤ºï¼š\n1 2 1 \u0026lt;= pressedKeys.length \u0026lt;= 105 pressedKeys åªåŒ…å«æ•°å­— \u0026#39;2\u0026#39; åˆ° \u0026#39;9\u0026#39; ã€‚ æ€è·¯ è¿™é¢˜å†™å®ŒT4å›æ¥çœ‹æ‰å†™å‡ºæ¥ ä¸éš¾çœ‹å‡ºæˆ‘ä»¬è¦è¿›è¡Œåˆ†ç»„è®¡ç®—(è¿ç»­ç›¸åŒçš„å­—æ¯åŒ–ä¸ºä¸€ç»„)ï¼Œå¹¶æ ¹æ®ä¹˜æ³•åŸåˆ™è®¡ç®—æœ€ç»ˆç»“æœ æœ€å¼€å§‹ä¸€ç›´æƒ³æ‰¾å‡ºæ•°å­¦è§„å¾‹ç®—å‡ºæ¯ä¸€ç»„(å¦å¤–æ¯”èµ›è¿˜æœ‰ä¸€ä¸ªé”™è¯¯å°±æ˜¯æ²¡å‘ç°7ï¼Œ9ä¸åŒæœ‰å››ç§å¯èƒ½) åæ¥å°è¯•è®°å¿†åŒ–æœç´¢\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution: def countTexts(self, pressedKeys: str) -\u0026gt; int: mod=int(1e9+7) @cache def dfs(i,size,t): if i==size: return 1 elif i\u0026gt;size: return 0 s=0 for k in range(i+1,i+4+t): s+=dfs(k,size,t) return s s=pressedKeys[0] pressedKeys+=\u0026#39;1\u0026#39; cnt=0 ans=1 for i in pressedKeys: if i!=s: t=0 if s==\u0026#39;7\u0026#39; or s==\u0026#39;9\u0026#39;: t=1 ans*=dfs(0,cnt,t) #xxx cnt=1 s=i else: cnt+=1 return ans%mod ç«Ÿç„¶MLEäº†ï¼Œæ— å¦¨æ”¹æˆé€’æ¨å½¢å¼+é¢„å¤„ç†å…¨éƒ¨\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 size=100009 a=[0]*size b=[0]*size for i in range(100000,-1,-1): if i==100000: a[i]=1 else: a[i]=a[i+1]+a[i+2]+a[i+3] for i in range(100000,-1,-1): if i==100000: b[i]=1 else: b[i]=b[i+1]+b[i+2]+b[i+3]+b[i+4] class Solution: def countTexts(self, pressedKeys: str) -\u0026gt; int: mod=int(1e9+7) s=pressedKeys[0] pressedKeys+=\u0026#39;1\u0026#39; cnt=0 ans=1 for i in pressedKeys: if i!=s: t=0 if s==\u0026#39;7\u0026#39; or s==\u0026#39;9\u0026#39;: ans*=b[100000-cnt] else: ans*=a[100000-cnt] cnt=1 s=i else: cnt+=1 return ans%mod ä½†æ˜¯è¿˜æ˜¯MLEï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ ç­”æ¡ˆæ˜¯ï¼šbä¸­çš„æ•°ä¼šå¾ˆå¤§å¾ˆå¤§ï¼Œå æ®å†…å­˜å¤§ æœ¬æ¥ç”¨pyå°±æ˜¯ä¸ºäº†é¿å…é«˜ç²¾åº¦ï¼Œæ‰€ä»¥ä¸€ç›´æ‡’å¾—åˆ†æ­¥å–æ¨¡ï¼Œæ‰€ä»¥MLEäº†ï¼Œè¿™ä¸ªæ˜¯çœŸçš„éš¾æ‰¾å‡ºæ¥ åŠ å…¥åˆ†æ­¥å–æ¨¡ACäº†\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 size=10**5 mod=int(1e9+7) a=[0]*(size+4) b=[0]*(size+5) for i in range(size,-1,-1): if i==size: a[i]=1 else: a[i]=(a[i+1]+a[i+2]+a[i+3])%mod a[i]%=mod for i in range(size,-1,-1): if i==size: b[i]=1 else: b[i]=(b[i+1]+b[i+2]+b[i+3]+b[i+4])%mod b[i]%=mod class Solution: def countTexts(self, pressedKeys: str) -\u0026gt; int: s=pressedKeys[0] pressedKeys+=\u0026#39;1\u0026#39; cnt=0 ans=1 for i in pressedKeys: if i!=s: t=0 if s==\u0026#39;7\u0026#39; or s==\u0026#39;9\u0026#39;: ans*=b[size-cnt] else: ans*=a[size-cnt] cnt=1 s=i else: cnt+=1 return ans%mod T4 æ£€æŸ¥æ˜¯å¦æœ‰åˆæ³•æ‹¬å·å­—ç¬¦ä¸²è·¯å¾„ ä¸€ä¸ªæ‹¬å·å­—ç¬¦ä¸²æ˜¯ä¸€ä¸ª éç©º ä¸”åªåŒ…å« \u0026lsquo;(\u0026rsquo; å’Œ \u0026lsquo;)\u0026rsquo; çš„å­—ç¬¦ä¸²ã€‚å¦‚æœä¸‹é¢ ä»»æ„ æ¡ä»¶ä¸º çœŸ ï¼Œé‚£ä¹ˆè¿™ä¸ªæ‹¬å·å­—ç¬¦ä¸²å°±æ˜¯ åˆæ³•çš„ ã€‚\nå­—ç¬¦ä¸²æ˜¯ () ã€‚ å­—ç¬¦ä¸²å¯ä»¥è¡¨ç¤ºä¸º ABï¼ˆA è¿æ¥ Bï¼‰ï¼ŒA å’Œ B éƒ½æ˜¯åˆæ³•æ‹¬å·åºåˆ—ã€‚ å­—ç¬¦ä¸²å¯ä»¥è¡¨ç¤ºä¸º (A) ï¼Œå…¶ä¸­ A æ˜¯åˆæ³•æ‹¬å·åºåˆ—ã€‚ ç»™ä½ ä¸€ä¸ª m x n çš„æ‹¬å·ç½‘æ ¼å›¾çŸ©é˜µ grid ã€‚ç½‘æ ¼å›¾ä¸­ä¸€ä¸ª åˆæ³•æ‹¬å·è·¯å¾„ æ˜¯æ»¡è¶³ä»¥ä¸‹æ‰€æœ‰æ¡ä»¶çš„ä¸€æ¡è·¯å¾„ï¼š\nè·¯å¾„å¼€å§‹äºå·¦ä¸Šè§’æ ¼å­ (0, 0) ã€‚ è·¯å¾„ç»“æŸäºå³ä¸‹è§’æ ¼å­ (m - 1, n - 1) ã€‚ è·¯å¾„æ¯æ¬¡åªä¼šå‘ ä¸‹ æˆ–è€…å‘ å³ ç§»åŠ¨ã€‚ è·¯å¾„ç»è¿‡çš„æ ¼å­ç»„æˆçš„æ‹¬å·å­—ç¬¦ä¸²æ˜¯ åˆæ³• çš„ã€‚ å¦‚æœç½‘æ ¼å›¾ä¸­å­˜åœ¨ä¸€æ¡ åˆæ³•æ‹¬å·è·¯å¾„ ï¼Œè¯·è¿”å› true ï¼Œå¦åˆ™è¿”å› false ã€‚\nç¤ºä¾‹ 1ï¼š 1 2 3 4 5 6 è¾“å…¥ï¼šgrid = [[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;],[\u0026#34;)\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;)\u0026#34;],[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;)\u0026#34;],[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;,\u0026#34;)\u0026#34;]] è¾“å‡ºï¼štrue è§£é‡Šï¼šä¸Šå›¾å±•ç¤ºäº†ä¸¤æ¡è·¯å¾„ï¼Œå®ƒä»¬éƒ½æ˜¯åˆæ³•æ‹¬å·å­—ç¬¦ä¸²è·¯å¾„ã€‚ ç¬¬ä¸€æ¡è·¯å¾„å¾—åˆ°çš„åˆæ³•å­—ç¬¦ä¸²æ˜¯ \u0026#34;()(())\u0026#34; ã€‚ ç¬¬äºŒæ¡è·¯å¾„å¾—åˆ°çš„åˆæ³•å­—ç¬¦ä¸²æ˜¯ \u0026#34;((()))\u0026#34; ã€‚ æ³¨æ„å¯èƒ½æœ‰å…¶ä»–çš„åˆæ³•æ‹¬å·å­—ç¬¦ä¸²è·¯å¾„ã€‚ ç¤ºä¾‹ 2ï¼š\n1 2 3 è¾“å…¥ï¼šgrid = [[\u0026#34;)\u0026#34;,\u0026#34;)\u0026#34;],[\u0026#34;(\u0026#34;,\u0026#34;(\u0026#34;]] è¾“å‡ºï¼šfalse è§£é‡Šï¼šä¸¤æ¡å¯è¡Œè·¯å¾„åˆ†åˆ«å¾—åˆ° \u0026#34;))(\u0026#34; å’Œ \u0026#34;)((\u0026#34; ã€‚ç”±äºå®ƒä»¬éƒ½ä¸æ˜¯åˆæ³•æ‹¬å·å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬è¿”å› false ã€‚ æç¤ºï¼š\n1 2 3 4 m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 100 grid[i][j] è¦ä¹ˆæ˜¯ \u0026#39;(\u0026#39; ï¼Œè¦ä¹ˆæ˜¯ \u0026#39;)\u0026#39; ã€‚ æ€è·¯ ä¸€çœ¼dpï¼Œç”¨æ•°å€¼æ¨¡æ‹Ÿæ‹¬å·è€Œéæ ˆï¼Œå¿«é€ŸAC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution: def hasValidPath(self, grid: List[List[str]]) -\u0026gt; bool: @cache def dfs(i,j,s): # print(i,j,s) if i\u0026gt;=len(grid)-1 and j\u0026gt;=len(grid[0])-1: # print(s) return s==0 a=False if j\u0026lt;len(grid[0])-1: if grid[i][j+1]==\u0026#39;)\u0026#39; and s\u0026gt;0: a|= dfs(i,j+1,s-1) elif grid[i][j+1]==\u0026#39;(\u0026#39;: a|= dfs(i,j+1,s+1) if i\u0026lt;len(grid)-1: if grid[i+1][j]==\u0026#39;)\u0026#39; and s\u0026gt;0: a|= dfs(i+1,j,s-1) elif grid[i+1][j]==\u0026#39;(\u0026#39;: a|= dfs(i+1,j,s+1) return a if grid[0][0]!=\u0026#39;(\u0026#39;: return False return dfs(0,0,1) ","date":"2023-05-29T00:00:00Z","image":"https://pic.lingkou.xyz/1651221841-OkHrex-1760-360%20Cider.png","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-292/","title":"lc weekly contest 292"},{"content":"Topics1 Logic and proofs Set, functions, sequences, and summations Counting Relations Graph theory Tree Boolean algebra Logic and Proofs Propositional logic Truth table (Given a proposition, draw the truth table)\nLogical operators Conjunction âˆ§\nDisjunction âˆ¨\nExclusive OR âŠ• Implication $â†’$\nPropositional equivalence Laws De Morganâ€™s laws (å¦å®šæ‹†æ‹¬å·å–å) Distributive(åˆ†é…) laws $p\\rightarrow q=\\neg p \\vee q$ Tautology and contradiction Given two propositions, prove they are equivalent\nPredicates Universal quantification\nExistential quantification\nTranslate a sentence to a logical expression\nProofs Inference rules æ¨ç†è§„åˆ™ (prove or disprove an argument)\nè‚¯å®šå‰ä»¶æ¨ç† $p\\wedge( p \\rightarrow q)\\Rightarrow q$ å¦å®šåä»¶æ¨ç† $\\neg q \\wedge(p\\rightarrow q) \\Rightarrow \\neg p$ æå–ä¸‰æ®µè®º å‡è¯´æ¼”ç»æ¨ç† å½’ç»“æ¨ç† Argument Valid argument Invalid argument Proof methods direct proofs Indirect proofs Proof by contraposition(ééå) Proof by contradiction\nExistence proof (constructive and non-constructive) Uniqueness proof (two steps) å­˜åœ¨ä¸”ä»…å­˜åœ¨ä¸€ä¸ª å‡è®¾å­˜åœ¨ä¸¤ä¸ªæ»¡è¶³,ç„¶åè¯æ˜ä¸¤ä¸ªç›¸ç­‰\nSets, Functions, Sequences and Summations Sets Subset å­é›†,ç©ºé›†,éç©ºçœŸå­é›†,çœŸå­é›†\nPowerset (P(S)=Aâˆ£AâŠ†S)\nCardinality é›†åˆå…ƒç´ ä¸ªæ•°ï¼Œç‰¹åˆ«æœ‰|P(S)|=$2^n$\nCartesian product(ç¬›å¡å°”ç§¯) å…¨éƒ¨ç»„åˆ\nSet operations Set identity (prove two sets are the same)\nDe Morganâ€™s Law Laws and membership table 0,1è¡¨\nFunctions One-to-one functions (injection) å•å°„,ä¸€ä¸€å¯¹åº”\nOnto functions (surjection) æ»¡å°„,å…¨éƒ¨yéƒ½æœ‰x\nOne-to-one and onto functions (bijection) å•åŠ æ»¡\nSpecial functions Ceiling functionä¸Š Floor functionä¸‹ Sequences and summations Countings Rules Product rule ä¹˜æ³•åŸç†\nSum rule åŠ æ³•åŸç†\néš”æ¿æ³• Principles Inclusion-exclusion principle å®¹æ–¥\nPigeonhole principle æŠ½å±‰åŸç†(ceil(n/k))\nPermutation and combination $$P(n,r)=n!/(n-r)!$$\nRecurrence relation $$C(n,r)=n!/[(n-r)!*r!]$$\nConstruct a recurrence relation Solve a recurrence relation $$ a_n=c_1a_{n-1}+c_2a_{n-2} \\ r^2-c_1r-c_2=0 \\ a_n=k_1r_1^n+k_2r_2^n $$\nRelations Representing relations There are several other ways to represent relations\nTables Matrices Graphs Relations on a set A relation on the set is a relation from ğ´ to ğ´\nReflexive (a,a) belongs to R for all element in A\nSymmetric å¯¹ç§°\nAnti-symmetric åå¯¹ç§°\nTransitive ä¼ é€’æ€§\nEquivalence relation Equivalence relation and Partition Equivalence relation â‡” Partition\nProve a relation is an equivalence relation. Reflexive Symmetric Transitive\nGiven an equivalence relation, list equivalent classes (give the partition) Graph Theory Graph Definition G=(V,E)\nRepresenting graphs (adjacency matrix, adjacency list, and sketch) Isomorphism é‚»æ¥çŸ©é˜µ $bijection f:V_1 \\rightarrow V_2: \\forall a,b \\in V_1((a,b)\\in E_1 \\leftrightarrow (f(a),f(b))\\in E_2) $ Eular path and Eular circuit containing every edge (simple path)\næ¬§æ‹‰å›è·¯:each vertex has even degree\næ¬§æ‹‰è·¯å¾„åœ¨è¿é€šmulti: exactly 2 vertices of odd degree\nHamilton path and Hamilton circuit each vertex once\nOreâ€™s theorem If for every pair of nonadjacent vertices u and v in the simple graph G with n vertices, deg(u) + deg(v) â‰¥ n ,then has a Hamilton circuit.\nDiracâ€™s theorem If the degree of each vertex is great than or equals n/2 in the connected simple graph G with n vertices where n â‰¥ 3, then G has a Hamilton circuit.\nPlanar graphs r=eâ€“v+2\nEulerâ€™s Formula G is a connected planar simple graph\nv â‰¥ 3, then e â‰¤ 3v â€“ 6 G has a vertex of degree not exceeding 5 if v\u0026gt;=3 and no circuits of length 3,then e\u0026lt;=2v-4 Trees Tree traversal Preorder traversal ä¸­å·¦1å³\nIn-order traversal å·¦1ä¸­å³\nPost-order traversal å·¦1å³ä¸­\nExpression forms (conversion among the different forms) å…³é”® Internal vertices(éå¶å­èŠ‚ç‚¹) represent operations\nLeaves(å¶å­èŠ‚ç‚¹) represent the variables or numbers\nInfix prefix postfix Spanning tree DFS å›æº¯(å­—æ¯åº)\nBFS éƒ½èµ°(å­—æ¯åº,ä¸é‡å¤)\nBoolean Algebra Boolean expressions . ä¸ product + æˆ– sum - é complement Boolean identities æ¢æˆé€»è¾‘è¡¨è¾¾å¼å†æ¢å›æ¥è®°å¿†\nmin-term(æœ€å°é¡¹) A min-term of Boolean variables x1, x2, â‹¯ ,xn is a Boolean product of literals2 y1y2 , â‹¯ , yn where yi (1 â‰¤ i â‰¤ n ) is either xi or complement of xi Each min-term has exactly one literal for every variable.\nDNF ä»»ä½•å‘½é¢˜å…¬å¼ï¼Œæœ€ç»ˆéƒ½èƒ½å¤ŸåŒ–æˆ ( A 1 âˆ§ A 2 ) âˆ¨ ( A 3 âˆ§ A 4 )çš„å½¢å¼ï¼Œè¿™ç§å…ˆ âˆ§ åˆ å– å† âˆ¨ æ å– çš„èŒƒå¼ï¼Œè¢«ç§°ä¸º â€œæå–èŒƒå¼â€ã€‚\nDNF is the unique sum of min-terms of the variables in the expression,Also called sum of products expansion\nSOPæ˜¯DNFçš„åŒ–ç®€ï¼ŒDNFæ˜¯SOPçš„æ‰©å±•3\nMaxterms(æœ€å¤§é¡¹) A max-term of Boolean variables x1, x2, â‹¯ , is the sum of literals y1 + y2+, â‹¯ ,yn + where (1 â‰¤ i â‰¤ n) is either xi or complement of xi\nCNF ä»»ä½•å‘½é¢˜å…¬å¼ï¼Œæœ€ç»ˆéƒ½èƒ½å¤ŸåŒ–æˆ ( A 1 âˆ¨ A 2 ) âˆ§ ( A 3 âˆ¨ A 4 ) çš„å½¢å¼ï¼Œè¿™ç§å…ˆ âˆ¨ æ å– å† âˆ§ åˆ å– çš„èŒƒå¼ï¼Œè¢«ç§°ä¸º â€œ åˆå–èŒƒå¼â€ã€‚\nPOSåŒä¸Š\nIf we have DNF for $\\overline F $, then get CNF from $\\overline{\\overline F} $\nEquivalence of expressions Funtion completeness can represent {+ . â€”â€”} using Operate O\nLogic circuits Logic gates Logic circuits Karnaugh maps4 1ã€å–å¤§ä¸å–å°ï¼Œåœˆè¶Šå¤§ï¼Œæ¶ˆå»çš„å˜é‡è¶Šå¤šï¼Œä¸é¡¹è¶Šç®€å•ï¼Œèƒ½ç”»å…¥å¤§åœˆå°±ä¸ç”»å…¥å°åœˆï¼›\n2ã€åœˆæ•°è¶Šå°‘ï¼ŒåŒ–ç®€åçš„ä¸é¡¹å°±è¶Šå°‘ï¼›\n3ã€ä¸€ä¸ªæœ€å°é¡¹å¯ä»¥é‡å¤ä½¿ç”¨ï¼Œå³åªè¦éœ€è¦ï¼Œä¸€ä¸ªæ–¹æ ¼å¯ä»¥åŒæ—¶è¢«å¤šåœˆæ‰€åœˆ\nSteps in designing a logic circuit æ¨èé˜…è¯»\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA literal is a Boolean variable or its complement.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\næœ‰äº›ä¹¦ä¸Šå®šä¹‰DNFä¸ºSOPï¼Œå°†SOPçš„æ‰©å±•å«åšCDNFï¼Œæœ¬æ–‡ä¸é‡‡ç”¨è¿™ç§å®šä¹‰\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nå¯ä»¥å‚è€ƒ\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-05-29T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/dm-quick-review/","title":"ç¦»æ•£æ•°å­¦çŸ¥è¯†é€ŸæŸ¥"},{"content":"å‰è¨€ é¢˜ç›®åˆ†å¸ƒ:ç®€å•,ä¸­ç­‰,å›°éš¾,å›°éš¾\nT3å¡å¸¸åå¤§ç‰¢\nT1 å°†æ‰¾åˆ°çš„å€¼ä¹˜ä»¥ 2 ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå¦ç»™ä½ ä¸€ä¸ªæ•´æ•° original ï¼Œè¿™æ˜¯éœ€è¦åœ¨ nums ä¸­æœç´¢çš„ç¬¬ä¸€ä¸ªæ•°å­—ã€‚\næ¥ä¸‹æ¥ï¼Œä½ éœ€è¦æŒ‰ä¸‹è¿°æ­¥éª¤æ“ä½œï¼š\nå¦‚æœåœ¨ nums ä¸­æ‰¾åˆ° original ï¼Œå°† original ä¹˜ä»¥ 2 ï¼Œå¾—åˆ°æ–° originalï¼ˆå³ï¼Œä»¤ original = 2 * originalï¼‰ã€‚\nå¦åˆ™ï¼Œåœæ­¢è¿™ä¸€è¿‡ç¨‹ã€‚ åªè¦èƒ½åœ¨æ•°ç»„ä¸­æ‰¾åˆ°æ–° original ï¼Œå°±å¯¹æ–° original ç»§ç»­ é‡å¤ è¿™ä¸€è¿‡ç¨‹ã€‚\nè¿”å› original çš„ æœ€ç»ˆ å€¼ã€‚\nç¤ºä¾‹ 1ï¼š\n1 2 è¾“å…¥ï¼šnums = [5,3,6,1,12], original = 3 è¾“å‡ºï¼š24 è§£é‡Šï¼š\n3 èƒ½åœ¨ nums ä¸­æ‰¾åˆ°ã€‚3 * 2 = 6 ã€‚ 6 èƒ½åœ¨ nums ä¸­æ‰¾åˆ°ã€‚6 * 2 = 12 ã€‚ 12 èƒ½åœ¨ nums ä¸­æ‰¾åˆ°ã€‚12 * 2 = 24 ã€‚ 24 ä¸èƒ½åœ¨ nums ä¸­æ‰¾åˆ°ã€‚å› æ­¤ï¼Œè¿”å› 24 ã€‚ ç¤ºä¾‹ 2ï¼š\n1 2 è¾“å…¥ï¼šnums = [2,7,9], original = 4 è¾“å‡ºï¼š4 è§£é‡Šï¼š\n4 ä¸èƒ½åœ¨ nums ä¸­æ‰¾åˆ°ã€‚å› æ­¤ï¼Œè¿”å› 4 ã€‚ æç¤ºï¼š\n1 2 1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i], original \u0026lt;= 1000 æ€è·¯ ç”±äºæ•°æ®èŒƒå›´å¾ˆå°,æ‰€ä»¥æ€ä¹ˆå†™éƒ½è¡Œ\nè¿™é‡Œçš„äºŒåˆ†è¿˜å¯ä»¥ç»§ç»­ä¼˜åŒ– è¿™é“é¢˜è¿˜å¯ä»¥ç”¨å“ˆå¸Œè¡¨è¾¾åˆ°è¿‘ä¼¼O(n) ç”šè‡³å¯ä»¥ç”¨ä½è¿ç®—è¾¾åˆ°ä¸¥æ ¼O(n)1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #define debug(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; class Solution { public: int findFinalValue(vector\u0026lt;int\u0026gt;\u0026amp; nums, int original) { sort(nums.begin(),nums.end()); auto s=nums.begin(); // debug(0,nums.size()-1,nums) while(1){ int x=lower_bound(nums.begin(),nums.end(),original)-nums.begin(); if (x\u0026gt;=nums.size()||nums[x]!=original){ break; } original*=2; } return original; } }; T2 åˆ†ç»„å¾—åˆ†æœ€é«˜çš„æ‰€æœ‰ä¸‹æ ‡ ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„äºŒè¿›åˆ¶æ•°ç»„ nums ï¼Œæ•°ç»„é•¿åº¦ä¸º n ã€‚nums å¯ä»¥æŒ‰ä¸‹æ ‡ iï¼ˆ 0 \u0026lt;= i \u0026lt;= n ï¼‰æ‹†åˆ†æˆä¸¤ä¸ªæ•°ç»„ï¼ˆå¯èƒ½ä¸ºç©ºï¼‰ï¼šnumsleft å’Œ numsright ã€‚\nnumsleft åŒ…å« nums ä¸­ä»ä¸‹æ ‡ 0 åˆ° i - 1 çš„æ‰€æœ‰å…ƒç´ ï¼ˆåŒ…æ‹¬ 0 å’Œ i - 1 ï¼‰ï¼Œè€Œ numsright åŒ…å« nums ä¸­ä»ä¸‹æ ‡ i åˆ° n - 1 çš„æ‰€æœ‰å…ƒç´ ï¼ˆåŒ…æ‹¬ i å’Œ n - 1 ï¼‰ã€‚\nå¦‚æœ i == 0 ï¼Œnumsleft ä¸º ç©º ï¼Œè€Œ numsright å°†åŒ…å« nums ä¸­çš„æ‰€æœ‰å…ƒç´ ã€‚\nå¦‚æœ i == n ï¼Œnumsleft å°†åŒ…å« nums ä¸­çš„æ‰€æœ‰å…ƒç´ ï¼Œè€Œ numsright ä¸º ç©º ã€‚\nä¸‹æ ‡ i çš„ åˆ†ç»„å¾—åˆ† ä¸º numsleft ä¸­ 0 çš„ä¸ªæ•°å’Œ numsright ä¸­ 1 çš„ä¸ªæ•°ä¹‹ å’Œ ã€‚\nè¿”å› åˆ†ç»„å¾—åˆ† æœ€é«˜ çš„ æ‰€æœ‰ä¸åŒä¸‹æ ‡ ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚\nç¤ºä¾‹ 1ï¼š\n1 2 è¾“å…¥ï¼šnums = [0,0,1,0] è¾“å‡ºï¼š[2,4] è§£é‡Šï¼šæŒ‰ä¸‹æ ‡åˆ†ç»„\n0 ï¼šnumsleft ä¸º [] ã€‚numsright ä¸º [0,0,1,0] ã€‚å¾—åˆ†ä¸º 0 + 1 = 1 ã€‚ 1 ï¼šnumsleft ä¸º [0] ã€‚numsright ä¸º [0,1,0] ã€‚å¾—åˆ†ä¸º 1 + 1 = 2 ã€‚ 2 ï¼šnumsleft ä¸º [0,0] ã€‚numsright ä¸º [1,0] ã€‚å¾—åˆ†ä¸º 2 + 1 = 3 ã€‚ 3 ï¼šnumsleft ä¸º [0,0,1] ã€‚numsright ä¸º [0] ã€‚å¾—åˆ†ä¸º 2 + 0 = 2 ã€‚ 4 ï¼šnumsleft ä¸º [0,0,1,0] ã€‚numsright ä¸º [] ã€‚å¾—åˆ†ä¸º 3 + 0 = 3 ã€‚ ä¸‹æ ‡ 2 å’Œ 4 éƒ½å¯ä»¥å¾—åˆ°æœ€é«˜çš„åˆ†ç»„å¾—åˆ† 3 ã€‚ æ³¨æ„ï¼Œç­”æ¡ˆ [4,2] ä¹Ÿè¢«è§†ä¸ºæ­£ç¡®ç­”æ¡ˆã€‚ ç¤ºä¾‹ 2ï¼š\n1 2 è¾“å…¥ï¼šnums = [0,0,0] è¾“å‡ºï¼š[3] è§£é‡Šï¼šæŒ‰ä¸‹æ ‡åˆ†ç»„\n0 ï¼šnumsleft ä¸º [] ã€‚numsright ä¸º [0,0,0] ã€‚å¾—åˆ†ä¸º 0 + 0 = 0 ã€‚ 1 ï¼šnumsleft ä¸º [0] ã€‚numsright ä¸º [0,0] ã€‚å¾—åˆ†ä¸º 1 + 0 = 1 ã€‚ 2 ï¼šnumsleft ä¸º [0,0] ã€‚numsright ä¸º [0] ã€‚å¾—åˆ†ä¸º 2 + 0 = 2 ã€‚ 3 ï¼šnumsleft ä¸º [0,0,0] ã€‚numsright ä¸º [] ã€‚å¾—åˆ†ä¸º 3 + 0 = 3 ã€‚ åªæœ‰ä¸‹æ ‡ 3 å¯ä»¥å¾—åˆ°æœ€é«˜çš„åˆ†ç»„å¾—åˆ† 3 ã€‚ ç¤ºä¾‹ 3ï¼š\n1 2 è¾“å…¥ï¼šnums = [1,1] è¾“å‡ºï¼š[0] è§£é‡Šï¼šæŒ‰ä¸‹æ ‡åˆ†ç»„\n0 ï¼šnumsleft ä¸º [] ã€‚numsright ä¸º [1,1] ã€‚å¾—åˆ†ä¸º 0 + 2 = 2 ã€‚ 1 ï¼šnumsleft ä¸º [1] ã€‚numsright ä¸º [1] ã€‚å¾—åˆ†ä¸º 0 + 1 = 1 ã€‚ 2 ï¼šnumsleft ä¸º [1,1] ã€‚numsright ä¸º [] ã€‚å¾—åˆ†ä¸º 0 + 0 = 0 ã€‚ åªæœ‰ä¸‹æ ‡ 0 å¯ä»¥å¾—åˆ°æœ€é«˜çš„åˆ†ç»„å¾—åˆ† 2 ã€‚ æç¤ºï¼š\n1 2 3 n == nums.length 1 \u0026lt;= n \u0026lt;= 105 nums[i] ä¸º 0 æˆ– 1 æ€è·¯ å†™çš„æ—¶å€™æ²¡ä»”ç»†çœ‹é¢˜ç›®,é•¿åº¦ä¸ºnåº”è¯¥æœ‰n+1ä¸­é€‰æ‹©æƒ…å†µ,åæ¥æ”¹åŠ¨çš„æ—¶å€™æ²¡æœ‰ä¿æŒä¸å˜é‡,è°ƒå‚è°ƒäº†åŠå¤© æ€è·¯: ç»´æŠ¤å‰ç¼€å’Œå³å¯,ç”±sumå‡å»å¾—å‡ºåç¼€ å½“ç„¶å¯ä»¥ç»´æŠ¤å‰åç¼€,å¥½å†™ä¸€ç‚¹ è¿™é‡Œè¿˜å¯ä»¥å‹ç¼©æˆä¸€æ¬¡éå†2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define debug(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; const int N=1e5+2; int b[N]; class Solution { public: vector\u0026lt;int\u0026gt; maxScoreIndices(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans=0; FOR(i,0,nums.size()){ //å·¦è¾¹1çš„ä¸ªæ•° b[i+1]=b[i]+nums[i]; ans+=nums[i]; } // debug(0,nums.size(),b) int max_=0; FOR(i,0,nums.size()+1){ max_=max(max_, i-b[i]+ans-b[i] ); } vector\u0026lt;int\u0026gt; res; FOR(i,0,nums.size()+1){ if(i-b[i]+ans-b[i]==max_)res.push_back(i); } return res; } }; T3 æŸ¥æ‰¾ç»™å®šå“ˆå¸Œå€¼çš„å­ä¸² ç»™å®šæ•´æ•° p å’Œ m ï¼Œä¸€ä¸ªé•¿åº¦ä¸º k ä¸”ä¸‹æ ‡ä» 0 å¼€å§‹çš„å­—ç¬¦ä¸² s çš„å“ˆå¸Œå€¼æŒ‰ç…§å¦‚ä¸‹å‡½æ•°è®¡ç®—ï¼š\nhash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + \u0026hellip; + val(s[k-1]) * pk-1) mod m.\nå…¶ä¸­ val(s[i]) è¡¨ç¤º s[i] åœ¨å­—æ¯è¡¨ä¸­çš„ä¸‹æ ‡ï¼Œä» val(\u0026lsquo;a\u0026rsquo;) = 1 åˆ° val(\u0026lsquo;z\u0026rsquo;) = 26 ã€‚\nç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s å’Œæ•´æ•° powerï¼Œmoduloï¼Œk å’Œ hashValue ã€‚è¯·ä½ è¿”å› s ä¸­ ç¬¬ä¸€ä¸ª é•¿åº¦ä¸º k çš„ å­ä¸² sub ï¼Œæ»¡è¶³ hash(sub, power, modulo) == hashValue ã€‚\næµ‹è¯•æ•°æ®ä¿è¯ä¸€å®š å­˜åœ¨ è‡³å°‘ä¸€ä¸ªè¿™æ ·çš„å­ä¸²ã€‚\nå­ä¸² å®šä¹‰ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²ä¸­è¿ç»­éç©ºå­—ç¬¦ç»„æˆçš„åºåˆ—ã€‚\nç¤ºä¾‹ 1ï¼š\n1 2 3 4 è¾“å…¥ï¼šs = \u0026#34;leetcode\u0026#34;, power = 7, modulo = 20, k = 2, hashValue = 0 è¾“å‡ºï¼š\u0026#34;ee\u0026#34; è§£é‡Šï¼š\u0026#34;ee\u0026#34; çš„å“ˆå¸Œå€¼ä¸º hash(\u0026#34;ee\u0026#34;, 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 ã€‚ \u0026#34;ee\u0026#34; æ˜¯é•¿åº¦ä¸º 2 çš„ç¬¬ä¸€ä¸ªå“ˆå¸Œå€¼ä¸º 0 çš„å­ä¸²ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å› \u0026#34;ee\u0026#34; ã€‚ ç¤ºä¾‹ 2ï¼š\n1 2 3 4 5 6 è¾“å…¥ï¼šs = \u0026#34;fbxzaad\u0026#34;, power = 31, modulo = 100, k = 3, hashValue = 32 è¾“å‡ºï¼š\u0026#34;fbx\u0026#34; è§£é‡Šï¼š\u0026#34;fbx\u0026#34; çš„å“ˆå¸Œå€¼ä¸º hash(\u0026#34;fbx\u0026#34;, 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32 ã€‚ \u0026#34;bxz\u0026#34; çš„å“ˆå¸Œå€¼ä¸º hash(\u0026#34;bxz\u0026#34;, 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32 ã€‚ \u0026#34;fbx\u0026#34; æ˜¯é•¿åº¦ä¸º 3 çš„ç¬¬ä¸€ä¸ªå“ˆå¸Œå€¼ä¸º 32 çš„å­ä¸²ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å› \u0026#34;fbx\u0026#34; ã€‚ æ³¨æ„ï¼Œ\u0026#34;bxz\u0026#34; çš„å“ˆå¸Œå€¼ä¹Ÿä¸º 32 ï¼Œä½†æ˜¯å®ƒåœ¨å­—ç¬¦ä¸²ä¸­æ¯” \u0026#34;fbx\u0026#34; æ›´æ™šå‡ºç°ã€‚ æç¤ºï¼š\n1 2 3 4 5 1 \u0026lt;= k \u0026lt;= s.length \u0026lt;= 2 * 104 1 \u0026lt;= power, modulo \u0026lt;= 109 0 \u0026lt;= hashValue \u0026lt; modulo s åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚ æµ‹è¯•æ•°æ®ä¿è¯ä¸€å®š å­˜åœ¨ æ»¡è¶³æ¡ä»¶çš„å­ä¸²ã€‚ æ€è·¯ å…ˆå†™ä¸€ä¸ªæš´åŠ›æ»‘çª—è§£æ³•\n1 2 3 4 5 6 7 8 9 10 11 class Solution: def subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -\u0026gt; str: def f(p,m,start,end): hashv=0 for i in range(start,end+1): hashv+=(ord(s[i])-ord(\u0026#39;a\u0026#39;)+1)*(p**(i-start)) return hashv%m for i in range(k-1,len(s)): if f(power,modulo,i-k+1,i)==hashValue: return s[i-k+1:i+1] return s æ¯«æ— æ‚¬å¿µçš„Täº† å°†få°è¯•æ”¹æˆ\n1 2 3 4 5 6 def f(p,m,start,end): hashv=0 for i in range(start,end+1): hashv+=(ord(s[i])-ord(\u0026#39;a\u0026#39;)+1)*(p**(i-start))%m hashv%=m return hashv%m è¿˜æ˜¯T,ä¸è¿‡è¿™ä¹Ÿå¾ˆæ­£å¸¸\nå¦‚ä½•ä¼˜åŒ–?ä¸éš¾çœ‹å‡ºåœ¨æ±‚få‡½æ•°æ˜¯å¯ä»¥ä¼˜åŒ–çš„,få¯ä»¥ç”±ä¸Šä¸ªä¸€ä¸ªçš„fè½¬ç§»è¿‡æ¥ å³ä¸Šä¸€ä¸ªfå‡å»ç¬¬ä¸€é¡¹å†é™¤ä»¥påœ¨åŠ ä¸Šæœ€æ–°ä¸€é¡¹å³å¯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution: def subStrHash(self, s: str, p: int, m: int, k: int, hashValue: int) -\u0026gt; str: hashv=0 for i in range(k-1,len(s)): if i==k-1: for j in range(i-k+1,i+1): hashv+=(ord(s[j])-ord(\u0026#39;a\u0026#39;)+1)*(p**(j-i+k-1)) else: hashv-=(ord(s[i-k])-ord(\u0026#39;a\u0026#39;)+1) hashv//=p hashv+=(ord(s[i])-ord(\u0026#39;a\u0026#39;)+1)*(p**(k-1)) if hashv%m==hashValue: return s[i-k+1:i+1] #print(hashv,i) return s è¿˜æ˜¯T? å› ä¸ºé™¤æ³•å–ä½™ä¸æ’ç­‰,ä¸èƒ½åˆ†æ­¥ä¼˜åŒ– é‚£æ€ä¹ˆæ”¹å‘¢ å€’å™å³å¯,é¡ºä¾¿åŠ å…¥ç‚¹ä¼˜åŒ–\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def subStrHash(self, s: str, p: int, m: int, k: int, hashValue: int) -\u0026gt; str: hashv=0 bas=p**(k-1) a=b=0 for i in range(len(s)-1,k-2,-1): if i==len(s)-1: for j in range(i-k+1,i+1): hashv+=(ord(s[j])-ord(\u0026#39;a\u0026#39;)+1)*(p**(j-i+k-1))%m hashv%=m else: hashv-=((ord(s[i+1])-ord(\u0026#39;a\u0026#39;)+1)*bas)%m hashv%=m hashv*=p hashv%=m hashv+=(ord(s[i-k+1])-ord(\u0026#39;a\u0026#39;)+1)%m hashv%=m if hashv==hashValue: a=i-k+1 b=i+1 return s[a:b] ä½†æ˜¯,æœ€åç‰¢çš„æ—¶åˆ»æ¥äº†,è¿™æ ·è¿˜æ˜¯T å¿«é€Ÿå¹‚çš„æ—¶å€™ä¹Ÿå¼•å…¥å–ä½™,æœ€ç»ˆACäº†\nAC code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def subStrHash(self, s: str, p: int, m: int, k: int, hashValue: int) -\u0026gt; str: hashv=0 bas=pow(p,k - 1,m) a=b=0 for i in range(len(s)-1,k-2,-1): if i==len(s)-1: for j in range(i-k+1,i+1): hashv+=(ord(s[j])-ord(\u0026#39;a\u0026#39;)+1)*pow(p,j-i+k-1,m)%m hashv%=m else: hashv-=((ord(s[i+1])-ord(\u0026#39;a\u0026#39;)+1)*bas)%m hashv%=m hashv*=p hashv%=m hashv+=(ord(s[i-k+1])-ord(\u0026#39;a\u0026#39;)+1)%m hashv%=m if hashv==hashValue: a=i-k+1 b=i+1 return s[a:b] å…¶å®è¿™é“é¢˜ä¸»è¦å¡æ—¶é—´å¤æ‚åº¦çš„åœ¨å¹‚å‡½æ•°è¿™é‡Œ,æ‰€ä»¥åªä¼˜åŒ–å¹‚å‡½æ•°,ä¸ä¼˜åŒ–åé¢çš„è½¬ç§»ä¹Ÿèƒ½å¡è¿‡å»(å³æ— éœ€å€’å™)3\nT4 å­—ç¬¦ä¸²åˆ†ç»„ ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„å­—ç¬¦ä¸²æ•°ç»„ words ã€‚æ¯ä¸ªå­—ç¬¦ä¸²éƒ½åªåŒ…å« å°å†™è‹±æ–‡å­—æ¯ ã€‚words ä¸­ä»»æ„ä¸€ä¸ªå­ä¸²ä¸­ï¼Œæ¯ä¸ªå­—æ¯éƒ½è‡³å¤šåªå‡ºç°ä¸€æ¬¡ã€‚\nå¦‚æœé€šè¿‡ä»¥ä¸‹æ“ä½œä¹‹ä¸€ï¼Œæˆ‘ä»¬å¯ä»¥ä» s1 çš„å­—æ¯é›†åˆå¾—åˆ° s2 çš„å­—æ¯é›†åˆï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§°è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸º å…³è”çš„ ï¼š\nå¾€ s1 çš„å­—æ¯é›†åˆä¸­æ·»åŠ ä¸€ä¸ªå­—æ¯ã€‚\nä» s1 çš„å­—æ¯é›†åˆä¸­åˆ å»ä¸€ä¸ªå­—æ¯ã€‚\nå°† s1 ä¸­çš„ä¸€ä¸ªå­—æ¯æ›¿æ¢æˆå¦å¤–ä»»æ„ä¸€ä¸ªå­—æ¯,ä¹Ÿå¯ä»¥æ›¿æ¢ä¸ºè¿™ä¸ªå­—æ¯æœ¬èº«ã€‚ æ•°ç»„ words å¯ä»¥åˆ†ä¸ºä¸€ä¸ªæˆ–è€…å¤šä¸ªæ— äº¤é›†çš„ ç»„ ã€‚å¦‚æœä¸€ä¸ªå­—ç¬¦ä¸²ä¸å¦ä¸€ä¸ªå­—ç¬¦ä¸²å…³è”ï¼Œé‚£ä¹ˆå®ƒä»¬åº”å½“å±äºåŒä¸€ä¸ªç»„ã€‚\næ³¨æ„ï¼Œä½ éœ€è¦ç¡®ä¿åˆ†å¥½ç»„åï¼Œä¸€ä¸ªç»„å†…çš„ä»»ä¸€å­—ç¬¦ä¸²ä¸å…¶ä»–ç»„çš„å­—ç¬¦ä¸²éƒ½ä¸å…³è”ã€‚å¯ä»¥è¯æ˜åœ¨è¿™ä¸ªæ¡ä»¶ä¸‹ï¼Œåˆ†ç»„æ–¹æ¡ˆæ˜¯å”¯ä¸€çš„ã€‚\nè¯·ä½ è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º 2 çš„æ•°ç»„ ans ï¼š\nans[0] æ˜¯ words åˆ†ç»„åçš„ æ€»ç»„æ•° ã€‚\nans[1] æ˜¯å­—ç¬¦ä¸²æ•°ç›®æœ€å¤šçš„ç»„æ‰€åŒ…å«çš„å­—ç¬¦ä¸²æ•°ç›®ã€‚\nç¤ºä¾‹ 1ï¼š\n1 2 è¾“å…¥ï¼šwords = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;ab\u0026#34;,\u0026#34;cde\u0026#34;] è¾“å‡ºï¼š[2,3] è§£é‡Šï¼š\nwords[0] å¯ä»¥å¾—åˆ° words[1] ï¼ˆå°† \u0026lsquo;a\u0026rsquo; æ›¿æ¢ä¸º \u0026lsquo;b\u0026rsquo;ï¼‰å’Œ words[2] ï¼ˆæ·»åŠ  \u0026lsquo;b\u0026rsquo;ï¼‰ã€‚æ‰€ä»¥ words[0] ä¸ words[1] å’Œ words[2] å…³è”ã€‚ words[1] å¯ä»¥å¾—åˆ° words[0] ï¼ˆå°† \u0026lsquo;b\u0026rsquo; æ›¿æ¢ä¸º \u0026lsquo;a\u0026rsquo;ï¼‰å’Œ words[2] ï¼ˆæ·»åŠ  \u0026lsquo;a\u0026rsquo;ï¼‰ã€‚æ‰€ä»¥ words[1] ä¸ words[0] å’Œ words[2] å…³è”ã€‚ words[2] å¯ä»¥å¾—åˆ° words[0] ï¼ˆåˆ å» \u0026lsquo;b\u0026rsquo;ï¼‰å’Œ words[1] ï¼ˆåˆ å» \u0026lsquo;a\u0026rsquo;ï¼‰ã€‚æ‰€ä»¥ words[2] ä¸ words[0] å’Œ words[1] å…³è”ã€‚ words[3] ä¸ words ä¸­å…¶ä»–å­—ç¬¦ä¸²éƒ½ä¸å…³è”ã€‚ æ‰€ä»¥ï¼Œwords å¯ä»¥åˆ†æˆ 2 ä¸ªç»„ [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;ab\u0026rdquo;] å’Œ [\u0026ldquo;cde\u0026rdquo;] ã€‚æœ€å¤§çš„ç»„å¤§å°ä¸º 3 ã€‚ ç¤ºä¾‹ 2ï¼š\n1 2 è¾“å…¥ï¼šwords = [\u0026#34;a\u0026#34;,\u0026#34;ab\u0026#34;,\u0026#34;abc\u0026#34;] è¾“å‡ºï¼š[1,3] è§£é‡Šï¼š\nwords[0] ä¸ words[1] å…³è”ã€‚ words[1] ä¸ words[0] å’Œ words[2] å…³è”ã€‚ words[2] ä¸ words[1] å…³è”ã€‚ ç”±äºæ‰€æœ‰å­—ç¬¦ä¸²ä¸å…¶ä»–å­—ç¬¦ä¸²éƒ½å…³è”ï¼Œæ‰€ä»¥å®ƒä»¬å…¨éƒ¨åœ¨åŒä¸€ä¸ªç»„å†…ã€‚ æ‰€ä»¥æœ€å¤§çš„ç»„å¤§å°ä¸º 3 ã€‚ æç¤ºï¼š\n1 2 3 4 1 \u0026lt;= words.length \u0026lt;= 2 * 104 1 \u0026lt;= words[i].length \u0026lt;= 26 words[i] åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚ words[i] ä¸­æ¯ä¸ªå­—æ¯æœ€å¤šåªå‡ºç°ä¸€æ¬¡ã€‚ æ€è·¯ æ²¡æ—¶é—´çœ‹äº†\nåé¢å†è¡¥ä¸Šå§ è§è¿™é‡Œ\nå¯ä»¥å‚è€ƒè¿™ä¸ªå¸–å­\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nleetcodeå®˜æ–¹è§£ç­”ä¸€æ¬¡éå†å³å¯\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nä¾‹å¦‚è¿™ä¸ªé¢„å¤„ç†å¹‚åŠ ä¸Šå…¶å®ƒå‰ªæä¹Ÿèƒ½AC\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-05-28T00:00:00Z","image":"https://pic.lingkou.xyz/1642577172-whzTsr-1760-360%20%E5%85%AD%E6%96%B9%E4%BA%91.png","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-278/","title":"lc weekly contest 278"},{"content":"ä»€ä¹ˆæ˜¯æ‘©å°”æŠ•ç¥¨ æ‘©å°”æŠ•ç¥¨æ˜¯ä¸€ç§ç”¨æ¥è§£å†³ç»å¯¹ä¼—æ•°1é—®é¢˜çš„ç®—æ³• å®ƒèƒ½ä½¿ç”¨O(1)çº§åˆ«çš„ç©ºé—´å¤æ‚åº¦æ‰¾å‡ºç»å¯¹ä¼—æ•°\nç»å…¸ä¾‹é¢˜2 ç»™å®šä¸€ä¸ªå¤§å°ä¸º n çš„æ•°ç»„ nums ï¼Œè¿”å›å…¶ä¸­çš„å¤šæ•°å…ƒç´ ã€‚å¤šæ•°å…ƒç´ æ˜¯æŒ‡åœ¨æ•°ç»„ä¸­å‡ºç°æ¬¡æ•° å¤§äº âŒŠ n/2 âŒ‹ çš„å…ƒç´ ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int t=0,cnt=0; for(auto i:nums){ if(i==t)cnt++; else if(--cnt\u0026lt;0){ t=i; cnt=1; } } return t; } }; åŒºé—´ç»å¯¹ä¼—æ•°3 è®¾è®¡ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œæœ‰æ•ˆåœ°æ‰¾åˆ°ç»™å®šå­æ•°ç»„çš„ å¤šæ•°å…ƒç´  ã€‚\nå­æ•°ç»„çš„ å¤šæ•°å…ƒç´  æ˜¯åœ¨å­æ•°ç»„ä¸­å‡ºç° threshold æ¬¡æ•°æˆ–æ¬¡æ•°ä»¥ä¸Šçš„å…ƒç´ ã€‚\nå®ç° MajorityChecker ç±»:\nMajorityChecker(int[] arr) ä¼šç”¨ç»™å®šçš„æ•°ç»„ arr å¯¹ MajorityChecker åˆå§‹åŒ–ã€‚ int query(int left, int right, int threshold) è¿”å›å­æ•°ç»„ä¸­çš„å…ƒç´  arr[left...right] è‡³å°‘å‡ºç° threshold æ¬¡æ•°ï¼Œå¦‚æœä¸å­˜åœ¨è¿™æ ·çš„å…ƒç´ åˆ™è¿”å› -1ã€‚ ç¤ºä¾‹ 1ï¼š\n1 2 3 4 5 6 7 8 9 10 è¾“å…¥: [\u0026#34;MajorityChecker\u0026#34;, \u0026#34;query\u0026#34;, \u0026#34;query\u0026#34;, \u0026#34;query\u0026#34;] [[[1, 1, 2, 2, 1, 1]], [0, 5, 4], [0, 3, 3], [2, 3, 2]] è¾“å‡ºï¼š [null, 1, -1, 2] è§£é‡Šï¼š MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]); majorityChecker.query(0,5,4); // è¿”å› 1 majorityChecker.query(0,3,3); // è¿”å› -1 majorityChecker.query(2,3,2); // è¿”å› 2 æç¤ºï¼š\n1 \u0026lt;= arr.length \u0026lt;= 2 * 104 1 \u0026lt;= arr[i] \u0026lt;= 2 * 104 0 \u0026lt;= left \u0026lt;= right \u0026lt; arr.length threshold \u0026lt;= right - left + 1 2 * threshold \u0026gt; right - left + 1 è°ƒç”¨ query çš„æ¬¡æ•°æœ€å¤šä¸º 104 å‚è€ƒ é€šä¿—æ˜“æ‡‚æ‘©å°”æŠ•ç¥¨æ³• ç®—æ³•å­¦ä¹ ç¬”è®°(78): æ‘©å°”æŠ•ç¥¨ åœ¨ä¸€ä¸ªé›†åˆä¸­ï¼Œå¦‚æœä¸€ä¸ªå…ƒç´ çš„å‡ºç°æ¬¡æ•°æ¯”å…¶ä»–æ‰€æœ‰å…ƒç´ çš„å‡ºç°æ¬¡æ•°ä¹‹å’Œè¿˜å¤šï¼Œé‚£ä¹ˆå°±ç§°å®ƒä¸ºè¿™ä¸ªé›†åˆçš„ç»å¯¹ä¼—æ•°ã€‚ç­‰ä»·åœ°è¯´ï¼Œç»å¯¹ä¼—æ•°çš„å‡ºç°æ¬¡æ•°å¤§äºæ€»å…ƒç´ æ•°çš„ä¸€åŠã€‚\u0026#160;\u0026#x21a9;\u0026#xfe0e;\né¢˜ç›®æ¥æº:https://leetcode.cn/problems/majority-element/description/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\né¢˜ç›®æ¥æºLC1157. å­æ•°ç»„ä¸­å ç»å¤§å¤šæ•°çš„å…ƒç´ \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-05-28T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/boyermoore-majority-vote-algorithm/","title":"æ‘©å°”æŠ•ç¥¨"},{"content":"å¤©æ‰ACM é¢˜ç›®æè¿° ç»™å®šä¸€ä¸ªæ•´æ•° Mï¼Œå¯¹äºä»»æ„ä¸€ä¸ªæ•´æ•°é›†åˆ Sï¼Œå®šä¹‰â€œæ ¡éªŒå€¼â€å¦‚ä¸‹:\nä»é›†åˆ S ä¸­å–å‡º M å¯¹æ•°(å³ 2Ã—M ä¸ªæ•°ï¼Œä¸èƒ½é‡å¤ä½¿ç”¨é›†åˆä¸­çš„æ•°ï¼Œå¦‚æœ S ä¸­çš„æ•´æ•°ä¸å¤Ÿ M å¯¹ï¼Œåˆ™å–åˆ°ä¸èƒ½å–ä¸ºæ­¢)ï¼Œä½¿å¾—â€œæ¯å¯¹æ•°çš„å·®çš„å¹³æ–¹â€ä¹‹å’Œæœ€å¤§ï¼Œè¿™ä¸ªæœ€å¤§å€¼å°±ç§°ä¸ºé›†åˆ S çš„â€œæ ¡éªŒå€¼â€ã€‚\nç°åœ¨ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º N çš„æ•°åˆ— A ä»¥åŠä¸€ä¸ªæ•´æ•° Tã€‚\næˆ‘ä»¬è¦æŠŠ A åˆ†æˆè‹¥å¹²æ®µï¼Œä½¿å¾—æ¯ä¸€æ®µçš„â€œæ ¡éªŒå€¼â€éƒ½ä¸è¶…è¿‡ Tã€‚\næ±‚æœ€å°‘éœ€è¦åˆ†æˆå‡ æ®µã€‚\næ ·ä¾‹ è¾“å…¥æ ·ä¾‹ï¼š\n2\n5 1 49\n8 2 1 7 9\n5 1 64\n8 2 1 7 9\nè¾“å‡ºæ ·ä¾‹ï¼š\n2\n1\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;ctime\u0026gt; using namespace std; typedef long long ll; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(ll w=(a);w\u0026lt;(n);++w) #define debug(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; #define inf 0x3f typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5e6+9; ll a[N],b[N],temp[N]; ll t; ll k,m,n; inline ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } bool check(ll l,ll last,ll r){ if(l==last){ ll x=a[l]; ll y=a[r]; temp[l]=min(x,y); temp[r]=max(x,y); ll ans=(x-y)*(x-y); return ans\u0026lt;=t; } FOR(i,last+1,r+1){ b[i]=a[i]; } sort(b+last+1,b+r+1); //merge int p1=l,p2=last+1,pp=l; while(p1\u0026lt;=last\u0026amp;\u0026amp;p2\u0026lt;=r){ if(b[p1]\u0026lt;b[p2])temp[pp++]=b[p1++]; else temp[pp++]=b[p2++]; } while(p1\u0026lt;=last)temp[pp++]=b[p1++]; while(p2\u0026lt;=r)temp[pp++]=b[p2++]; //check ll num=m; ll sums=0; ll ll=l,rr=r; while(num\u0026amp;\u0026amp;l\u0026lt;r){ num--; sums+=(temp[r]-temp[l])*(temp[r]-temp[l]); l++; r--; } //cout\u0026lt;\u0026lt;\u0026#34; l:\u0026#34;\u0026lt;\u0026lt;ll\u0026lt;\u0026lt;\u0026#34; last:\u0026#34;\u0026lt;\u0026lt;last\u0026lt;\u0026lt;\u0026#34; r:\u0026#34;\u0026lt;\u0026lt;rr\u0026lt;\u0026lt;\u0026#34; sums:\u0026#34;\u0026lt;\u0026lt;sums\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; //debug(ll,rr,temp) return sums\u0026lt;=t; } int main() { // freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); // freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); k=read(); while(k--){ n=read(); m=read(); t=read(); FOR(i,1,n+1)a[i]=read(); //strat from 1 ,[l,r+size] ll cnt=0,l=1,r=1,size=1; while(r\u0026lt;n+1){ while(size){ if(r+size\u0026lt;n+1\u0026amp;\u0026amp;check(l,r,r+size)){ r+=size; size*=2; FOR(i,l,r+1)b[i]=temp[i]; //cout\u0026lt;\u0026lt;\u0026#34;ss\u0026#34;\u0026lt;\u0026lt;endl; //debug(l,r,b) //cout\u0026lt;\u0026lt;\u0026#34;ss\u0026#34;\u0026lt;\u0026lt;endl; } else{ size/=2; } } //cout\u0026lt;\u0026lt;\u0026#34;!!!!!!!!!!!\u0026#34;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cnt++; size=1; r++; l=r; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } return 0; } stè¡¨ è¯¦è§stè¡¨æ¨¡æ¿\n","date":"2023-05-27T01:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue06/","title":"å°è“ä¹¦0X06å€å¢---å¤©æ‰ACM"},{"content":"å‰è¨€ å¾…æ›´æ–°\nT1 è´­ä¹°ä¸¤å—å·§å…‹åŠ› ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ prices ï¼Œå®ƒè¡¨ç¤ºä¸€ä¸ªå•†åº—é‡Œè‹¥å¹²å·§å…‹åŠ›çš„ä»·æ ¼ã€‚åŒæ—¶ç»™ä½ ä¸€ä¸ªæ•´æ•° money ï¼Œè¡¨ç¤ºä½ ä¸€å¼€å§‹æ‹¥æœ‰çš„é’±æ•°ã€‚\nä½ å¿…é¡»è´­ä¹° æ°å¥½ ä¸¤å—å·§å…‹åŠ›ï¼Œè€Œä¸”å‰©ä½™çš„é’±æ•°å¿…é¡»æ˜¯ éè´Ÿæ•° ã€‚åŒæ—¶ä½ æƒ³æœ€å°åŒ–è´­ä¹°ä¸¤å—å·§å…‹åŠ›çš„æ€»èŠ±è´¹ã€‚\nè¯·ä½ è¿”å›åœ¨è´­ä¹°ä¸¤å—å·§å…‹åŠ›åï¼Œæœ€å¤šèƒ½å‰©ä¸‹å¤šå°‘é’±ã€‚å¦‚æœè´­ä¹°ä»»æ„ä¸¤å—å·§å…‹åŠ›éƒ½è¶…è¿‡äº†ä½ æ‹¥æœ‰çš„é’±ï¼Œè¯·ä½ è¿”å› money ã€‚æ³¨æ„å‰©ä½™é’±æ•°å¿…é¡»æ˜¯éè´Ÿæ•°ã€‚\nç¤ºä¾‹ 1ï¼š\n1 2 3 è¾“å…¥ï¼šprices = [1,2,2], money = 3 è¾“å‡ºï¼š0 è§£é‡Šï¼šåˆ†åˆ«è´­ä¹°ä»·æ ¼ä¸º 1 å’Œ 2 çš„å·§å…‹åŠ›ã€‚ä½ å‰©ä¸‹ 3 - 3 = 0 å—é’±ã€‚æ‰€ä»¥æˆ‘ä»¬è¿”å› 0 ã€‚ ç¤ºä¾‹ 2ï¼š\n1 2 3 è¾“å…¥ï¼šprices = [3,2,3], money = 3 è¾“å‡ºï¼š3 è§£é‡Šï¼šè´­ä¹°ä»»æ„ 2 å—å·§å…‹åŠ›éƒ½ä¼šè¶…è¿‡ä½ æ‹¥æœ‰çš„é’±æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å› 3 ã€‚ æç¤ºï¼š\n1 2 3 2 \u0026lt;= prices.length \u0026lt;= 50 1 \u0026lt;= prices[i] \u0026lt;= 100 1 \u0026lt;= money \u0026lt;= 100 æ€è·¯ æ¨¡æ‹Ÿ\n1 2 3 4 5 class Solution: def buyChoco(self, prices: List[int], money: int) -\u0026gt; int: prices.sort() x=money-prices[0]+prices[1] return x if x\u0026gt;=0 else money T2 å­—ç¬¦ä¸²ä¸­çš„é¢å¤–å­—ç¬¦ ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„å­—ç¬¦ä¸² s å’Œä¸€ä¸ªå•è¯å­—å…¸ dictionary ã€‚ä½ éœ€è¦å°† s åˆ†å‰²æˆè‹¥å¹²ä¸ª äº’ä¸é‡å  çš„å­å­—ç¬¦ä¸²ï¼Œæ¯ä¸ªå­å­—ç¬¦ä¸²éƒ½åœ¨ dictionary ä¸­å‡ºç°è¿‡ã€‚s ä¸­å¯èƒ½ä¼šæœ‰ä¸€äº› é¢å¤–çš„å­—ç¬¦ ä¸åœ¨ä»»ä½•å­å­—ç¬¦ä¸²ä¸­ã€‚\nè¯·ä½ é‡‡å–æœ€ä¼˜ç­–ç•¥åˆ†å‰² s ï¼Œä½¿å‰©ä¸‹çš„å­—ç¬¦ æœ€å°‘ ã€‚\nç¤ºä¾‹ 1ï¼š\n1 2 3 è¾“å…¥ï¼šs = \u0026#34;leetscode\u0026#34;, dictionary = [\u0026#34;leet\u0026#34;,\u0026#34;code\u0026#34;,\u0026#34;leetcode\u0026#34;] è¾“å‡ºï¼š1 è§£é‡Šï¼šå°† s åˆ†æˆä¸¤ä¸ªå­å­—ç¬¦ä¸²ï¼šä¸‹æ ‡ä» 0 åˆ° 3 çš„ \u0026#34;leet\u0026#34; å’Œä¸‹æ ‡ä» 5 åˆ° 8 çš„ \u0026#34;code\u0026#34; ã€‚åªæœ‰ 1 ä¸ªå­—ç¬¦æ²¡æœ‰ä½¿ç”¨ï¼ˆä¸‹æ ‡ä¸º 4ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å› 1 ã€‚ ç¤ºä¾‹ 2ï¼š\n1 2 3 è¾“å…¥ï¼šs = \u0026#34;sayhelloworld\u0026#34;, dictionary = [\u0026#34;hello\u0026#34;,\u0026#34;world\u0026#34;] è¾“å‡ºï¼š3 è§£é‡Šï¼šå°† s åˆ†æˆä¸¤ä¸ªå­å­—ç¬¦ä¸²ï¼šä¸‹æ ‡ä» 3 åˆ° 7 çš„ \u0026#34;hello\u0026#34; å’Œä¸‹æ ‡ä» 8 åˆ° 12 çš„ \u0026#34;world\u0026#34; ã€‚ä¸‹æ ‡ä¸º 0 ï¼Œ1 å’Œ 2 çš„å­—ç¬¦æ²¡æœ‰ä½¿ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿”å› 3 ã€‚ æç¤ºï¼š\n1 2 3 4 5 1 \u0026lt;= s.length \u0026lt;= 50 1 \u0026lt;= dictionary.length \u0026lt;= 50 1 \u0026lt;= dictionary[i].length \u0026lt;= 50 dictionary[i] å’Œ s åªåŒ…å«å°å†™è‹±æ–‡å­—æ¯ã€‚ dictionary ä¸­çš„å•è¯äº’ä¸ç›¸åŒ æ€è·¯ ä¸€å¼€å§‹æ²¡çœ‹æ•°æ®å¤§å°(çœŸçš„è¦æ”¹),æ­»ç£•kmp,ç„¶åæƒ³çš„æ˜¯è´ªå¿ƒå¤„ç†é‡å é€‰æ‹©(å¾ˆæ˜æ˜¾,è‡³å°‘æˆ‘æƒ³äº†å¥½ä¹…æ²¡æ‰¾å‡ºæ¥) åæ¥å›è¿‡å¤´æ¥çœ‹æ•°æ®èŒƒå›´è¿™ä¹ˆå°,ç›´æ¥è®°å¿†åŒ–æœç´¢AC(å…¶å®è¿˜waäº†ä¸€å‘,ç”¨å›æº¯å·æ‡’æ²¡è¿‡)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution: def minExtraChar(self, s: str, dictionary: List[str]) -\u0026gt; int: ss=set(dictionary) ans=[0] @cache def dfs(i): if i\u0026gt;=len(s): return 0 res=0 for k in range(len(s)-i): if s[i:k+i+1] in ss: res=max(dfs(k+i+1)+k+1,res) else: res=max(res,dfs(k+i+1)) return res return len(s)-dfs(0) T3 ä¸€ä¸ªå°ç»„çš„æœ€å¤§å®åŠ›å€¼ ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„æ•´æ•°æ•°ç»„ nums ï¼Œå®ƒè¡¨ç¤ºä¸€ä¸ªç­çº§ä¸­æ‰€æœ‰å­¦ç”Ÿåœ¨ä¸€æ¬¡è€ƒè¯•ä¸­çš„æˆç»©ã€‚è€å¸ˆæƒ³é€‰å‡ºä¸€éƒ¨åˆ†åŒå­¦ç»„æˆä¸€ä¸ª éç©º å°ç»„ï¼Œä¸”è¿™ä¸ªå°ç»„çš„ å®åŠ›å€¼ æœ€å¤§ï¼Œå¦‚æœè¿™ä¸ªå°ç»„é‡Œçš„å­¦ç”Ÿä¸‹æ ‡ä¸º i0, i1, i2, \u0026hellip; , ik ï¼Œé‚£ä¹ˆè¿™ä¸ªå°ç»„çš„å®åŠ›å€¼å®šä¹‰ä¸º nums[i0] * nums[i1] * nums[i2] * \u0026hellip; * nums[ikâ€‹] ã€‚\nè¯·ä½ è¿”å›è€å¸ˆåˆ›å»ºçš„å°ç»„èƒ½å¾—åˆ°çš„æœ€å¤§å®åŠ›å€¼ä¸ºå¤šå°‘ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šnums = [3,-1,-5,2,5,-9]\nè¾“å‡ºï¼š1350\nè§£é‡Šï¼šä¸€ç§æ„æˆæœ€å¤§å®åŠ›å€¼å°ç»„çš„æ–¹æ¡ˆæ˜¯é€‰æ‹©ä¸‹æ ‡ä¸º [0,2,3,4,5] çš„å­¦ç”Ÿã€‚å®åŠ›å€¼ä¸º 3 * (-5) * 2 * 5 * (-9) = 1350 ï¼Œè¿™æ˜¯å¯ä»¥å¾—åˆ°çš„æœ€å¤§å®åŠ›å€¼ã€‚\nç¤ºä¾‹ 2ï¼š\nè¾“å…¥ï¼šnums = [-4,-5,-4]\nè¾“å‡ºï¼š20\nè§£é‡Šï¼šé€‰æ‹©ä¸‹æ ‡ä¸º [0, 1] çš„å­¦ç”Ÿã€‚å¾—åˆ°çš„å®åŠ›å€¼ä¸º 20 ã€‚æˆ‘ä»¬æ²¡æ³•å¾—åˆ°æ›´å¤§çš„å®åŠ›å€¼\nåæ€ å¾ˆç®€å•çš„ä¸€é“é¢˜ è¿™é‡Œç«Ÿç„¶waäº†ä¸‰å‘,ç¬¬ä¸€å‘waåœ¨å°‘æ‰“äº†ä¸€ä¸ª*å·,ç¬¬äºŒä¸‰å‘waåœ¨æ²¡æ³¨æ„å¤§å°å†™isZeroå’Œiszero æ˜æ˜æœ¬é¢˜å”¯ä¸€è¦æ€è€ƒçš„åˆ†ç±»è®¨è®ºéƒ½ä»”ç»†æ€è€ƒäº†é˜²æ­¢wa(è™½ç„¶åˆ†ç±»ä¸å¤Ÿç²¾ç®€),å´åœ¨æ‰“å­—ä¸Šè¿‡äºæ€¥èºwa\nå¯¼è‡´æ’åç‹‚æ‰ ä»¥åæ— è®ºä»£ç æœ‰å¤šç®€å•ä¸€å®šè¦è®°å¾—å…ˆæµ‹è¯•ä¸€ä¸‹èƒ½ä¸èƒ½è·‘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution: def maxStrength(self, nums: List[int]) -\u0026gt; int: ans=1 flag=0 p=[] res=1 isZero=False for i in nums: if i\u0026gt;0: ans*=i flag=1 elif i\u0026lt;0: p.append(i) else: isZero=True p.sort() size=(len(p)//2)*2 for i in range(size): res*=p[i] if flag: return res*ans elif size\u0026gt;=2: return res elif isZero: return 0 return p[0] T4 æœ€å¤§å…¬çº¦æ•°éå† ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„æ•´æ•°æ•°ç»„ nums ï¼Œä½ å¯ä»¥åœ¨ä¸€äº›ä¸‹æ ‡ä¹‹é—´éå†ã€‚å¯¹äºä¸¤ä¸ªä¸‹æ ‡ i å’Œ jï¼ˆi != jï¼‰ï¼Œå½“ä¸”ä»…å½“ gcd(nums[i], nums[j]) \u0026gt; 1 æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸¤ä¸ªä¸‹æ ‡ä¹‹é—´é€šè¡Œï¼Œå…¶ä¸­ gcd æ˜¯ä¸¤ä¸ªæ•°çš„ æœ€å¤§å…¬çº¦æ•° ã€‚\nä½ éœ€è¦åˆ¤æ–­ nums æ•°ç»„ä¸­ ä»»æ„ ä¸¤ä¸ªæ»¡è¶³ i \u0026lt; j çš„ä¸‹æ ‡ i å’Œ j ï¼Œæ˜¯å¦å­˜åœ¨è‹¥å¹²æ¬¡é€šè¡Œå¯ä»¥ä» i éå†åˆ° j ã€‚\nå¦‚æœä»»æ„æ»¡è¶³æ¡ä»¶çš„ä¸‹æ ‡å¯¹éƒ½å¯ä»¥éå†ï¼Œé‚£ä¹ˆè¿”å› true ï¼Œå¦åˆ™è¿”å› false ã€‚\nç¤ºä¾‹ 1ï¼š\n1 2 3 4 5 è¾“å…¥ï¼šnums = [2,3,6] è¾“å‡ºï¼štrue è§£é‡Šï¼šè¿™ä¸ªä¾‹å­ä¸­ï¼Œæ€»å…±æœ‰ 3 ä¸ªä¸‹æ ‡å¯¹ï¼š(0, 1) ï¼Œ(0, 2) å’Œ (1, 2) ã€‚ ä»ä¸‹æ ‡ 0 åˆ°ä¸‹æ ‡ 1 ï¼Œæˆ‘ä»¬å¯ä»¥éå† 0 -\u0026gt; 2 -\u0026gt; 1 ï¼Œæˆ‘ä»¬å¯ä»¥ä»ä¸‹æ ‡ 0 åˆ° 2 æ˜¯å› ä¸º gcd(nums[0], nums[2]) = gcd(2, 6) = 2 \u0026gt; 1 ï¼Œä»ä¸‹æ ‡ 2 åˆ° 1 æ˜¯å› ä¸º gcd(nums[2], nums[1]) = gcd(6, 3) = 3 \u0026gt; 1 ã€‚ ä»ä¸‹æ ‡ 0 åˆ°ä¸‹æ ‡ 2 ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥éå†ï¼Œå› ä¸º gcd(nums[0], nums[2]) = gcd(2, 6) = 2 \u0026gt; 1 ã€‚åŒç†ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ä»ä¸‹æ ‡ 1 åˆ° 2 å› ä¸º gcd(nums[1], nums[2]) = gcd(3, 6) = 3 \u0026gt; 1 ã€‚ ç¤ºä¾‹ 2ï¼š\n1 2 3 è¾“å…¥ï¼šnums = [3,9,5] è¾“å‡ºï¼šfalse è§£é‡Šï¼šæˆ‘ä»¬æ²¡æ³•ä»ä¸‹æ ‡ 0 åˆ° 2 ï¼Œæ‰€ä»¥è¿”å› false ã€‚ ç¤ºä¾‹ 3ï¼š\n1 2 3 è¾“å…¥ï¼šnums = [4,3,12,8] è¾“å‡ºï¼štrue è§£é‡Šï¼šæ€»å…±æœ‰ 6 ä¸ªä¸‹æ ‡å¯¹ï¼š(0, 1) ï¼Œ(0, 2) ï¼Œ(0, 3) ï¼Œ(1, 2) ï¼Œ(1, 3) å’Œ (2, 3) ã€‚æ‰€æœ‰ä¸‹æ ‡å¯¹ä¹‹é—´éƒ½å­˜åœ¨å¯è¡Œçš„éå†ï¼Œæ‰€ä»¥è¿”å› true ã€‚ æç¤ºï¼š\n1 2 1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 105 æ€è·¯ è§è¯„è®ºåŒºå§\n","date":"2023-05-27T00:00:00Z","image":"https://pic.lingkou.xyz/1683871861-YilDpq-1760-360%20%E5%AE%BD%E5%BE%B7%E6%8A%95%E8%B5%84.png","permalink":"https://open17.github.io/CpHugo/p/lc-biweekly-contest-105/","title":"lc-biweekly-contest-105"},{"content":" ç—›è‹¦T4\nT1 å…¬å› å­çš„æ•°ç›® ç»™ä½ ä¸¤ä¸ªæ­£æ•´æ•° a å’Œ b ï¼Œè¿”å› a å’Œ b çš„ å…¬ å› å­çš„æ•°ç›®ã€‚\nå¦‚æœ x å¯ä»¥åŒæ—¶æ•´é™¤ a å’Œ b ï¼Œåˆ™è®¤ä¸º x æ˜¯ a å’Œ b çš„ä¸€ä¸ª å…¬å› å­ ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼ša = 12, b = 6 è¾“å‡ºï¼š4 è§£é‡Šï¼š12 å’Œ 6 çš„å…¬å› å­æ˜¯ 1ã€2ã€3ã€6 ã€‚ ç¤ºä¾‹ 2ï¼š\nè¾“å…¥ï¼ša = 25, b = 30 è¾“å‡ºï¼š2 è§£é‡Šï¼š25 å’Œ 30 çš„å…¬å› å­æ˜¯ 1ã€5 ã€‚\næç¤ºï¼š\n1 \u0026lt;= a, b \u0026lt;= 1000\næ€è·¯ æ¨¡æ‹Ÿå³å¯\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int commonFactors(int a, int b) { int t=min(a,b); int cnt=0; for(int i=1;i\u0026lt;=t;i++){ if(a%i==0\u0026amp;\u0026amp;b%i==0)cnt++; } return cnt; } }; T2 æ²™æ¼çš„æœ€å¤§æ€»å’Œ ç»™ä½ ä¸€ä¸ªå¤§å°ä¸º m x n çš„æ•´æ•°çŸ©é˜µ grid ã€‚\næŒ‰ä»¥ä¸‹å½¢å¼å°†çŸ©é˜µçš„ä¸€éƒ¨åˆ†å®šä¹‰ä¸ºä¸€ä¸ª æ²™æ¼ ï¼š\nè¿”å›æ²™æ¼ä¸­å…ƒç´ çš„ æœ€å¤§ æ€»å’Œã€‚\næ³¨æ„ï¼šæ²™æ¼æ— æ³•æ—‹è½¬ä¸”å¿…é¡»æ•´ä¸ªåŒ…å«åœ¨çŸ©é˜µä¸­ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šgrid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]\nè¾“å‡ºï¼š30\nè§£é‡Šï¼šä¸Šå›¾ä¸­çš„å•å…ƒæ ¼è¡¨ç¤ºå…ƒç´ æ€»å’Œæœ€å¤§çš„æ²™æ¼ï¼š6 + 2 + 1 + 2 + 9 + 2 + 8 = 30 ã€‚\nç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šgrid = [[1,2,3],[4,5,6],[7,8,9]] è¾“å‡ºï¼š35 è§£é‡Šï¼šä¸Šå›¾ä¸­çš„å•å…ƒæ ¼è¡¨ç¤ºå…ƒç´ æ€»å’Œæœ€å¤§çš„æ²™æ¼ï¼š1 + 2 + 3 + 5 + 7 + 8 + 9 = 35 ã€‚\næç¤ºï¼š\n1 2 3 4 m == grid.length n == grid[i].length 3 \u0026lt;= m, n \u0026lt;= 150 0 \u0026lt;= grid[i][j] \u0026lt;= 106 æ€è·¯ æ•°æ®å°,æš´åŠ›æ¨¡æ‹Ÿä¹Ÿèƒ½ac è¿™é‡Œç”¨å‰ç¼€å’Œä¼˜åŒ–\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: long long b[153][153]; int maxSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { memset(b,0,sizeof(b)); for(int i=0;i\u0026lt;grid.size();i++){ for(int j=0;j\u0026lt;grid[0].size();j++){ b[i+1][j+1]=b[i][j+1]+b[i+1][j]+grid[i][j]-b[i][j]; } } long long ans=-1; for(int i=3;i\u0026lt;=grid.size();i++){ for(int j=3;j\u0026lt;=grid[0].size();j++){ ans=max(ans,b[i][j] - b[i-3][j] - b[i][j-3] + b[i-3][j-3]-grid[i-2][j-3]-grid[i-2][j-1]); } } return ans; } }; T3 æœ€å° XOR ç»™ä½ ä¸¤ä¸ªæ­£æ•´æ•° num1 å’Œ num2 ï¼Œæ‰¾å‡ºæ»¡è¶³ä¸‹è¿°æ¡ä»¶çš„æ•´æ•° x ï¼š\nx çš„ç½®ä½æ•°å’Œ num2 ç›¸åŒï¼Œä¸” x XOR num1 çš„å€¼ æœ€å° æ³¨æ„ XOR æ˜¯æŒ‰ä½å¼‚æˆ–è¿ç®—ã€‚\nè¿”å›æ•´æ•° x ã€‚é¢˜ç›®ä¿è¯ï¼Œå¯¹äºç”Ÿæˆçš„æµ‹è¯•ç”¨ä¾‹ï¼Œ x æ˜¯ å”¯ä¸€ç¡®å®š çš„ã€‚\næ•´æ•°çš„ ç½®ä½æ•° æ˜¯å…¶äºŒè¿›åˆ¶è¡¨ç¤ºä¸­ 1 çš„æ•°ç›®ã€‚\nç¤ºä¾‹ 1ï¼š\n1 2 3 4 5 è¾“å…¥ï¼šnum1 = 3, num2 = 5 è¾“å‡ºï¼š3 è§£é‡Šï¼š num1 å’Œ num2 çš„äºŒè¿›åˆ¶è¡¨ç¤ºåˆ†åˆ«æ˜¯ 0011 å’Œ 0101 ã€‚ æ•´æ•° 3 çš„ç½®ä½æ•°ä¸ num2 ç›¸åŒï¼Œä¸” 3 XOR 3 = 0 æ˜¯æœ€å°çš„ã€‚ ç¤ºä¾‹ 2ï¼š\n1 2 3 4 5 è¾“å…¥ï¼šnum1 = 1, num2 = 12 è¾“å‡ºï¼š3 è§£é‡Šï¼š num1 å’Œ num2 çš„äºŒè¿›åˆ¶è¡¨ç¤ºåˆ†åˆ«æ˜¯ 0001 å’Œ 1100 ã€‚ æ•´æ•° 3 çš„ç½®ä½æ•°ä¸ num2 ç›¸åŒï¼Œä¸” 3 XOR 1 = 2 æ˜¯æœ€å°çš„ã€‚ æç¤ºï¼š\n1 1 \u0026lt;= num1, num2 \u0026lt;= 109 æ€è·¯ è´ªå¿ƒ+ä½è¿ç®—\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: int lowbit(int a){ int cnt=0; while(a){ a^=(a\u0026amp;(-a)); cnt++; } return cnt; } int minimizeXor(int num1, int num2) { int cnt=lowbit(num2); int res=lowbit(num1); if(cnt==res)return num1; if(res\u0026gt;cnt){ int dif=res-cnt; int ans=0; int p=num1; while(dif){ dif--; ans+=num1\u0026amp;(-num1); num1^=(num1\u0026amp;(-num1)); } return p-ans; } int d=-1; int t=cnt-res; int ans=0; while(d\u0026lt;31\u0026amp;\u0026amp;t\u0026gt;0){ d++; if(num1\u0026amp;(1\u0026lt;\u0026lt;d)){continue;} ans+=pow(2,d); t--; } return ans+num1; } }; ç¼©å‡ç‰ˆ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int minimizeXor(int num1, int num2) { int c1 = __builtin_popcount(num1); int c2 = __builtin_popcount(num2); for (; c2 \u0026lt; c1; ++c2) num1 \u0026amp;= num1 - 1; // æœ€ä½çš„ 1 å˜æˆ 0 for (; c2 \u0026gt; c1; --c2) num1 |= num1 + 1; // æœ€ä½çš„ 0 å˜æˆ 1 return num1; } }; // ä½œè€…ï¼šendlesscheng T4 å¯¹å­—æ¯ä¸²å¯æ‰§è¡Œçš„æœ€å¤§åˆ é™¤æ•° 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ç»™ä½ ä¸€ä¸ªä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸² s ã€‚åœ¨ä¸€æ­¥æ“ä½œä¸­ï¼Œä½ å¯ä»¥ï¼š åˆ é™¤ æ•´ä¸ªå­—ç¬¦ä¸² s ï¼Œæˆ–è€… å¯¹äºæ»¡è¶³ 1 \u0026lt;= i \u0026lt;= s.length / 2 çš„ä»»æ„ i ï¼Œå¦‚æœ s ä¸­çš„ å‰ i ä¸ªå­—æ¯å’Œæ¥ä¸‹æ¥çš„ i ä¸ªå­—æ¯ ç›¸ç­‰ ï¼Œåˆ é™¤ å‰ i ä¸ªå­—æ¯ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœ s = \u0026#34;ababc\u0026#34; ï¼Œé‚£ä¹ˆåœ¨ä¸€æ­¥æ“ä½œä¸­ï¼Œä½ å¯ä»¥åˆ é™¤ s çš„å‰ä¸¤ä¸ªå­—æ¯å¾—åˆ° \u0026#34;abc\u0026#34; ï¼Œå› ä¸º s çš„å‰ä¸¤ä¸ªå­—æ¯å’Œæ¥ä¸‹æ¥çš„ä¸¤ä¸ªå­—æ¯éƒ½ç­‰äº \u0026#34;ab\u0026#34; ã€‚ è¿”å›åˆ é™¤ s æ‰€éœ€çš„æœ€å¤§æ“ä½œæ•°ã€‚ ç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šs = \u0026#34;abcabcdabc\u0026#34; è¾“å‡ºï¼š2 è§£é‡Šï¼š - åˆ é™¤å‰ 3 ä¸ªå­—æ¯ï¼ˆ\u0026#34;abc\u0026#34;ï¼‰ï¼Œå› ä¸ºå®ƒä»¬å’Œæ¥ä¸‹æ¥ 3 ä¸ªå­—æ¯ç›¸ç­‰ã€‚ç°åœ¨ï¼Œs = \u0026#34;abcdabc\u0026#34;ã€‚ - åˆ é™¤å…¨éƒ¨å­—æ¯ã€‚ ä¸€å…±ç”¨äº† 2 æ­¥æ“ä½œï¼Œæ‰€ä»¥è¿”å› 2 ã€‚å¯ä»¥è¯æ˜ 2 æ˜¯æ‰€éœ€çš„æœ€å¤§æ“ä½œæ•°ã€‚ æ³¨æ„ï¼Œåœ¨ç¬¬äºŒæ­¥æ“ä½œä¸­æ— æ³•å†æ¬¡åˆ é™¤ \u0026#34;abc\u0026#34; ï¼Œå› ä¸º \u0026#34;abc\u0026#34; çš„ä¸‹ä¸€æ¬¡å‡ºç°å¹¶ä¸æ˜¯ä½äºæ¥ä¸‹æ¥çš„ 3 ä¸ªå­—æ¯ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šs = \u0026#34;aaabaab\u0026#34; è¾“å‡ºï¼š4 è§£é‡Šï¼š - åˆ é™¤ç¬¬ä¸€ä¸ªå­—æ¯ï¼ˆ\u0026#34;a\u0026#34;ï¼‰ï¼Œå› ä¸ºå®ƒå’Œæ¥ä¸‹æ¥çš„å­—æ¯ç›¸ç­‰ã€‚ç°åœ¨ï¼Œs = \u0026#34;aabaab\u0026#34;ã€‚ - åˆ é™¤å‰ 3 ä¸ªå­—æ¯ï¼ˆ\u0026#34;aab\u0026#34;ï¼‰ï¼Œå› ä¸ºå®ƒä»¬å’Œæ¥ä¸‹æ¥ 3 ä¸ªå­—æ¯ç›¸ç­‰ã€‚ç°åœ¨ï¼Œs = \u0026#34;aab\u0026#34;ã€‚ - åˆ é™¤ç¬¬ä¸€ä¸ªå­—æ¯ï¼ˆ\u0026#34;a\u0026#34;ï¼‰ï¼Œå› ä¸ºå®ƒå’Œæ¥ä¸‹æ¥çš„å­—æ¯ç›¸ç­‰ã€‚ç°åœ¨ï¼Œs = \u0026#34;ab\u0026#34;ã€‚ - åˆ é™¤å…¨éƒ¨å­—æ¯ã€‚ ä¸€å…±ç”¨äº† 4 æ­¥æ“ä½œï¼Œæ‰€ä»¥è¿”å› 4 ã€‚å¯ä»¥è¯æ˜ 4 æ˜¯æ‰€éœ€çš„æœ€å¤§æ“ä½œæ•°ã€‚ ç¤ºä¾‹ 3ï¼š è¾“å…¥ï¼šs = \u0026#34;aaaaa\u0026#34; è¾“å‡ºï¼š5 è§£é‡Šï¼šåœ¨æ¯ä¸€æ­¥æ“ä½œä¸­ï¼Œéƒ½å¯ä»¥ä»…åˆ é™¤ s çš„ç¬¬ä¸€ä¸ªå­—æ¯ã€‚ æç¤ºï¼š 1 \u0026lt;= s.length \u0026lt;= 4000 s ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ æœ´ç´ è®°å¿†åŒ–æœç´¢(MLE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution: def deleteString(self, s: str) -\u0026gt; int: if len(set(s)) == 1: return len(s) @cache def dfs(i,start): ans=0 if i\u0026gt;=len(s): if i==start: return 0 return 1 # print(s[start:i+1],s[i+1:i+1+(i+1-start)]) if s[start:i+1]==s[i+1:i+1+(i+1-start)]: ans=dfs(i+1,i+1)+1 ans=max(ans,dfs(i+1,start)) return ans dfs.cache_clear() return dfs(0,0) æœ´ç´ åŠ¨æ€è§„åˆ’(TLE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution: def deleteString(self, s: str) -\u0026gt; int: size=len(s)+1 dfs=[[0]*(size+2) for _ in range(size+2)] for j in range(size): if j==size-1: dfs[size-1][j]=0 else: dfs[size-1][j]=1 for i in range(size-1,-1,-1): for j in range(size-1,-1,-1): if s[j:i+1]==s[i+1:i+1+(i+1-j)]: dfs[i][j]=dfs[i+1][i+1]+1 dfs[i][j]=max(dfs[i][j],dfs[i+1][j]) return dfs[0][0] LCPä¼˜åŒ–æœ´ç´ åŠ¨æ€è§„åˆ’(TLE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def deleteString(self, s: str) -\u0026gt; int: size=len(s)+1 if len(set(s)) == 1: return size-1 dfs=[[0]*(size+2) for _ in range(size+2)] lcp=[[0]*(size+2) for _ in range(size+2)] for i in range(size-2, -1, -1): for j in range(size-2, i, -1): if s[i] == s[j]: lcp[i][j] = lcp[i + 1][j + 1] + 1 for j in range(size): if j==size-1: dfs[size-1][j]=0 else: dfs[size-1][j]=1 for i in range(size-1,-1,-1): for j in range(size-1,-1,-1): if lcp[j][i+1]\u0026gt;=i+1-j: dfs[i][j]=dfs[i+1][i+1]+1 dfs[i][j]=max(dfs[i][j],dfs[i+1][j]) return dfs[0][0] å‰ªæè®°å¿†åŒ–æœç´¢(AC) 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution: def deleteString(self, s: str) -\u0026gt; int: @cache def dfs(i): s_ = s[i:] ans = 1 for j in range(1, len(s) // 2 + 1): if s_[:j] == s_[j:j*2]: ans = max(ans, 1 + dfs(i + j)) return ans dfs.cache_clear() return dfs(0) å‰ªæ+LCPä¼˜åŒ–åŠ¨æ€è§„åˆ’(AC) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution: def deleteString(self, s: str) -\u0026gt; int: n = len(s) if len(set(s)) == 1: return n # ç‰¹åˆ¤å…¨éƒ¨ç›¸åŒçš„æƒ…å†µ lcp = [[0] * (n + 1) for _ in range(n + 1)] # lcp[i][j] è¡¨ç¤º s[i:] å’Œ s[j:] çš„æœ€é•¿å…¬å…±å‰ç¼€ for i in range(n - 1, -1, -1): for j in range(n - 1, i, -1): if s[i] == s[j]: lcp[i][j] = lcp[i + 1][j + 1] + 1 f = [0] * n for i in range(n - 1, -1, -1): for j in range(1, (n - i) // 2 + 1): if lcp[i][i + j] \u0026gt;= j: # è¯´æ˜ s[i:i+j] == s[i+j:i+2*j] f[i] = max(f[i], f[i + j]) f[i] += 1 return f[0] # endlesscheng ","date":"2023-05-26T00:00:00Z","image":"https://pic.lingkou.xyz/1664008640-fTlCRH-1760-360%20%E7%A9%BA%E4%B8%AD%E4%BA%91%E6%B1%87.png","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-313/","title":"lc weekly contest 313"},{"content":"102. æœ€ä½³ç‰›å›´æ  é¢˜ç›®æè¿° å†œå¤«çº¦ç¿°çš„å†œåœºç”± $N$ å—ç”°åœ°ç»„æˆï¼Œæ¯å—åœ°é‡Œéƒ½æœ‰ä¸€å®šæ•°é‡çš„ç‰›ï¼Œå…¶æ•°é‡ä¸ä¼šå°‘äº 1 å¤´ï¼Œä¹Ÿä¸ä¼šè¶…è¿‡ 2000 å¤´ã€‚\nçº¦ç¿°å¸Œæœ›ç”¨å›´æ å°†ä¸€éƒ¨åˆ†è¿ç»­çš„ç”°åœ°å›´èµ·æ¥ï¼Œå¹¶ä½¿å¾—å›´èµ·æ¥çš„åŒºåŸŸå†…æ¯å—åœ°åŒ…å«çš„ç‰›çš„æ•°é‡çš„å¹³å‡å€¼è¾¾åˆ°æœ€å¤§ã€‚\nå›´èµ·åŒºåŸŸå†…è‡³å°‘éœ€è¦åŒ…å« $F$ å—åœ°ï¼Œå…¶ä¸­ $F$ ä¼šåœ¨è¾“å…¥ä¸­ç»™å‡ºã€‚\nåœ¨ç»™å®šæ¡ä»¶ä¸‹ï¼Œè®¡ç®—å›´èµ·åŒºåŸŸå†…æ¯å—åœ°åŒ…å«çš„ç‰›çš„æ•°é‡çš„å¹³å‡å€¼å¯èƒ½çš„æœ€å¤§å€¼æ˜¯å¤šå°‘ã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œè¾“å…¥æ•´æ•° $N$ å’Œ $F$ï¼Œæ•°æ®é—´ç”¨ç©ºæ ¼éš”å¼€ã€‚\næ¥ä¸‹æ¥ $N$ è¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼Œç¬¬ $i+1$ è¡Œè¾“å…¥çš„æ•´æ•°ä»£è¡¨ç¬¬ $i$ ç‰‡åŒºåŸŸå†…åŒ…å«çš„ç‰›çš„æ•°ç›®ã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºå¹³å‡å€¼çš„æœ€å¤§å€¼ä¹˜ä»¥ 1000 å†å‘ä¸‹å–æ•´ä¹‹åå¾—åˆ°çš„ç»“æœã€‚\næ•°æ®èŒƒå›´ $1â‰¤Nâ‰¤100000$\n$1â‰¤Fâ‰¤N$\nè¾“å…¥æ ·ä¾‹ï¼š 1 2 3 4 5 6 7 8 9 10 11 10 6 6 4 2 10 3 8 5 9 4 1 è¾“å‡ºæ ·ä¾‹ï¼š 1 6500 tag æ€ç»´ äºŒåˆ† DP/å‰ç¼€å’Œ code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f3f3f3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+2; double a[N],b[N]; int n,f; bool check(double t){ FOR(i,1,n+1){ b[i]=a[i]+b[i-1]-t; } double mins=inf; double maxs=-inf; FOR(i,f,n+1){ mins=min(mins,b[i-f]); maxs=max(maxs,b[i]-mins); } return maxs\u0026gt;=0; } int main() { ios cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;f; FOR(i,1,n+1){ cin\u0026gt;\u0026gt;a[i]; } double l=1,r=2001; double eps=1e-5; while(r-l\u0026gt;eps){ double mid=(l+r)/2; if (check(mid))l=mid; else r=mid; } cout\u0026lt;\u0026lt;int(r*1000)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } å…ƒç´ æ’åº æœ‰ $N$ ä¸ªå…ƒç´ ï¼Œç¼–å· $1,2,\\dots,N$ï¼Œæ¯ä¸€å¯¹å…ƒç´ ä¹‹é—´çš„å¤§å°å…³ç³»æ˜¯ç¡®å®šçš„ï¼Œå…³ç³»å…·æœ‰åå¯¹ç§°æ€§ï¼Œä½†ä¸å…·æœ‰ä¼ é€’æ€§ã€‚å…ƒç´ çš„å¤§å°å…³ç³»æ˜¯ $N$ ä¸ªç‚¹ä¸ $\\frac{N\\times(N-1)}{2}$ æ¡æœ‰å‘è¾¹æ„æˆçš„ä»»æ„æœ‰å‘å›¾ã€‚\nç„¶è€Œï¼Œè¿™æ˜¯ä¸€é“äº¤äº’å¼è¯•é¢˜ï¼Œè¿™äº›å…³ç³»ä¸èƒ½ä¸€æ¬¡æ€§å¾—çŸ¥ï¼Œä½ å¿…é¡»é€šè¿‡ä¸è¶…è¿‡ $10000$ æ¬¡æé—®æ¥è·å–ä¿¡æ¯ï¼Œæ¯æ¬¡æé—®åªèƒ½äº†è§£æŸä¸¤ä¸ªå…ƒç´ ä¹‹é—´çš„å…³ç³»ã€‚\nç°åœ¨è¯·ä½ æŠŠè¿™ $N$ ä¸ªå…ƒç´ æ’æˆä¸€è¡Œï¼Œä½¿å¾—æ¯ä¸ªå…ƒç´ éƒ½å°äºå³è¾¹ä¸å®ƒç›¸é‚»çš„å…ƒç´ ã€‚\nä½ å¯ä»¥é€šè¿‡æˆ‘ä»¬é¢„è®¾çš„ bool å‡½æ•° compare æ¥è·å¾—ä¸¤ä¸ªå…ƒç´ ä¹‹é—´çš„å¤§å°å…³ç³»ã€‚\nä¾‹å¦‚ï¼Œç¼–å·ä¸º $a$ å’Œ $b$ çš„ä¸¤ä¸ªå…ƒç´ ï¼Œå¦‚æœå…ƒç´  $a$ å°äºå…ƒç´  $b$ï¼Œåˆ™ compare(a,b) è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚\nå°† $N$ ä¸ªå…ƒç´ æ’å¥½åºåï¼ŒæŠŠå®ƒä»¬çš„ç¼–å·ä»¥æ•°ç»„çš„å½¢å¼è¾“å‡ºï¼Œå¦‚æœç­”æ¡ˆä¸å”¯ä¸€ï¼Œåˆ™è¾“å‡ºä»»æ„ä¸€ä¸ªå‡å¯ã€‚\næ•°æ®èŒƒå›´ $1 \\leq N \\leq 1000$\nè¾“å…¥æ ·ä¾‹ 1 [[0, 1, 0], [0, 0, 0], [1, 1, 0]] è¾“å‡ºæ ·ä¾‹ 1 [3, 1, 2] code 1 2 3 4 5 6 7 8 9 10 11 12 13 //æ»¡è¶³å½’å¹¶æ’åºæ€§è´¨ï¼Œå…ˆæ°´è¿‡å»å§ // Forward declaration of compare API. // bool compare(int a, int b); // return bool means whether a is less than b. class Solution { public: vector\u0026lt;int\u0026gt; specialSort(int N) { vector\u0026lt;int\u0026gt;a; for(int i=1;i\u0026lt;=N;++i)a.push_back(i); stable_sort(a.begin(),a.end(),compare); return a; } }; ","date":"2023-05-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue04/","title":"å°è“ä¹¦0X04äºŒåˆ†æ³•"},{"content":"windows å¯¹æ‹ä¸»ç¨‹åº 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;ctime\u0026gt; #include\u0026lt;windows.h\u0026gt; int main(){ int cnt=0; system(\u0026#34;g++ 1.cpp -o 1.exe\u0026#34;); system(\u0026#34;g++ 2.cpp -o 2.exe\u0026#34;); system(\u0026#34;g++ data.cpp -o data.exe\u0026#34;); while(1){ cnt++; system(\u0026#34;data.exe\u0026#34;); printf(\u0026#34;data create successfully\\n\u0026#34;); Sleep(1000); system(\u0026#34;1.exe\u0026#34;); system(\u0026#34;2.exe\u0026#34;); if(!system(\u0026#34;fc res.out ans.out\u0026#34;)){ printf(\u0026#34;AC test#%d\\n\u0026#34;,cnt); } else{ printf(\u0026#34;WA!\\n\u0026#34;); Sleep(2000); break; } } return 0; } æ•°æ®ç”Ÿæˆ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;ctime\u0026gt; using namespace std; typedef long long ll; ll random(ll mod) { ll n1, n2, n3, n4, ans; n1 = rand(); n2 = rand(); n3 = rand(); n4 = rand(); ans = n1 * n2 % mod; ans = ans * n3 % mod; ans = ans * n4 % mod; return ans; } int main(){ freopen(\u0026#34;data.in\u0026#34;,\u0026#34;w\u0026#34;,stdout); srand((unsigned)time(0)); ll i=random(10); cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return 0; } ç¨‹åºå¯¹æ‹èŠ‚ç‚¹ 1 2 3 4 5 6 //1.cpp freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //2.cpp freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); linux æŠŠexeæ”¹æˆout,fcæ”¹æˆdiff,Sleepæ”¹æˆsleep,windows.hæ”¹ä¸ºunistd.h\n","date":"2023-05-23T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/duipai/","title":"å¯¹æ‹æ¨¡æ¿"},{"content":"","date":"2023-05-22T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/java-gui/","title":"Java Gui"},{"content":"å†™åœ¨å‰é¢ LC346ä¼ é€é—¨ ç¬¬å››é¢˜éš¾,å‰ä¸‰é¢˜éš¾åº¦è¾ƒä½\nT1 åˆ é™¤å­ä¸²åçš„å­—ç¬¦ä¸²æœ€å°é•¿åº¦ ç»™ä½ ä¸€ä¸ªä»…ç”± å¤§å†™ è‹±æ–‡å­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸² s ã€‚ ä½ å¯ä»¥å¯¹æ­¤å­—ç¬¦ä¸²æ‰§è¡Œä¸€äº›æ“ä½œï¼Œåœ¨æ¯ä¸€æ­¥æ“ä½œä¸­ï¼Œä½ å¯ä»¥ä» s ä¸­åˆ é™¤ ä»»ä¸€ä¸ª \u0026ldquo;AB\u0026rdquo; æˆ– \u0026ldquo;CD\u0026rdquo; å­å­—ç¬¦ä¸²ã€‚ é€šè¿‡æ‰§è¡Œæ“ä½œï¼Œåˆ é™¤æ‰€æœ‰ \u0026ldquo;AB\u0026rdquo; å’Œ \u0026ldquo;CD\u0026rdquo; å­ä¸²ï¼Œè¿”å›å¯è·å¾—çš„æœ€ç»ˆå­—ç¬¦ä¸²çš„ æœ€å° å¯èƒ½é•¿åº¦ã€‚ æ³¨æ„ï¼Œåˆ é™¤å­ä¸²åï¼Œé‡æ–°è¿æ¥å‡ºçš„å­—ç¬¦ä¸²å¯èƒ½ä¼šäº§ç”Ÿæ–°çš„ \u0026ldquo;AB\u0026rdquo; æˆ– \u0026ldquo;CD\u0026rdquo; å­ä¸²\nç¤ºä¾‹ 1ï¼š è¾“å…¥ï¼šs = \u0026ldquo;ABFCACDB\u0026rdquo; è¾“å‡ºï¼š2 è§£é‡Šï¼šä½ å¯ä»¥æ‰§è¡Œä¸‹è¿°æ“ä½œï¼š\nä» \u0026ldquo;ABFCACDB\u0026rdquo; ä¸­åˆ é™¤å­ä¸² \u0026ldquo;AB\u0026rdquo;ï¼Œå¾—åˆ° s = \u0026ldquo;FCACDB\u0026rdquo; ã€‚ ä» \u0026ldquo;FCACDB\u0026rdquo; ä¸­åˆ é™¤å­ä¸² \u0026ldquo;CD\u0026rdquo;ï¼Œå¾—åˆ° s = \u0026ldquo;FCAB\u0026rdquo; ã€‚ ä» \u0026ldquo;FCAB\u0026rdquo; ä¸­åˆ é™¤å­ä¸² \u0026ldquo;AB\u0026rdquo;ï¼Œå¾—åˆ° s = \u0026ldquo;FC\u0026rdquo; ã€‚ æœ€ç»ˆå­—ç¬¦ä¸²çš„é•¿åº¦ä¸º 2 ã€‚ å¯ä»¥è¯æ˜ 2 æ˜¯å¯è·å¾—çš„æœ€å°é•¿åº¦ã€‚ ç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šs = \u0026ldquo;ACBBD\u0026rdquo; è¾“å‡ºï¼š5 è§£é‡Šï¼šæ— æ³•æ‰§è¡Œæ“ä½œï¼Œå­—ç¬¦ä¸²é•¿åº¦ä¸å˜ã€‚\næ€è·¯ æ¨¡æ‹Ÿ/æ ˆ(ç±»ä¼¼æ‹¬å·åˆ é™¤)\næ¯”èµ›ä»£ç (æ¨¡æ‹Ÿ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution: def minLength(self, s: str) -\u0026gt; int: p1=0 p2=1 if len(s)==1: return 1 a=[] for i in s: a.append(i) while p2\u0026lt;len(a): if a[p1]==\u0026#34;A\u0026#34; and a[p2]==\u0026#34;B\u0026#34;: del a[p1] del a[p2-1] if p1!=0 and p2!=1: p1-=1 p2-=1 elif a[p1]==\u0026#34;C\u0026#34; and a[p2]==\u0026#34;D\u0026#34;: del a[p1] del a[p2-1] if p1!=0 and p2!=1: p1-=1 p2-=1 else: p1+=1 p2+=1 return len(a) è¯­æ³•ç³–æ¨¡æ‹Ÿ 1 2 3 4 5 6 class Solution: def minLength(self, s: str) -\u0026gt; int: while \u0026#34;AB\u0026#34; in s or \u0026#34;CD\u0026#34; in s: s = s.replace(\u0026#34;AB\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;CD\u0026#34;, \u0026#34;\u0026#34;) return len(s) # ä½œè€…ï¼šendlesscheng æ ˆ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int minLength(string s) { stack\u0026lt;char\u0026gt; ss; for(auto i:s){ if(!ss.empty()\u0026amp;\u0026amp;((ss.top()==\u0026#39;A\u0026#39;\u0026amp;\u0026amp;i==\u0026#39;B\u0026#39;)||(ss.top()==\u0026#39;C\u0026#39;\u0026amp;\u0026amp;i==\u0026#39;D\u0026#39;)))ss.pop(); else ss.push(i); } return ss.size(); } }; T2 å­—å…¸åºæœ€å°å›æ–‡ä¸² ç»™ä½ ä¸€ä¸ªç”± å°å†™è‹±æ–‡å­—æ¯ ç»„æˆçš„å­—ç¬¦ä¸² s ï¼Œä½ å¯ä»¥å¯¹å…¶æ‰§è¡Œä¸€äº›æ“ä½œã€‚åœ¨ä¸€æ­¥æ“ä½œä¸­ï¼Œä½ å¯ä»¥ç”¨å…¶ä»–å°å†™è‹±æ–‡å­—æ¯ æ›¿æ¢ s ä¸­çš„ä¸€ä¸ªå­—ç¬¦ã€‚\nè¯·ä½ æ‰§è¡Œ å°½å¯èƒ½å°‘çš„æ“ä½œ ï¼Œä½¿ s å˜æˆä¸€ä¸ª å›æ–‡ä¸² ã€‚å¦‚æœæ‰§è¡Œ æœ€å°‘ æ“ä½œæ¬¡æ•°çš„æ–¹æ¡ˆä¸æ­¢ä¸€ç§ï¼Œåˆ™åªéœ€é€‰å– å­—å…¸åºæœ€å° çš„æ–¹æ¡ˆã€‚\nå¯¹äºä¸¤ä¸ªé•¿åº¦ç›¸åŒçš„å­—ç¬¦ä¸² a å’Œ b ï¼Œåœ¨ a å’Œ b å‡ºç°ä¸åŒçš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œå¦‚æœè¯¥ä½ç½®ä¸Š a ä¸­å¯¹åº”å­—æ¯æ¯” b ä¸­å¯¹åº”å­—æ¯åœ¨å­—æ¯è¡¨ä¸­å‡ºç°é¡ºåºæ›´æ—©ï¼Œåˆ™è®¤ä¸º a çš„å­—å…¸åºæ¯” b çš„å­—å…¸åºè¦å°ã€‚\nè¿”å›æœ€ç»ˆçš„å›æ–‡å­—ç¬¦ä¸²ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šs = \u0026ldquo;egcfe\u0026rdquo; è¾“å‡ºï¼š\u0026ldquo;efcfe\u0026rdquo; è§£é‡Šï¼šå°† \u0026ldquo;egcfe\u0026rdquo; å˜æˆå›æ–‡å­—ç¬¦ä¸²çš„æœ€å°æ“ä½œæ¬¡æ•°ä¸º 1 ï¼Œä¿®æ”¹ 1 æ¬¡å¾—åˆ°çš„å­—å…¸åºæœ€å°å›æ–‡å­—ç¬¦ä¸²æ˜¯ \u0026ldquo;efcfe\u0026rdquo;ï¼Œåªéœ€å°† \u0026lsquo;g\u0026rsquo; æ”¹ä¸º \u0026lsquo;f\u0026rsquo; ã€‚ ç¤ºä¾‹ 2ï¼š\nè¾“å…¥ï¼šs = \u0026ldquo;abcd\u0026rdquo; è¾“å‡ºï¼š\u0026ldquo;abba\u0026rdquo; è§£é‡Šï¼šå°† \u0026ldquo;abcd\u0026rdquo; å˜æˆå›æ–‡å­—ç¬¦ä¸²çš„æœ€å°æ“ä½œæ¬¡æ•°ä¸º 2 ï¼Œä¿®æ”¹ 2 æ¬¡å¾—åˆ°çš„å­—å…¸åºæœ€å°å›æ–‡å­—ç¬¦ä¸²æ˜¯ \u0026ldquo;abba\u0026rdquo; ã€‚ ç¤ºä¾‹ 3ï¼š\nè¾“å…¥ï¼šs = \u0026ldquo;seven\u0026rdquo; è¾“å‡ºï¼š\u0026ldquo;neven\u0026rdquo; è§£é‡Šï¼šå°† \u0026ldquo;seven\u0026rdquo; å˜æˆå›æ–‡å­—ç¬¦ä¸²çš„æœ€å°æ“ä½œæ¬¡æ•°ä¸º 1 ï¼Œä¿®æ”¹ 1 æ¬¡å¾—åˆ°çš„å­—å…¸åºæœ€å°å›æ–‡å­—ç¬¦ä¸²æ˜¯ \u0026ldquo;neven\u0026rdquo; ã€‚\næç¤ºï¼š\n1 \u0026lt;= s.length \u0026lt;= 1000 s ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ\næ€è·¯ åŒæŒ‡é’ˆ\nèµ›æ—¶ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: string makeSmallestPalindrome(string s) { int st=0; int ed=s.size()-1; while(st\u0026lt;ed){ if(s[st]!=s[ed]){ if(s[st]-\u0026#39;a\u0026#39;\u0026gt;s[ed]-\u0026#39;a\u0026#39;){ s[st]=s[ed]; } else{ s[ed]=s[st]; } } st++; ed--; } return s; } }; T3 æ±‚ä¸€ä¸ªæ•´æ•°çš„æƒ©ç½šæ•° ç»™ä½ ä¸€ä¸ªæ­£æ•´æ•° n ï¼Œè¯·ä½ è¿”å› n çš„ æƒ©ç½šæ•° ã€‚\nn çš„ æƒ©ç½šæ•° å®šä¹‰ä¸ºæ‰€æœ‰æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ i çš„æ•°çš„å¹³æ–¹å’Œï¼š\n1 \u0026lt;= i \u0026lt;= n i * i çš„åè¿›åˆ¶è¡¨ç¤ºçš„å­—ç¬¦ä¸²å¯ä»¥åˆ†å‰²æˆè‹¥å¹²è¿ç»­å­å­—ç¬¦ä¸²ï¼Œä¸”è¿™äº›å­å­—ç¬¦ä¸²å¯¹åº”çš„æ•´æ•°å€¼ä¹‹å’Œç­‰äº i ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šn = 10 è¾“å‡ºï¼š182 è§£é‡Šï¼šæ€»å…±æœ‰ 3 ä¸ªæ•´æ•° i æ»¡è¶³è¦æ±‚ï¼š\n1 ï¼Œå› ä¸º 1 * 1 = 1 9 ï¼Œå› ä¸º 9 * 9 = 81 ï¼Œä¸” 81 å¯ä»¥åˆ†å‰²æˆ 8 + 1 ã€‚ 10 ï¼Œå› ä¸º 10 * 10 = 100 ï¼Œä¸” 100 å¯ä»¥åˆ†å‰²æˆ 10 + 0 ã€‚ å› æ­¤ï¼Œ10 çš„æƒ©ç½šæ•°ä¸º 1 + 81 + 100 = 182\nç¤ºä¾‹ 2ï¼š è¾“å…¥ï¼šn = 37 è¾“å‡ºï¼š1478 è§£é‡Šï¼šæ€»å…±æœ‰ 4 ä¸ªæ•´æ•° i æ»¡è¶³è¦æ±‚ï¼š\n1 ï¼Œå› ä¸º 1 * 1 = 1 9 ï¼Œå› ä¸º 9 * 9 = 81 ï¼Œä¸” 81 å¯ä»¥åˆ†å‰²æˆ 8 + 1 ã€‚ 10 ï¼Œå› ä¸º 10 * 10 = 100 ï¼Œä¸” 100 å¯ä»¥åˆ†å‰²æˆ 10 + 0 ã€‚ 36 ï¼Œå› ä¸º 36 * 36 = 1296 ï¼Œä¸” 1296 å¯ä»¥åˆ†å‰²æˆ 1 + 29 + 6 ã€‚ å› æ­¤ï¼Œ37 çš„æƒ©ç½šæ•°ä¸º 1 + 81 + 100 + 1296 = 1478 æç¤ºï¼š\n1 \u0026lt;= n \u0026lt;= 1000\næ€è·¯ æ¯”èµ›æ—¶çœ‹åˆ°næœ€å¤§æ‰1000,å¯ä»¥ç›´æ¥é¢„å¤„ç† æ‰“è¡¨ç”¨çš„dfs, ä¸ºäº†èŠ‚çº¦æ—¶é—´æ²¡æŠŠdfsæ”¹æˆåŠ¨æ€è§„åˆ’\nèµ›æ—¶ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # æ‰“è¡¨ä»£ç  # a=[] # s=\u0026#34;\u0026#34; # def check(i,v,p): # if i\u0026gt;=len(s): # if p==v: # return 1 # return 0 # x=0 # for d in range(i,len(s)): # x=x|check(d+1,v,p+int(s[i:d+1])) # return x # for i in range(1,1001): # s=str(i*i) # if check(0,i,0): # a.append(i) # print(a) class Solution: def punishmentNumber(self, n: int) -\u0026gt; int: s={1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000} cnt=0 for i in range(1,n+1): if i in s: cnt+=i*i return cnt è®°å¿†åŒ–æœç´¢ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution: def punishmentNumber(self, n: int) -\u0026gt; int: @cache def check(i,v,p,s): if i\u0026gt;=len(s): if p==v: return 1 return 0 x=0 for d in range(i,len(s)): x=x|check(d+1,v,p+int(s[i:d+1]),s) return x cnt=0 for i in range(1,n+1): s=str(i*i) if check(0,i,0,s): cnt+=i*i return cnt T4ä¿®æ”¹å›¾ä¸­çš„è¾¹æƒ ç»™ä½ ä¸€ä¸ª n ä¸ªèŠ‚ç‚¹çš„ æ— å‘å¸¦æƒè¿é€š å›¾ï¼ŒèŠ‚ç‚¹ç¼–å·ä¸º 0 åˆ° n - 1 ï¼Œå†ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ edges ï¼Œå…¶ä¸­ edges[i] = [ai, bi, wi] è¡¨ç¤ºèŠ‚ç‚¹ ai å’Œ bi ä¹‹é—´æœ‰ä¸€æ¡è¾¹æƒä¸º wi çš„è¾¹ã€‚\néƒ¨åˆ†è¾¹çš„è¾¹æƒä¸º -1ï¼ˆwi = -1ï¼‰ï¼Œå…¶ä»–è¾¹çš„è¾¹æƒéƒ½ä¸º æ­£ æ•°ï¼ˆwi \u0026gt; 0ï¼‰ã€‚\nä½ éœ€è¦å°†æ‰€æœ‰è¾¹æƒä¸º -1 çš„è¾¹éƒ½ä¿®æ”¹ä¸ºèŒƒå›´ [1, 2 * 109] ä¸­çš„ æ­£æ•´æ•° ï¼Œä½¿å¾—ä»èŠ‚ç‚¹ source åˆ°èŠ‚ç‚¹ destination çš„ æœ€çŸ­è·ç¦» ä¸ºæ•´æ•° target ã€‚å¦‚æœæœ‰ å¤šç§ ä¿®æ”¹æ–¹æ¡ˆå¯ä»¥ä½¿ source å’Œ destination ä¹‹é—´çš„æœ€çŸ­è·ç¦»ç­‰äº target ï¼Œä½ å¯ä»¥è¿”å›ä»»æ„ä¸€ç§æ–¹æ¡ˆã€‚\nå¦‚æœå­˜åœ¨ä½¿ source åˆ° destination æœ€çŸ­è·ç¦»ä¸º target çš„æ–¹æ¡ˆï¼Œè¯·ä½ æŒ‰ä»»æ„é¡ºåºè¿”å›åŒ…å«æ‰€æœ‰è¾¹çš„æ•°ç»„ï¼ˆåŒ…æ‹¬æœªä¿®æ”¹è¾¹æƒçš„è¾¹ï¼‰ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„æ–¹æ¡ˆï¼Œè¯·ä½ è¿”å›ä¸€ä¸ª ç©ºæ•°ç»„ ã€‚\næ³¨æ„ï¼šä½ ä¸èƒ½ä¿®æ”¹ä¸€å¼€å§‹è¾¹æƒä¸ºæ­£æ•°çš„è¾¹ã€‚\nç¤ºä¾‹ 1ï¼š\nè¾“å…¥ï¼šn = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5 è¾“å‡ºï¼š[[4,1,1],[2,0,1],[0,3,3],[4,3,1]] è§£é‡Šï¼šä¸Šå›¾å±•ç¤ºäº†ä¸€ä¸ªæ»¡è¶³é¢˜æ„çš„ä¿®æ”¹æ–¹æ¡ˆï¼Œä» 0 åˆ° 1 çš„æœ€çŸ­è·ç¦»ä¸º 5 ã€‚ ç¤ºä¾‹ 2ï¼š\nè¾“å…¥ï¼šn = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6 è¾“å‡ºï¼š[] è§£é‡Šï¼šä¸Šå›¾æ˜¯ä¸€å¼€å§‹çš„å›¾ã€‚æ²¡æœ‰åŠæ³•é€šè¿‡ä¿®æ”¹è¾¹æƒä¸º -1 çš„è¾¹ï¼Œä½¿å¾— 0 åˆ° 2 çš„æœ€çŸ­è·ç¦»ç­‰äº 6 ï¼Œæ‰€ä»¥è¿”å›ä¸€ä¸ªç©ºæ•°ç»„ã€‚ ç¤ºä¾‹ 3ï¼š\nè¾“å…¥ï¼šn = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6 è¾“å‡ºï¼š[[1,0,4],[1,2,3],[2,3,5],[0,3,1]] è§£é‡Šï¼šä¸Šå›¾å±•ç¤ºäº†ä¸€ä¸ªæ»¡è¶³é¢˜æ„çš„ä¿®æ”¹æ–¹æ¡ˆï¼Œä» 0 åˆ° 2 çš„æœ€çŸ­è·ç¦»ä¸º 6 ã€‚\næç¤ºï¼š\n1 2 3 4 5 6 7 8 9 10 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= edges.length \u0026lt;= n * (n - 1) / 2 edges[i].length == 3 0 \u0026lt;= ai, bi \u0026lt; n wi = -1 æˆ–è€… 1 \u0026lt;= wi \u0026lt;= 107 ai != bi 0 \u0026lt;= source, destination \u0026lt; n source != destination 1 \u0026lt;= target \u0026lt;= 109 è¾“å…¥çš„å›¾æ˜¯è¿é€šå›¾ï¼Œä¸”æ²¡æœ‰è‡ªç¯å’Œé‡è¾¹ã€‚ è¯·è§ ","date":"2023-05-21T00:00:00Z","image":"https://pic.lingkou.xyz/1684119642-NLFpUC-1760-360%20%E9%A1%BA%E4%B8%B0%E7%A7%91%E6%8A%80.png","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-346/","title":"lc weekly contest 346"},{"content":"c++ ç²¾ç®€æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define For(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define _For(a,b,c) for(int a=(b);a\u0026gt;(c);a--) #define all(x) (x).begin(),x.end() #define inf 0x3f3f3f3f //å¯¹æ‹ #define fo1 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); #define fo2 freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //è¾“å‡ºæ•°ç»„ #define printA(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; typedef long long ll; typedef unsigned long long ull; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6; const int MOD=1e9+7; inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } inline void write(int x) { if (x \u0026lt; 0) { putchar(\u0026#39;-\u0026#39;); x = -x; } if (x \u0026gt; 9) write(x / 10); putchar(x % 10 + \u0026#39;0\u0026#39;); } inline void hhhh(){ //todo } int main() { //hhhh(); int T; T.read(); while(T--){ hhhh(); } return 0; } å…¶å®ƒæ¨¡æ¿(æ¥æºç½‘ç»œ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #define _USE_MATH_DEFINES // C #include \u0026lt;cassert\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;ctime\u0026gt; //io #include \u0026lt;iostream\u0026gt; //åŸºæœ¬è¾“å…¥è¾“å‡ºæµ #include \u0026lt;iomanip\u0026gt; #include \u0026lt;sstream\u0026gt; //åŸºäºå­—ç¬¦ä¸²çš„æµ //æ ‡å‡†å¼‚å¸¸ç±» #include \u0026lt;stdexcept\u0026gt; //algorithm #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;functional\u0026gt; //å®šä¹‰è¿ç®—å‡½æ•°ï¼ˆä»£æ›¿è¿ç®—ç¬¦ï¼‰ #include \u0026lt;complex\u0026gt; //å¤æ•°ç±» #include \u0026lt;random\u0026gt; //STL #include \u0026lt;string\u0026gt; //å­—ç¬¦ä¸²ç±» #include \u0026lt;list\u0026gt; //çº¿æ€§åˆ—è¡¨å®¹å™¨ #include \u0026lt;vector\u0026gt; //åŠ¨æ€æ•°ç»„å®¹å™¨ #include \u0026lt;stack\u0026gt; //å †æ ˆå®¹å™¨ #include \u0026lt;queue\u0026gt; //é˜Ÿåˆ—å®¹å™¨ #include \u0026lt;deque\u0026gt; //åŒç«¯é˜Ÿåˆ—å®¹å™¨ #include \u0026lt;bitset\u0026gt; //æ¯”ç‰¹é›†åˆ #include \u0026lt;set\u0026gt; //é›†åˆå®¹å™¨ #include \u0026lt;map\u0026gt; //æ˜ å°„å®¹å™¨ #include \u0026lt;unordered_set\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; //fast ios #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define ALL(a) (a).begin(),(a).end() #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define RFOR(w, a, n) for(int w=(n)-1;w\u0026gt;=(a);--w) #define REP(w, n) for(int w=0;w\u0026lt;int(n);++w) #define RREP(w, n) for(int w=int(n)-1;w\u0026gt;=0;--w) #define IN(a, x, b) (a\u0026lt;=x \u0026amp;\u0026amp; x\u0026lt;b) #define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) template \u0026lt;typename Arg1\u0026gt; void __f(const char* name, Arg1\u0026amp;\u0026amp; arg1){ cerr \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; endl; } template \u0026lt;typename Arg1, typename... Args\u0026gt; void __f(const char* names, Arg1\u0026amp;\u0026amp; arg1, Args\u0026amp;\u0026amp;... args){ const char* comma = strchr(names + 1, \u0026#39;,\u0026#39;); cerr.write(names, comma - names) \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; \u0026#34; |\u0026#34;; __f(comma + 1, args...); } typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const double PI = acos(-1.0); const double eps = 1e-6; const int INF = 1 \u0026lt;\u0026lt; 29; const int MOD = 1e9 + 7; const int MAXN = 100; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, ACM.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys import heapq import random from math import ceil,floor,fmod,gcd,sqrt,inf from bisect import bisect_left from collections import defaultdict,Counter,deque,OrderedDict from functools import lru_cache,cmp_to_key #sys.setrecursionlimit(1000000) # è¾“å…¥1 def ii(): return int(sys.stdin.readline().strip()) # è¾“å…¥2 def iin(): return map(int,sys.stdin.readline().split()) def inn(): return sys.stdin.readline().strip() java go ","date":"2023-05-08T00:03:00Z","image":"https://open17.github.io/CpHugo/p/template/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://open17.github.io/CpHugo/p/template/","title":"ç®—æ³•è¾“å…¥è¾“å‡ºæ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 vector\u0026lt;int\u0026gt; get_prefix_table(string pattern) { int n = pattern.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = pi[j-1]; } if (pattern[i] == pattern[j]) { j++; } pi[i] = j; } return pi; } vector\u0026lt;int\u0026gt; kmp(string text, string pattern) { vector\u0026lt;int\u0026gt; pi = get_prefix_table(pattern); vector\u0026lt;int\u0026gt; matches; for (int i = 0, j = 0; i \u0026lt; text.length(); i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; text[i] != pattern[j]) { j = pi[j-1]; } if (text[i] == pattern[j]) { j++; } if (j == pattern.length()) { matches.push_back(i - j + 1); j = pi[j-1]; } } return matches; } ã€æ¨¡æ¿ã€‘KMPå­—ç¬¦ä¸²åŒ¹é… é¢˜ç›®æè¿° ç»™å‡ºä¸¤ä¸ªå­—ç¬¦ä¸² $s_1$ å’Œ $s_2$ï¼Œè‹¥ $s_1$ çš„åŒºé—´ $[l, r]$ å­ä¸²ä¸ $s_2$ å®Œå…¨ç›¸åŒï¼Œåˆ™ç§° $s_2$ åœ¨ $s_1$ ä¸­å‡ºç°äº†ï¼Œå…¶å‡ºç°ä½ç½®ä¸º $l$ã€‚\nç°åœ¨è¯·ä½ æ±‚å‡º $s_2$ åœ¨ $s_1$ ä¸­æ‰€æœ‰å‡ºç°çš„ä½ç½®ã€‚\nå®šä¹‰ä¸€ä¸ªå­—ç¬¦ä¸² $s$ çš„ border ä¸º $s$ çš„ä¸€ä¸ªé $s$ æœ¬èº«çš„å­ä¸² $t$ï¼Œæ»¡è¶³ $t$ æ—¢æ˜¯ $s$ çš„å‰ç¼€ï¼Œåˆæ˜¯ $s$ çš„åç¼€ã€‚\nå¯¹äº $s_2$ï¼Œä½ è¿˜éœ€è¦æ±‚å‡ºå¯¹äºå…¶æ¯ä¸ªå‰ç¼€ $s\u0026rsquo;$ çš„æœ€é•¿ border $t\u0026rsquo;$ çš„é•¿åº¦ã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œä¸ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå³ä¸º $s_1$ã€‚\nç¬¬äºŒè¡Œä¸ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå³ä¸º $s_2$ã€‚\nè¾“å‡ºæ ¼å¼ é¦–å…ˆè¾“å‡ºè‹¥å¹²è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°ï¼ŒæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºè¾“å‡º $s_2$ åœ¨ $s_1$ ä¸­å‡ºç°çš„ä½ç½®ã€‚\næœ€åä¸€è¡Œè¾“å‡º $|s_2|$ ä¸ªæ•´æ•°ï¼Œç¬¬ $i$ ä¸ªæ•´æ•°è¡¨ç¤º $s_2$ çš„é•¿åº¦ä¸º $i$ çš„å‰ç¼€çš„æœ€é•¿ border é•¿åº¦ã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 ABABABC ABA æ ·ä¾‹è¾“å‡º #1 1 2 3 1 3 0 0 1 æç¤º æ ·ä¾‹ 1 è§£é‡Š ã€‚\nå¯¹äº $s_2$ é•¿åº¦ä¸º $3$ çš„å‰ç¼€ ABAï¼Œå­—ç¬¦ä¸² A æ—¢æ˜¯å…¶åç¼€ä¹Ÿæ˜¯å…¶å‰ç¼€ï¼Œä¸”æ˜¯æœ€é•¿çš„ï¼Œå› æ­¤æœ€é•¿ border é•¿åº¦ä¸º $1$ã€‚\næ•°æ®è§„æ¨¡ä¸çº¦å®š æœ¬é¢˜é‡‡ç”¨å¤šæµ‹è¯•ç‚¹æ†ç»‘æµ‹è¯•ï¼Œå…±æœ‰ 3 ä¸ªå­ä»»åŠ¡ã€‚\nSubtask 1ï¼ˆ30 pointsï¼‰ï¼š$|s_1| \\leq 15$ï¼Œ$|s_2| \\leq 5$ã€‚ Subtask 2ï¼ˆ40 pointsï¼‰ï¼š$|s_1| \\leq 10^4$ï¼Œ$|s_2| \\leq 10^2$ã€‚ Subtask 3ï¼ˆ30 pointsï¼‰ï¼šæ— ç‰¹æ®Šçº¦å®šã€‚ å¯¹äºå…¨éƒ¨çš„æµ‹è¯•ç‚¹ï¼Œä¿è¯ $1 \\leq |s_1|,|s_2| \\leq 10^6$ï¼Œ$s_1, s_2$ ä¸­å‡åªå«å¤§å†™è‹±æ–‡å­—æ¯ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; get_prefix_table(string pattern) { int n = pattern.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = pi[j-1]; } if (pattern[i] == pattern[j]) { j++; } pi[i] = j; } return pi; } vector\u0026lt;int\u0026gt; kmp(string text, string pattern) { vector\u0026lt;int\u0026gt; pi = get_prefix_table(pattern); vector\u0026lt;int\u0026gt; matches; for (int i = 0, j = 0; i \u0026lt; text.length(); i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; text[i] != pattern[j]) { j = pi[j-1]; } if (text[i] == pattern[j]) { j++; } if (j == pattern.length()) { matches.push_back(i - j + 1); j = pi[j-1]; } } return matches; } int main() { string s1, s2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; // ä½¿ç”¨ KMP ç®—æ³•æŸ¥æ‰¾æ‰€æœ‰å‡ºç°ä½ç½® vector\u0026lt;int\u0026gt; matches = kmp(s1, s2); // è¾“å‡ºå‡ºç°ä½ç½® for (int i = 0; i \u0026lt; matches.size(); i++) { cout \u0026lt;\u0026lt; matches[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // è®¡ç®— s2 çš„å‰ç¼€çš„æœ€é•¿ border é•¿åº¦ vector\u0026lt;int\u0026gt; pi = get_prefix_table(s2); for (int i = 0; i \u0026lt; s2.length(); i++) { cout \u0026lt;\u0026lt; pi[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/kmp/","title":"KMPæ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const int MAXN = 1e5 + 5; // æœ€å¤§æ•°ç»„é•¿åº¦ const int MAXK = 25; // log2(MAXN) å‘ä¸Šå–æ•´ int a[MAXN]; // è¾“å…¥æ•°ç»„ int st[MAXN][MAXK + 1]; // STè¡¨ int Log2[MAXN]; void build(int n) { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; // åˆå§‹åŒ–ç¬¬ä¸€åˆ— } for (int j = 1; j \u0026lt;= MAXK; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = min(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); // æ›´æ–°STè¡¨ } } for (int i = 2; i \u0026lt;= n; ++i) Log2[i] = Log2[i / 2] + 1; } int query(int l, int r) { int k = Log2[r - l + 1]; // è®¡ç®—åŒºé—´é•¿åº¦çš„å¯¹æ•°ï¼Œå‘ä¸‹å–æ•´ return min(st[l][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); // è¿”å›åŒºé—´æœ€å°å€¼ } ã€æ¨¡æ¿ã€‘ST è¡¨ é¢˜ç›®èƒŒæ™¯ è¿™æ˜¯ä¸€é“ ST è¡¨ç»å…¸é¢˜â€”â€”é™æ€åŒºé—´æœ€å¤§å€¼\nè¯·æ³¨æ„æœ€å¤§æ•°æ®æ—¶é™åªæœ‰ 0.8sï¼Œæ•°æ®å¼ºåº¦ä¸ä½ï¼Œè¯·åŠ¡å¿…ä¿è¯ä½ çš„æ¯æ¬¡æŸ¥è¯¢å¤æ‚åº¦ä¸º $O(1)$ã€‚è‹¥ä½¿ç”¨æ›´é«˜æ—¶é—´å¤æ‚åº¦ç®—æ³•ä¸ä¿è¯èƒ½é€šè¿‡ã€‚\nå¦‚æœæ‚¨è®¤ä¸ºæ‚¨çš„ä»£ç æ—¶é—´å¤æ‚åº¦æ­£ç¡®ä½†æ˜¯ TLEï¼Œå¯ä»¥å°è¯•ä½¿ç”¨å¿«é€Ÿè¯»å…¥ï¼š\n1 2 3 4 5 6 7 inline int read() { int x=0,f=1;char ch=getchar(); while (ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if (ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while (ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-48;ch=getchar();} return x*f; } å‡½æ•°è¿”å›å€¼ä¸ºè¯»å…¥çš„ç¬¬ä¸€ä¸ªæ•´æ•°ã€‚\nå¿«é€Ÿè¯»å…¥ä½œç”¨ä»…ä¸ºåŠ å¿«è¯»å…¥ï¼Œå¹¶éå¼ºåˆ¶ä½¿ç”¨ã€‚\né¢˜ç›®æè¿° ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $N$ çš„æ•°åˆ—ï¼Œå’Œ $ M $ æ¬¡è¯¢é—®ï¼Œæ±‚å‡ºæ¯ä¸€æ¬¡è¯¢é—®çš„åŒºé—´å†…æ•°å­—çš„æœ€å¤§å€¼ã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° $N,M$ï¼Œåˆ†åˆ«è¡¨ç¤ºæ•°åˆ—çš„é•¿åº¦å’Œè¯¢é—®çš„ä¸ªæ•°ã€‚\nç¬¬äºŒè¡ŒåŒ…å« $N$ ä¸ªæ•´æ•°ï¼ˆè®°ä¸º $a_i$ï¼‰ï¼Œä¾æ¬¡è¡¨ç¤ºæ•°åˆ—çš„ç¬¬ $i$ é¡¹ã€‚\næ¥ä¸‹æ¥ $M$ è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° $l_i,r_i$ï¼Œè¡¨ç¤ºæŸ¥è¯¢çš„åŒºé—´ä¸º $[l_i,r_i]$ã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡ºåŒ…å« $M$ è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°ï¼Œä¾æ¬¡è¡¨ç¤ºæ¯ä¸€æ¬¡è¯¢é—®çš„ç»“æœã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 7 8 9 10 8 8 9 3 1 7 5 6 0 8 1 6 1 5 2 7 2 6 1 8 4 8 3 7 1 8 æ ·ä¾‹è¾“å‡º #1 1 2 3 4 5 6 7 8 9 9 7 7 9 8 7 9 æç¤º å¯¹äº $30%$ çš„æ•°æ®ï¼Œæ»¡è¶³ $1\\le N,M\\le 10$ã€‚\nå¯¹äº $70%$ çš„æ•°æ®ï¼Œæ»¡è¶³ $1\\le N,M\\le {10}^5$ã€‚\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œæ»¡è¶³ $1\\le N\\le {10}^5$ï¼Œ$1\\le M\\le 2\\times{10}^6$ï¼Œ$a_i\\in[0,{10}^9]$ï¼Œ$1\\le l_i\\le r_i\\le N$ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAXN = 1e5 + 5; // æœ€å¤§æ•°ç»„é•¿åº¦ const int MAXK = 25; // log2(MAXN) å‘ä¸Šå–æ•´ int a[MAXN]; // è¾“å…¥æ•°ç»„ int st[MAXN][MAXK + 1]; // STè¡¨ int Log2[MAXN]; void build(int n) { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; // åˆå§‹åŒ–ç¬¬ä¸€åˆ— } for (int j = 1; j \u0026lt;= MAXK; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = max(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); // æ›´æ–°STè¡¨ } } for (int i = 2; i \u0026lt;= n; ++i) Log2[i] = Log2[i / 2] + 1; } int query(int l, int r) { int k = Log2[r - l + 1]; // è®¡ç®—åŒºé—´é•¿åº¦çš„å¯¹æ•°ï¼Œå‘ä¸‹å–æ•´ return max(st[l][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); // è¿”å›åŒºé—´æœ€å°å€¼ } inline int read() { int x=0,f=1;char ch=getchar(); while (ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if (ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while (ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-48;ch=getchar();} return x*f; } int main() { int n,m; n=read(); m=read(); for(int i=1;i\u0026lt;=n;i++){ a[i]=read(); } build(n); while(m--){ int l=read(),r=read(); printf(\u0026#34;%d\\n\u0026#34;,query(l,r)); } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/st/","title":"STè¡¨æ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œç”¨äºæ±‚æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦å’Œç¥–å…ˆä¿¡æ¯ void dfs(int u, int fa) { depth[u] = depth[fa] + 1; // å½“å‰èŠ‚ç‚¹çš„æ·±åº¦ä¸ºçˆ¶èŠ‚ç‚¹çš„æ·±åº¦åŠ ä¸€ p[u][0] = fa; // å½“å‰èŠ‚ç‚¹çš„ 2^0 çº§ç¥–å…ˆä¸ºçˆ¶èŠ‚ç‚¹ // é€’æ¨æ±‚å‡ºå½“å‰èŠ‚ç‚¹çš„ 2^i çº§ç¥–å…ˆ for (int i = 1; i \u0026lt; M; i ++ ) p[u][i] = p[p[u][i - 1]][i - 1]; // éå†å½“å‰èŠ‚ç‚¹çš„æ¯ä¸€ä¸ªå„¿å­ï¼Œé€’å½’è°ƒç”¨ dfs å‡½æ•° for (auto v : g[u]) if (v != fa) // é¿å…å‘çˆ¶èŠ‚ç‚¹é€’å½’ dfs(v, u); } // æ±‚ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ int lca(int a, int b) { if (depth[a] \u0026lt; depth[b]) swap(a, b); // ä¿è¯ a æ·±åº¦ä¸å°äº b // å…ˆå°† a è·³åˆ°å’Œ b åŒä¸€æ·±åº¦ for (int i = M - 1; i \u0026gt;= 0; i -- ) if (depth[p[a][i]] \u0026gt;= depth[b]) a = p[a][i]; if (a == b) return a; // ç‰¹åˆ¤ a å’Œ b åœ¨åŒä¸€æ¡é“¾ä¸Šçš„æƒ…å†µ // ä¸€èµ·å‘ä¸Šè·³ï¼Œç›´åˆ° a å’Œ b çš„ç¬¬ä¸€ä¸ªä¸åŒçš„ç¥–å…ˆ for (int i = M - 1; i \u0026gt;= 0; i -- ) if (p[a][i] != p[b][i]) { a = p[a][i]; b = p[b][i]; } return p[a][0]; // è¿”å› a çš„çˆ¶èŠ‚ç‚¹ï¼Œå³ä¸º LCA } ã€æ¨¡æ¿ã€‘æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆLCAï¼‰ é¢˜ç›®æè¿° å¦‚é¢˜ï¼Œç»™å®šä¸€æ£µæœ‰æ ¹å¤šå‰æ ‘ï¼Œè¯·æ±‚å‡ºæŒ‡å®šä¸¤ä¸ªç‚¹ç›´æ¥æœ€è¿‘çš„å…¬å…±ç¥–å…ˆã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«ä¸‰ä¸ªæ­£æ•´æ•° $N,M,S$ï¼Œåˆ†åˆ«è¡¨ç¤ºæ ‘çš„ç»“ç‚¹ä¸ªæ•°ã€è¯¢é—®çš„ä¸ªæ•°å’Œæ ‘æ ¹ç»“ç‚¹çš„åºå·ã€‚\næ¥ä¸‹æ¥ $N-1$ è¡Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•° $x, y$ï¼Œè¡¨ç¤º $x$ ç»“ç‚¹å’Œ $y$ ç»“ç‚¹ä¹‹é—´æœ‰ä¸€æ¡ç›´æ¥è¿æ¥çš„è¾¹ï¼ˆæ•°æ®ä¿è¯å¯ä»¥æ„æˆæ ‘ï¼‰ã€‚\næ¥ä¸‹æ¥ $M$ è¡Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•° $a, b$ï¼Œè¡¨ç¤ºè¯¢é—® $a$ ç»“ç‚¹å’Œ $b$ ç»“ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡ºåŒ…å« $M$ è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªæ­£æ•´æ•°ï¼Œä¾æ¬¡ä¸ºæ¯ä¸€ä¸ªè¯¢é—®çš„ç»“æœã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 7 8 9 10 5 5 4 3 1 2 4 5 1 1 4 2 4 3 2 3 5 1 2 4 5 æ ·ä¾‹è¾“å‡º #1 1 2 3 4 5 4 4 1 4 4 æç¤º å¯¹äº $30%$ çš„æ•°æ®ï¼Œ$N\\leq 10$ï¼Œ$M\\leq 10$ã€‚\nå¯¹äº $70%$ çš„æ•°æ®ï¼Œ$N\\leq 10000$ï¼Œ$M\\leq 10000$ã€‚\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œ$1 \\leq N,M\\leq 500000$ï¼Œ$1 \\leq x, y,a ,b \\leq N$ï¼Œä¸ä¿è¯ $a \\neq b$ã€‚\næ ·ä¾‹è¯´æ˜ï¼š\nè¯¥æ ‘ç»“æ„å¦‚ä¸‹ï¼š\nç¬¬ä¸€æ¬¡è¯¢é—®ï¼š$2, 4$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œæ•…ä¸º $4$ã€‚\nç¬¬äºŒæ¬¡è¯¢é—®ï¼š$3, 2$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œæ•…ä¸º $4$ã€‚\nç¬¬ä¸‰æ¬¡è¯¢é—®ï¼š$3, 5$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œæ•…ä¸º $1$ã€‚\nç¬¬å››æ¬¡è¯¢é—®ï¼š$1, 2$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œæ•…ä¸º $4$ã€‚\nç¬¬äº”æ¬¡è¯¢é—®ï¼š$4, 5$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œæ•…ä¸º $4$ã€‚\næ•…è¾“å‡ºä¾æ¬¡ä¸º $4, 4, 1, 4, 4$ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N = 500010, M = 20; int n, m, s; // nï¼šèŠ‚ç‚¹æ•°ï¼Œmï¼šæŸ¥è¯¢æ¬¡æ•°ï¼Œsï¼šæ ¹èŠ‚ç‚¹ç¼–å· int depth[N], p[N][M]; // depthï¼šæ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦ï¼Œpï¼šæ¯ä¸ªèŠ‚ç‚¹çš„ 2^i çº§ç¥–å…ˆ vector\u0026lt;int\u0026gt; g[N]; // gï¼šæ ‘çš„é‚»æ¥è¡¨è¡¨ç¤º // æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œç”¨äºæ±‚æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦å’Œç¥–å…ˆä¿¡æ¯ void dfs(int u, int fa) { depth[u] = depth[fa] + 1; // å½“å‰èŠ‚ç‚¹çš„æ·±åº¦ä¸ºçˆ¶èŠ‚ç‚¹çš„æ·±åº¦åŠ ä¸€ p[u][0] = fa; // å½“å‰èŠ‚ç‚¹çš„ 2^0 çº§ç¥–å…ˆä¸ºçˆ¶èŠ‚ç‚¹ // é€’æ¨æ±‚å‡ºå½“å‰èŠ‚ç‚¹çš„ 2^i çº§ç¥–å…ˆ for (int i = 1; i \u0026lt; M; i ++ ) p[u][i] = p[p[u][i - 1]][i - 1]; // éå†å½“å‰èŠ‚ç‚¹çš„æ¯ä¸€ä¸ªå„¿å­ï¼Œé€’å½’è°ƒç”¨ dfs å‡½æ•° for (auto v : g[u]) if (v != fa) // é¿å…å‘çˆ¶èŠ‚ç‚¹é€’å½’ dfs(v, u); } // æ±‚ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ int lca(int a, int b) { if (depth[a] \u0026lt; depth[b]) swap(a, b); // ä¿è¯ a æ·±åº¦ä¸å°äº b // å…ˆå°† a è·³åˆ°å’Œ b åŒä¸€æ·±åº¦ for (int i = M - 1; i \u0026gt;= 0; i -- ) if (depth[p[a][i]] \u0026gt;= depth[b]) a = p[a][i]; if (a == b) return a; // ç‰¹åˆ¤ a å’Œ b åœ¨åŒä¸€æ¡é“¾ä¸Šçš„æƒ…å†µ // ä¸€èµ·å‘ä¸Šè·³ï¼Œç›´åˆ° a å’Œ b çš„ç¬¬ä¸€ä¸ªä¸åŒçš„ç¥–å…ˆ for (int i = M - 1; i \u0026gt;= 0; i -- ) if (p[a][i] != p[b][i]) { a = p[a][i]; b = p[b][i]; } return p[a][0]; // è¿”å› a çš„çˆ¶èŠ‚ç‚¹ï¼Œå³ä¸º LCA } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; // è¯»å…¥èŠ‚ç‚¹æ•°ã€æŸ¥è¯¢æ¬¡æ•°å’Œæ ¹èŠ‚ç‚¹ç¼–å· // é€ä¸ªè¯»å…¥æ¯æ¡è¾¹ï¼Œæ„å»ºæ ‘çš„é‚»æ¥è¡¨è¡¨ç¤º for (int i = 1; i \u0026lt; n; i ++ ) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].push_back(b); g[b].push_back(a); } dfs(s, 0); // æ±‚æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦å’Œç¥–å…ˆä¿¡æ¯ while (m -- ) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // è¯»å…¥æŸ¥è¯¢ cout \u0026lt;\u0026lt; lca(a, b) \u0026lt;\u0026lt; endl; // è¾“å‡º } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/lca/","title":"å€å¢LCAæ¨¡æ¿"},{"content":"æ¨¡æ¿ åªé€‚ç”¨äºæ¨¡æ•°ä¸ºè´¨æ•°çš„æƒ…å†µ(è´¹é©¬å°å®šç†) 1 2 3 4 5 6 7 vector\u0026lt;long long\u0026gt; inv_vec(long long n, long long m) { vector\u0026lt;long long\u0026gt; inv(n + 1, 1); for (long long i = 2; i \u0026lt;= n; i++) { inv[i] = (m - m / i) * inv[m % i] % m; } return inv; } ã€æ¨¡æ¿ã€‘ä¹˜æ³•é€†å…ƒ é¢˜ç›®èƒŒæ™¯ è¿™æ˜¯ä¸€é“æ¨¡æ¿é¢˜\né¢˜ç›®æè¿° ç»™å®š $n,p$ æ±‚ $1\\sim n$ ä¸­æ‰€æœ‰æ•´æ•°åœ¨æ¨¡ $p$ æ„ä¹‰ä¸‹çš„ä¹˜æ³•é€†å…ƒã€‚\nè¿™é‡Œ $a$ æ¨¡ $p$ çš„ä¹˜æ³•é€†å…ƒå®šä¹‰ä¸º $ax\\equiv1\\pmod p$ çš„è§£ã€‚\nè¾“å…¥æ ¼å¼ ä¸€è¡Œä¸¤ä¸ªæ­£æ•´æ•° $n,p$ã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡º $n$ è¡Œï¼Œç¬¬ $i$ è¡Œè¡¨ç¤º $i$ åœ¨æ¨¡ $p$ ä¸‹çš„ä¹˜æ³•é€†å…ƒã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 10 13 æ ·ä¾‹è¾“å‡º #1 1 2 3 4 5 6 7 8 9 10 1 7 9 10 8 11 2 5 3 4 æç¤º $ 1 \\leq n \\leq 3 \\times 10 ^ 6, n \u0026lt; p \u0026lt; 20000528 $\nè¾“å…¥ä¿è¯ $ p $ ä¸ºè´¨æ•°ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;iostream\u0026gt; using namespace std; const int N=3e6+2; long long inv[N]; void inv_vec(long long n, long long m) { inv[0]=1; inv[1]=1; for (long long i = 2; i \u0026lt;= n; i++) { inv[i] = (m - m / i) * inv[m % i] % m; printf(\u0026#34;%lld\\n\u0026#34;,inv[i]); } } int main(){ int n,p; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;p); printf(\u0026#34;1\\n\u0026#34;); inv_vec(n,p); return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/inv2/","title":"ä¹˜æ³•é€†å…ƒé€’æ¨æ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 long long extgcd(long long a, long long b, long long \u0026amp;x, long long \u0026amp;y) { if (b == 0) { x = 1; y = 0; return a; } long long d = extgcd(b, a % b, y, x); y -= a / b * x; return d; } long long inv(long long a, long long m) { long long x, y; if (extgcd(a, m, x, y) != 1) { return -1; // ä¸å­˜åœ¨ä¹˜æ³•é€†å…ƒ } return (x % m + m) % m; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/inv1/","title":"ä¹˜æ³•é€†å…ƒæ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 FOR(p,0,n){ while(!maxs.empty()\u0026amp;\u0026amp;maxs.back()\u0026lt;a[p])maxs.pop_back(); while(!mins.empty()\u0026amp;\u0026amp;mins.back()\u0026gt;a[p])mins.pop_back(); maxs.push_back(a[p]); mins.push_back(a[p]); ans1[p]=maxs.front(); ans2[p]=mins.front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;maxs.front()==a[p-k+1])maxs.pop_front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;mins.front()==a[p-k+1])mins.pop_front(); } æ»‘åŠ¨çª—å£ /ã€æ¨¡æ¿ã€‘å•è°ƒé˜Ÿåˆ— é¢˜ç›®æè¿° æœ‰ä¸€ä¸ªé•¿ä¸º $n$ çš„åºåˆ— $a$ï¼Œä»¥åŠä¸€ä¸ªå¤§å°ä¸º $k$ çš„çª—å£ã€‚ç°åœ¨è¿™ä¸ªä»å·¦è¾¹å¼€å§‹å‘å³æ»‘åŠ¨ï¼Œæ¯æ¬¡æ»‘åŠ¨ä¸€ä¸ªå•ä½ï¼Œæ±‚å‡ºæ¯æ¬¡æ»‘åŠ¨åçª—å£ä¸­çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ã€‚\nä¾‹å¦‚ï¼š\nThe array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$ã€‚\nè¾“å…¥æ ¼å¼ è¾“å…¥ä¸€å…±æœ‰ä¸¤è¡Œï¼Œç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ­£æ•´æ•° $n,k$ã€‚ ç¬¬äºŒè¡Œ $n$ ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºåºåˆ— $a$\nè¾“å‡ºæ ¼å¼ è¾“å‡ºå…±ä¸¤è¡Œï¼Œç¬¬ä¸€è¡Œä¸ºæ¯æ¬¡çª—å£æ»‘åŠ¨çš„æœ€å°å€¼\nç¬¬äºŒè¡Œä¸ºæ¯æ¬¡çª—å£æ»‘åŠ¨çš„æœ€å¤§å€¼\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 8 3 1 3 -1 -3 5 3 6 7 æ ·ä¾‹è¾“å‡º #1 1 2 -1 -3 -3 -3 3 3 3 3 5 5 6 7 æç¤º ã€æ•°æ®èŒƒå›´ã€‘ å¯¹äº $50%$ çš„æ•°æ®ï¼Œ$1 \\le n \\le 10^5$ï¼›\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œ$1\\le k \\le n \\le 10^6$ï¼Œ$a_i \\in [-2^{31},2^{31})$ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int a[N],ans1[N],ans2[N]; deque\u0026lt;int\u0026gt; maxs,mins; int main() { ios int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; FOR(i,0,n){ cin\u0026gt;\u0026gt;a[i]; } FOR(p,0,n){ while(!maxs.empty()\u0026amp;\u0026amp;maxs.back()\u0026lt;a[p])maxs.pop_back(); while(!mins.empty()\u0026amp;\u0026amp;mins.back()\u0026gt;a[p])mins.pop_back(); maxs.push_back(a[p]); mins.push_back(a[p]); ans1[p]=maxs.front(); ans2[p]=mins.front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;maxs.front()==a[p-k+1])maxs.pop_front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;mins.front()==a[p-k+1])mins.pop_front(); } FOR(i,k-1,n){ cout\u0026lt;\u0026lt;ans2[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; FOR(i,k-1,n){ cout\u0026lt;\u0026lt;ans1[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/monotonicqueue/","title":"å•è°ƒé˜Ÿåˆ—æ¨¡æ¿"},{"content":"æ¨¡æ¿1 è¿™ç§æ€è·¯é€šå¸¸ç”¨äºå¯»æ‰¾å³è¾¹çš„æ•°ï¼ˆæ±‚å·¦è¾¹æ—¶å€’å™å³å¯ï¼‰ æ¯æ¬¡stackå¼¹å‡ºæ—¶æ‰è®°å½•ç­”æ¡ˆï¼Œå› æ­¤éœ€è¦ç»´æŠ¤ä¸€ä¸ªæ•°ç»„æˆ–è€…å“ˆå¸Œè¡¨ ç¡®å®šå•è°ƒæ€§ä¸ç›®æ ‡ç›¸åå³å¯ï¼Œè‹¥æ±‚å³æœ€å°ï¼Œå•è°ƒå¢ï¼ˆæ–¹å‘æŒ‡çš„æ˜¯è‡ªåº•å‘é¡¶ï¼Œåé¢åŒï¼‰ï¼Œæœ€å¤§åä¹‹å³å¯ è¿™é‡Œä»¥æ±‚å³è¾¹NGEä¸ºä»£è¡¨ 1 2 3 4 5 6 7 8 9 10 11 12 const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; FOR(i,1,n+1){ while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;a[i]){ b[s.top()]=i; s.pop(); } s.push(i); } } æ¨¡æ¿2 è¿™ç§æ€è·¯é€šå¸¸ç”¨äºå¯»æ‰¾å·¦è¾¹çš„æ•° å¯»æ‰¾å³è¾¹æ—¶ï¼Œåº”åè½¬åˆ—è¡¨ï¼ˆå®é™…ä¸Šå€’å™å³å¯ï¼‰æ¥çœ‹ è¿™ç§å†™æ³•æ¯æ¬¡ç»´æŠ¤åçš„æ ˆé¡¶å³ä½¿ç­”æ¡ˆ è¿™é‡Œä»¥æ±‚å³è¾¹NGEä¸ºä»£è¡¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; for(int i=n;i\u0026gt;0;i--){ //è¿™é‡Œçš„ç­‰å·è¦æ³¨æ„ï¼Œä¸ç„¶å¦‚ 5ï¼Œ5 çš„è¯è¿”å›çš„æ˜¯ 2ï¼Œ0ï¼ˆä¸‹æ ‡ä»1å¼€å§‹ï¼‰ while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;=a[i]){ s.pop(); } if(!s.empty()){ b[i]=s.top(); } s.push(i); } } ã€æ¨¡æ¿ã€‘å•è°ƒæ ˆ é¢˜ç›®èƒŒæ™¯ æ¨¡æ¿é¢˜ï¼Œæ— èƒŒæ™¯ã€‚\n2019.12.12 æ›´æ–°æ•°æ®ï¼Œæ”¾å®½æ—¶é™ï¼Œç°åœ¨ä¸å†å¡å¸¸äº†ã€‚\né¢˜ç›®æè¿° ç»™å‡ºé¡¹æ•°ä¸º $n$ çš„æ•´æ•°æ•°åˆ— $a_{1 \\dots n}$ã€‚\nå®šä¹‰å‡½æ•° $f(i)$ ä»£è¡¨æ•°åˆ—ä¸­ç¬¬ $i$ ä¸ªå…ƒç´ ä¹‹åç¬¬ä¸€ä¸ªå¤§äº $a_i$ çš„å…ƒç´ çš„ä¸‹æ ‡ï¼Œå³ $f(i)=\\min_{i\u0026lt;j\\leq n, a_j \u0026gt; a_i} {j}$ã€‚è‹¥ä¸å­˜åœ¨ï¼Œåˆ™ $f(i)=0$ã€‚\nè¯•æ±‚å‡º $f(1\\dots n)$ã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œä¸€ä¸ªæ­£æ•´æ•° $n$ã€‚\nç¬¬äºŒè¡Œ $n$ ä¸ªæ­£æ•´æ•° $a_{1\\dots n}$ã€‚\nè¾“å‡ºæ ¼å¼ ä¸€è¡Œ $n$ ä¸ªæ•´æ•° $f(1\\dots n)$ çš„å€¼ã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 5 1 4 2 3 5 æ ·ä¾‹è¾“å‡º #1 1 2 5 4 5 0 æç¤º ã€æ•°æ®è§„æ¨¡ä¸çº¦å®šã€‘\nå¯¹äº $30%$ çš„æ•°æ®ï¼Œ$n\\leq 100$ï¼›\nå¯¹äº $60%$ çš„æ•°æ®ï¼Œ$n\\leq 5 \\times 10^3$ ï¼›\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œ$1 \\le n\\leq 3\\times 10^6$ï¼Œ$1\\leq a_i\\leq 10^9$ã€‚\nCODE1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; FOR(i,1,n+1){ while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;a[i]){ b[s.top()]=i; s.pop(); } s.push(i); } } int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,1,n+1)cin\u0026gt;\u0026gt;a[i]; NGE(n); FOR(i,1,n+1)cout\u0026lt;\u0026lt;b[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } CODE2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; for(int i=n;i\u0026gt;0;i--){ while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;=a[i]){ s.pop(); } if(!s.empty()){ b[i]=s.top(); } s.push(i); } } int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,1,n+1)cin\u0026gt;\u0026gt;a[i]; NGE(n); FOR(i,1,n+1)cout\u0026lt;\u0026lt;b[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/monotonicstack/","title":"å•è°ƒæ ˆæ¨¡æ¿"},{"content":"Basic Counting Principles The product rule ä¹˜æ³•åŸç†\nExercise â€¢Prove Theorem: $ if |S| = n, then |P(S)| = 2^n$\nThe sum rule åŠ æ³•åŸç†\nThe Inclusion-Exclusion Principle å®¹æ–¥åŸç†\nThe Pigeonhole Principle æŠ½å±‰åŸç†\nTheorem 1: If k is a positive integer and k + 1 or more objects are placed into k boxes, then there is at least one box containing two or more of the objects.\nTheorem 2: If n objects are placed into k boxes, then there is at least one box containing at least n/k objects.\nPermutation æ’åˆ—ï¼ˆè€ƒè™‘é¡ºåºï¼‰ $P(n, r) = n!/(n âˆ’ r)!$\nCombination ç»„åˆï¼ˆä¸è€ƒè™‘é¡ºåºï¼‰ $C(n, r), or (^n_r)$\néš”æ¿æ³• How many solutions does the equation a + b + c = 11 have where a, b, and c are non-negative integers?\nBinomial Coefficients äºŒé¡¹å¼å®šç†ï¼š Recurrence Relations Linear Homogeneous recurrence relation Theorem 1: Let $c_1$ and $c_2$ be real numbers. Suppose that $r^2 â€“ c_1 â€“ c_2 = 0$ has two distinct roots $r_1$ and $r_2$. Then the sequence ${a_n}$ is a solution of the recurrence relation $a_n= c_1a_{n-1} + c_2a_{n-2}$ if and only if $a_n= k_1r_1^n+k_2r_2^n$ for $n = 0, 1, 2, â€¦,$ where $k_1$ and $k_2$ are constants.\n","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/counting/","title":"ç¦»æ•£æ•°å­¦â€”â€”â€”â€”Counting"},{"content":"æ¬§æ‹‰ç­› 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const int N=100; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } ã€æ¨¡æ¿ã€‘çº¿æ€§ç­›ç´ æ•° é¢˜ç›®èƒŒæ™¯ æœ¬é¢˜å·²æ›´æ–°ï¼Œä»åˆ¤æ–­ç´ æ•°æ”¹ä¸ºäº†æŸ¥è¯¢ç¬¬ $k$ å°çš„ç´ æ•°\næç¤ºï¼šå¦‚æœä½ ä½¿ç”¨ cin æ¥è¯»å…¥ï¼Œå»ºè®®ä½¿ç”¨ std::ios::sync_with_stdio(0) æ¥åŠ é€Ÿã€‚\né¢˜ç›®æè¿° å¦‚é¢˜ï¼Œç»™å®šä¸€ä¸ªèŒƒå›´ $n$ï¼Œæœ‰ $q$ ä¸ªè¯¢é—®ï¼Œæ¯æ¬¡è¾“å‡ºç¬¬ $k$ å°çš„ç´ æ•°ã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•° $n,q$ï¼Œåˆ†åˆ«è¡¨ç¤ºæŸ¥è¯¢çš„èŒƒå›´å’ŒæŸ¥è¯¢çš„ä¸ªæ•°ã€‚\næ¥ä¸‹æ¥ $q$ è¡Œæ¯è¡Œä¸€ä¸ªæ­£æ•´æ•° $k$ï¼Œè¡¨ç¤ºæŸ¥è¯¢ç¬¬ $k$ å°çš„ç´ æ•°ã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡º $q$ è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ­£æ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 100 5 1 2 3 4 5 æ ·ä¾‹è¾“å‡º #1 1 2 3 4 5 2 3 5 7 11 æç¤º ã€æ•°æ®èŒƒå›´ã€‘\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œ$n = 10^8$ï¼Œ$1 \\le q \\le 10^6$ï¼Œä¿è¯æŸ¥è¯¢çš„ç´ æ•°ä¸å¤§äº $n$ã€‚\nData by NaCly_Fish.\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e8; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int main() { ios int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; get_primes(n); while(q--){ int x; cin\u0026gt;\u0026gt;x; cout\u0026lt;\u0026lt;primes[x-1]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/eulersieve/","title":"æ¬§æ‹‰ç­›æ¨¡æ¿"},{"content":"æŒ‰åºåˆå¹¶è·¯å¾„å‹ç¼©ä¼˜åŒ–å¹¶æŸ¥é›† å°è£…æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Buf { public: Buf(int sz) : root(sz), rank(sz) { for (int i = 0; i \u0026lt; sz; i++) { root[i] = i; rank[i] = 1; } } int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] \u0026lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(int x, int y) { return find(x) == find(y); } private: vector\u0026lt;int\u0026gt; root; vector\u0026lt;int\u0026gt; rank; }; éå°è£…æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ll root[MAXN],rank[MAXN],n; void initbuf(ll n){ for (ll i = 0; i \u0026lt; n; i++) { root[i] = i; } } ll find(ll x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(ll x, ll y) { ll rootX = find(x); ll rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) root[rootY] = rootX; else if (rank[rootX] \u0026lt; rank[rootY])root[rootX] = rootY; else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(ll x, ll y) { return find(x) == find(y); } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/buf/","title":"å¹¶æŸ¥é›†æ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 ll qpow(ll a,ll b,ll p){ ll ans=1%p; while(b){ if(b\u0026amp;1)ans=(ans*a)%p; b\u0026gt;\u0026gt;=1; a=(a*a)%p; } return ans; } é¢˜ç›®æè¿° ç»™ä½ ä¸‰ä¸ªæ•´æ•° $a,b,p$ï¼Œæ±‚ $a^b \\bmod p$ã€‚\nè¾“å…¥æ ¼å¼ è¾“å…¥åªæœ‰ä¸€è¡Œä¸‰ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«ä»£è¡¨ $a,b,p$ã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡ºä¸€è¡Œä¸€ä¸ªå­—ç¬¦ä¸² a^b mod p=sï¼Œå…¶ä¸­ $a,b,p$ åˆ†åˆ«ä¸ºé¢˜ç›®ç»™å®šçš„å€¼ï¼Œ $s$ ä¸ºè¿ç®—ç»“æœã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 10 9 æ ·ä¾‹è¾“å‡º #1 1 2^10 mod 9=7 æç¤º æ ·ä¾‹è§£é‡Š\n$2^{10} = 1024$ï¼Œ$1024 \\bmod 9 = 7$ã€‚\næ•°æ®è§„æ¨¡ä¸çº¦å®š\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œä¿è¯ $0\\le a,b \u0026lt; 2^{31}$ï¼Œ$a+b\u0026gt;0$ï¼Œ$2 \\leq p \\lt 2^{31}$ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; ll qpow(ll a,ll b,ll p){ ll ans=1%p; while(b){ if(b\u0026amp;1)ans=(ans*a)%p; b\u0026gt;\u0026gt;=1; a=(a*a)%p; } return ans; } int main() { ios ll a,b,p; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; ll res=qpow(a,b,p); cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;^\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; mod \u0026#34;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#34;=\u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/qpowp/","title":"å¿«é€Ÿå¹‚å–ä½™æ¨¡æ¿"},{"content":" A relation is a structure that is used to represent the relationships between elements\nCategory of relations Binary relations N-ary relations Binary Relations A binary relation R from the set ğ´ to the set ğµ is a subset of ğ´ Ã— ğµ.\nR is a set of ordered pairs in the form (ğ‘, ğ‘) where ğ‘ is from ğ´ and ğ‘ is from ğµ.\na R b denotes (ğ‘, ğ‘) âˆˆ ğ‘…, called ğ‘ is related to ğ‘ by R\nFunctions and Relations Are all the functions relations? Yes Are all relations functions? No Relation on the Set A relation on the set is a relation from ğ´ to ğ´. Properties of Relations Reflexive A relation ğ‘… on a set ğ´ is called reflexive if (ğ‘, ğ‘) âˆˆ ğ‘… for every element ğ‘ âˆˆ A\nSymmetric A relation ğ‘… on a set ğ´ is called symmetric if (ğ‘, ğ‘) âˆˆ ğ‘… whenever (ğ‘, ğ‘) âˆˆ R\nAnti-symmetric relation ğ‘… on a set ğ´ is called anti-symmetric if whenever (ğ‘, ğ‘) âˆˆ ğ‘… and (ğ‘, ğ‘) âˆˆ ğ‘…, then ğ‘ = ğ‘\nTransitive A relation ğ‘… on a set ğ´ is called transitive if whenever (ğ‘, ğ‘) âˆˆ ğ‘… and (ğ‘, ğ‘) âˆˆ ğ‘…, then (ğ‘, ğ‘) âˆˆ ğ‘…\nCombining Relations The composite of ğ‘… and ğ‘† (ğ‘† â—¦ ğ‘…): consisting of all ordered pairs (ğ‘, ğ‘) where ğ‘ âˆˆ ğ´, and ğ‘ âˆˆ ğ¶ if there exists ğ‘ such that (ğ‘, ğ‘) âˆˆ ğ‘… and (ğ‘, ğ‘) âˆˆ ğ‘†.\nE.g.,\nâ–ª ğ´ = {1}, ğµ = {0, 1}, ğ¶ = {2, 3}\nâ–ª ğ‘… = {(1, 0), (1, 1)} (a relation from ğ´ to ğµ)\nâ–ª ğ‘† = {(0, 2), (1, 3)} (a relation from ğµ to ğ¶)\nâ–ª ğ‘† â—¦ ğ‘… = {(1, 2), (1, 3)}\nPowers of a Relation Let ğ‘… be a relation on the set ğ´. The powers ğ‘…ğ‘› for integer ğ‘› with ğ‘› \u0026gt; 0 are defined recursively by $R^1 = R$\n$R^{n}=R^{n-1}â—¦R$\nTheorem: The relation ğ‘… on a set ğ´ is transitive if and only if ğ‘…^ğ‘› âŠ† ğ‘… for ğ‘› = 1, 2, 3, â‹¯\nğ‘›-ary Relations Let ğ´1, ğ´2, â€¦ , ğ´ğ‘› be sets. An ğ‘›-ary relation on these sets is a subset of ğ´1 Ã— ğ´2 Ã— â‹¯ Ã— ğ´ğ‘› Domain: ğ´1 Ã— ğ´2 Ã— â‹¯ Ã— ğ´ğ‘› Degree: n Relations and Database Currently, the most commonly used databases are relational databases. Each database consists of multiple relations. Each relation is presented as a table. Operations on n-ary Relations Selection operator ğœ: ğ‘›-ary relation ğ‘… condition ğ‘ Selection operator ğœğ‘: maps ğ‘… to an ğ‘›-ary relations ğ‘‡, where all the tuples in ğ‘‡ satisfy the condition ğ‘.\ni.e. ğœ_{ğ‘šğ‘ğ‘—ğ‘œğ‘Ÿ}=\u0026ldquo;ğ¶ğ‘œğ‘šğ‘ğ‘¢ğ‘¡ğ‘’ğ‘Ÿ ğ‘†ğ‘ğ‘–ğ‘’ğ‘›ğ‘ğ‘’\u0026rdquo; ğºğ‘Ÿğ‘ğ‘‘ğ‘’ğ‘…ğ‘’ğ‘ğ‘œğ‘Ÿğ‘¡ = {(ğ½ğ‘œâ„ğ‘›,001,ğ¶ğ‘œğ‘šğ‘ğ‘¢ğ‘¡ğ‘’ğ‘Ÿ ğ‘†ğ‘ğ‘–ğ‘’ğ‘›ğ‘ğ‘’, 3.5)} Projection operator ğœ‹: the input relation is on ğ‘› tuples (ğ‘1, ğ‘2, â‹¯ , ğ‘ğ‘›) , the output relation is on ğ‘š tuples (ğ‘ğ‘–_1,ğ‘ğ‘–_2, â‹¯ , ğ‘ğ‘–_ğ‘š), ğ‘š \u0026lt; ğ‘›. Projection operator ğœ‹ğ‘–1,ğ‘–2,â‹¯,ğ‘–ğ‘š: removes the tuples not in the ğ‘š-tuple (ğ‘ğ‘–1ğ‘ğ‘–2, â‹¯ , ğ‘ğ‘–ğ‘š) list i.e. ğœ‹_{ğ‘›ğ‘ğ‘šğ‘’,ğºğ‘ƒğ´} (ğºğ‘Ÿğ‘ğ‘‘ğ‘’ğ‘…ğ‘’ğ‘ğ‘œğ‘Ÿğ‘¡) = {(ğ½ğ‘œâ„ğ‘›, 3.5 ),( ğ‘‡ğ‘œğ‘›ğ‘¦, 3.2 ),( ğ½ğ‘œğ‘›ğ‘ğ‘ , 3.3)} Equivalence Relations A relation on a set ğ´ is called an equivalence relation if it is reflexive, symmetric, and transitive. Let ğ‘… be an equivalence relation on ğ´. Equivalent class Equivalent class -\u0026gt; Equivalent relations\nPartition All the equivalent classes obtained from ğ´ through an equivalent class are either same or disjoint. These disjoint classes are subsets of ğ´. The union of these subsets is ğ´. These subsets are called a partition of A In general, (ğ´1, ğ´2, â‹¯ , ğ´ğ‘›) is a partition of ğ´ if: ğ´ğ‘– â‰  âˆ… for all 1 â‰¤ ğ‘– â‰¤ ğ‘› ğ´ğ‘– âˆ© ğ´ğ‘— = âˆ… for all 1 â‰¤ ğ‘–,ğ‘— â‰¤ ğ‘› ğ´1 âˆª ğ´2 âˆª â‹¯ âˆª ğ´ğ‘› = A Theorem: Let ğ‘… be an equivalence relation on a nonempty set ğ´. The following statements are equivalent:\na R b [ğ‘] = [ğ‘] ğ‘ âˆ© [ğ‘] â‰  âˆ… ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/distcreterelations/","title":"ç¦»æ•£æ•°å­¦â€”â€”Relations"},{"content":"Sets A set is a collection of objects Sets are used to group objects together Three ways to express the members in a set - List all the members - Use predicates - Use suspension(çœç•¥å·)points(must be inferred) universal set $â„•$ : the set of all natural numbers $â„¤$ : the set of integers $â„¤^+$ : the set of all the positive integers $â„š$: the set of all rational numbers $â„$: the set of all the real numbers $â„‚$: the set of all complex numbers Venn Diagrams two basic shapes A rectangle: indicates the universal set Circles or other shapes: indicate normal sets Elements and Sets $AâˆˆB$ : A is in or is an element of B $Aâˆ‰B$ : A is not in or is not an element of B Subsets Subsets Proper subsets(çœŸå­é›†) Empty sets Cardinality number of distinct elements in a set\nThe cardinality of a set s is denoted as |s|\nPower Sets $P(S) = {A|A âŠ† S}$\nTheorem of Power Sets: $ if |S| = n, then |P(S)| = 2^n$\nOrdered n-tuple The form (1, 2, â€¦ , ) or \u0026lt; 1, 2, â€¦ , \u0026gt; (1,2) not equal to (2,1) Cartesian Product(ç¬›å¡å°”ä¹˜ç§¯) Cartesian product of $S_1, S_2, â‹¯ ,S_n (denoted S_1 Ã— S_2 Ã— â‹¯ Ã—S_n )$ $S_1 Ã— S_2 Ã— â‹¯ Ã—S_n = {(a1, a2, â€¦ ,an )|a_1 âˆˆ S_1 âˆ§ a_2 âˆˆ S_2 âˆ§â‹¯ âˆ§ a_n âˆˆ S_n}$\nDisjoint Sets If A âˆ© B = âˆ… then A and B are disjoint. If A âˆ© B â‰  âˆ… then A and B are overlapped. function conditions A function from to is a subset of Ã— which satisfies the following two conditions\n1.$ âˆ€ x(x âˆˆ A â†’ âˆƒ y(y âˆˆ B âˆ§ (x,y) âˆˆf)) $\n2. $ (((x_1,y_1 ) âˆˆ f âˆ§ (x_1,y_2 ) âˆˆ f) â†’ y_1 = y_2)$\nImage, Pre-image and Range(å€¼åŸŸ) If $y = f(x)$ from set A to set B, then\ny is called the image of x under f x is called a pre-image of y the set of all the images of the elements in the domain under is called the range of f, f(A) = {f(x)|x âˆˆ A} injective functionï¼ˆå•å°„ï¼‰ f is one-to-one\nurjective function (æ»¡å°„) Onto function :$âˆ€y âˆˆ B (âˆƒx(x âˆˆA âˆ§f (x) =y ))$\nbijective function (åŒå°„) [One-to-One and onto function] is also called bijective function\nFloor functions Denoted $\\lfloor x \\rfloor$ The largest integer less than or equivalent to x Ceiling functions Denoted $\\lceil x \\rceil$ The smallest integer greater than or equivalent to x Sequences æ•°åˆ— Sequences are ordered lists of elements â€¢ A sequence is a function from a subset of the set of integers ({0, 1, 2, 3, â€¦ } or {1, 2, 3, â€¦ }) to a set , denoted {$a_n$}. The integers determine the positions of the elements in the list\nSummations æ±‚å’Œ A summation is the value of the sum of the terms of a sequence.\nSpecial Summations Geometric series ç­‰æ¯”æ•°åˆ—å’Œ $\\sum^n_{j=0}ar^j$\nharmonic series $\\sum^n_{j=1} \\frac{1}{j}$\n","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/sfss/","title":"ç¦»æ•£æ•°å­¦â€”â€”SFSS"},{"content":"ã€æ¨¡æ¿ã€‘å¹¶æŸ¥é›† é¢˜ç›®æè¿° å¦‚é¢˜ï¼Œç°åœ¨æœ‰ä¸€ä¸ªå¹¶æŸ¥é›†ï¼Œä½ éœ€è¦å®Œæˆåˆå¹¶å’ŒæŸ¥è¯¢æ“ä½œã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° $N,M$ ,è¡¨ç¤ºå…±æœ‰ $N$ ä¸ªå…ƒç´ å’Œ $M$ ä¸ªæ“ä½œã€‚\næ¥ä¸‹æ¥ $M$ è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ•´æ•° $Z_i,X_i,Y_i$ ã€‚\nå½“ $Z_i=1$ æ—¶ï¼Œå°† $X_i$ ä¸ $Y_i$ æ‰€åœ¨çš„é›†åˆåˆå¹¶ã€‚\nå½“ $Z_i=2$ æ—¶ï¼Œè¾“å‡º $X_i$ ä¸ $Y_i$ æ˜¯å¦åœ¨åŒä¸€é›†åˆå†…ï¼Œæ˜¯çš„è¾“å‡º Y ï¼›å¦åˆ™è¾“å‡º N ã€‚\nè¾“å‡ºæ ¼å¼ å¯¹äºæ¯ä¸€ä¸ª $Z_i=2$ çš„æ“ä½œï¼Œéƒ½æœ‰ä¸€è¡Œè¾“å‡ºï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªå¤§å†™å­—æ¯ï¼Œä¸º Y æˆ–è€… N ã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 7 8 4 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 æ ·ä¾‹è¾“å‡º #1 1 2 3 4 N Y N Y æç¤º å¯¹äº $30%$ çš„æ•°æ®ï¼Œ$N \\le 10$ï¼Œ$M \\le 20$ã€‚\nå¯¹äº $70%$ çš„æ•°æ®ï¼Œ$N \\le 100$ï¼Œ$M \\le 10^3$ã€‚\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œ$1\\le N \\le 10^4$ï¼Œ$1\\le M \\le 2\\times 10^5$ï¼Œ$1 \\le X_i, Y_i \\le N$ï¼Œ$Z_i \\in { 1, 2 }$ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; class Buf { public: Buf(int sz) : root(sz), rank(sz) { for (int i = 0; i \u0026lt; sz; i++) { root[i] = i; rank[i] = 1; } } int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] \u0026lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(int x, int y) { return find(x) == find(y); } private: vector\u0026lt;int\u0026gt; root; vector\u0026lt;int\u0026gt; rank; }; int main() { ios int n,m,y,x,z; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; Buf a=Buf(n+1); while(m--){ cin\u0026gt;\u0026gt;z\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(z==1){ a.unionSet(x,y); } else{ if(a.connected(x,y))cout\u0026lt;\u0026lt;\u0026#34;Y\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; cout\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0003/","title":"æ´›è°·0003â€”â€”å¹¶æŸ¥é›†"},{"content":"[TJOI2009] å¼€å…³ é¢˜ç›®æè¿° ç°æœ‰ $n$ ç›ç¯æ’æˆä¸€æ’ï¼Œä»å·¦åˆ°å³ä¾æ¬¡ç¼–å·ä¸ºï¼š$1$ï¼Œ$2$ï¼Œâ€¦â€¦ï¼Œ$n$ã€‚ç„¶åä¾æ¬¡æ‰§è¡Œ $m$ é¡¹æ“ä½œã€‚\næ“ä½œåˆ†ä¸ºä¸¤ç§ï¼š\næŒ‡å®šä¸€ä¸ªåŒºé—´ $[a,b]$ï¼Œç„¶åæ”¹å˜ç¼–å·åœ¨è¿™ä¸ªåŒºé—´å†…çš„ç¯çš„çŠ¶æ€ï¼ˆæŠŠå¼€ç€çš„ç¯å…³ä¸Šï¼Œå…³ç€çš„ç¯æ‰“å¼€ï¼‰ï¼› æŒ‡å®šä¸€ä¸ªåŒºé—´ $[a,b]$ï¼Œè¦æ±‚ä½ è¾“å‡ºè¿™ä¸ªåŒºé—´å†…æœ‰å¤šå°‘ç›ç¯æ˜¯æ‰“å¼€çš„ã€‚ ç¯åœ¨åˆå§‹æ—¶éƒ½æ˜¯å…³ç€çš„ã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ•´æ•° $n$ å’Œ $m$ï¼Œåˆ†åˆ«è¡¨ç¤ºç¯çš„æ•°ç›®å’Œæ“ä½œçš„æ•°ç›®ã€‚\næ¥ä¸‹æ¥æœ‰ $m$ è¡Œï¼Œæ¯è¡Œæœ‰ä¸‰ä¸ªæ•´æ•°ï¼Œä¾æ¬¡ä¸ºï¼š$c$ã€$a$ã€$b$ã€‚å…¶ä¸­ $c$ è¡¨ç¤ºæ“ä½œçš„ç§ç±»ã€‚\nå½“ $c$ çš„å€¼ä¸º $0$ æ—¶ï¼Œè¡¨ç¤ºæ˜¯ç¬¬ä¸€ç§æ“ä½œã€‚ å½“ $c$ çš„å€¼ä¸º $1$ æ—¶ï¼Œè¡¨ç¤ºæ˜¯ç¬¬äºŒç§æ“ä½œã€‚ $a$ å’Œ $b$ åˆ™åˆ†åˆ«è¡¨ç¤ºäº†æ“ä½œåŒºé—´çš„å·¦å³è¾¹ç•Œã€‚\nè¾“å‡ºæ ¼å¼ æ¯å½“é‡åˆ°ç¬¬äºŒç§æ“ä½œæ—¶ï¼Œè¾“å‡ºä¸€è¡Œï¼ŒåŒ…å«ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæ­¤æ—¶åœ¨æŸ¥è¯¢çš„åŒºé—´ä¸­æ‰“å¼€çš„ç¯çš„æ•°ç›®ã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 4 5 0 1 2 0 2 4 1 2 3 0 2 4 1 1 4 æ ·ä¾‹è¾“å‡º #1 1 2 1 2 æç¤º æ•°æ®è§„æ¨¡ä¸çº¦å®š å¯¹äºå…¨éƒ¨çš„æµ‹è¯•ç‚¹ï¼Œä¿è¯ $2\\le n\\le 10^5$ï¼Œ$1\\le m\\le 10^5$ï¼Œ$1\\le a,b\\le n$ï¼Œ$c\\in{0,1}$ã€‚\\\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e5+9; //å¼€4å€ //n ä¸ºç»´æŠ¤çš„æ•°ç»„é•¿åº¦ï¼ŒAä¸ºç»´æŠ¤çš„æ•°ç»„ ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //å¶å­èŠ‚ç‚¹å¯ä»¥ä¸æ›´æ–° if (len \u0026lt;= 1) return; //å‘ä¸‹ä¼ é€’lazyæ ‡è®° if(mark[p]%2)tree[p \u0026lt;\u0026lt; 1] = (len - len / 2)-tree[p\u0026lt;\u0026lt;1]; mark[p \u0026lt;\u0026lt; 1] += mark[p]%2; if(mark[p]%2)tree[p \u0026lt;\u0026lt; 1 | 1] = (len / 2)-tree[p\u0026lt;\u0026lt;1|1]; mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]%2; //å‘ä¸‹ä¼ é€’äº†ï¼Œè‡ªç„¶æ¸…é™¤è‡ªèº«çš„tag mark[p] = 0; } void push_up(int p){ //è¿™é‡Œç»´æŠ¤çš„æ˜¯åŒºé—´å’Œ tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //å¦‚æœå¶å­èŠ‚ç‚¹ if (cl == cr) return void(tree[p] = A[cl]); //å·¦å³é€’å½’å»ºæ ‘ int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] = d * (cr - cl + 1)-tree[p]; mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } int main() { ios int m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; build(); int op,x,y; while(m--){ cin\u0026gt;\u0026gt;op; if(op==0){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; update(x,y,1); } else{ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll res=query(x,y); cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0004/","title":"æ´›è°·0004â€”â€”[TJOI2009] å¼€å…³"},{"content":"ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1 é¢˜ç›®æè¿° å¦‚é¢˜ï¼Œå·²çŸ¥ä¸€ä¸ªæ•°åˆ—ï¼Œä½ éœ€è¦è¿›è¡Œä¸‹é¢ä¸¤ç§æ“ä½œï¼š\nå°†æŸåŒºé—´æ¯ä¸€ä¸ªæ•°åŠ ä¸Š $k$ã€‚ æ±‚å‡ºæŸåŒºé—´æ¯ä¸€ä¸ªæ•°çš„å’Œã€‚ è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° $n, m$ï¼Œåˆ†åˆ«è¡¨ç¤ºè¯¥æ•°åˆ—æ•°å­—çš„ä¸ªæ•°å’Œæ“ä½œçš„æ€»ä¸ªæ•°ã€‚\nç¬¬äºŒè¡ŒåŒ…å« $n$ ä¸ªç”¨ç©ºæ ¼åˆ†éš”çš„æ•´æ•°ï¼Œå…¶ä¸­ç¬¬ $i$ ä¸ªæ•°å­—è¡¨ç¤ºæ•°åˆ—ç¬¬ $i$ é¡¹çš„åˆå§‹å€¼ã€‚\næ¥ä¸‹æ¥ $m$ è¡Œæ¯è¡ŒåŒ…å« $3$ æˆ– $4$ ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºä¸€ä¸ªæ“ä½œï¼Œå…·ä½“å¦‚ä¸‹ï¼š\n1 x y kï¼šå°†åŒºé—´ $[x, y]$ å†…æ¯ä¸ªæ•°åŠ ä¸Š $k$ã€‚ 2 x yï¼šè¾“å‡ºåŒºé—´ $[x, y]$ å†…æ¯ä¸ªæ•°çš„å’Œã€‚ è¾“å‡ºæ ¼å¼ è¾“å‡ºåŒ…å«è‹¥å¹²è¡Œæ•´æ•°ï¼Œå³ä¸ºæ‰€æœ‰æ“ä½œ 2 çš„ç»“æœã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 7 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 æ ·ä¾‹è¾“å‡º #1 1 2 3 11 8 20 æç¤º å¯¹äº $30%$ çš„æ•°æ®ï¼š$n \\le 8$ï¼Œ$m \\le 10$ã€‚\nå¯¹äº $70%$ çš„æ•°æ®ï¼š$n \\le {10}^3$ï¼Œ$m \\le {10}^4$ã€‚\nå¯¹äº $100%$ çš„æ•°æ®ï¼š$1 \\le n, m \\le {10}^5$ã€‚\nä¿è¯ä»»æ„æ—¶åˆ»æ•°åˆ—ä¸­æ‰€æœ‰å…ƒç´ çš„ç»å¯¹å€¼ä¹‹å’Œ $\\le {10}^{18}$ã€‚\nã€æ ·ä¾‹è§£é‡Šã€‘\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e5+9; //å¼€4å€ //n ä¸ºç»´æŠ¤çš„æ•°ç»„é•¿åº¦ï¼ŒAä¸ºç»´æŠ¤çš„æ•°ç»„ ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //å¶å­èŠ‚ç‚¹å¯ä»¥ä¸æ›´æ–° if (len \u0026lt;= 1) return; //å‘ä¸‹ä¼ é€’lazyæ ‡è®° tree[p \u0026lt;\u0026lt; 1] += mark[p] * (len - len / 2); mark[p \u0026lt;\u0026lt; 1] += mark[p]; tree[p \u0026lt;\u0026lt; 1 | 1] += mark[p] * (len / 2); mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]; //å‘ä¸‹ä¼ é€’äº†ï¼Œè‡ªç„¶æ¸…é™¤è‡ªèº«çš„tag mark[p] = 0; } void push_up(int p){ //è¿™é‡Œç»´æŠ¤çš„æ˜¯åŒºé—´å’Œ tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //å¦‚æœå¶å­èŠ‚ç‚¹ if (cl == cr) return void(tree[p] = A[cl]); //å·¦å³é€’å½’å»ºæ ‘ int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] += d * (cr - cl + 1); mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } int main() { ios int m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; FOR(i,1,n+1){ cin\u0026gt;\u0026gt;A[i]; } build(); int op,x,y,k; while(m--){ cin\u0026gt;\u0026gt;op; if(op==1){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;k; update(x,y,k); } else{ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll res=query(x,y); cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0005/","title":"æ´›è°·0005â€”â€”ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1"},{"content":"å°è£…æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class FenwickTree{ public: int n; vector\u0026lt;int\u0026gt; tree; FenwickTree(int i): n(i),tree(i+1){ for(int a=0;a\u0026lt;=i;a++){ tree[a]=0; } } void update(int i,int val){ while(i\u0026lt;=n){ tree[i]+=val; i+=i\u0026amp;(-i); } } int query(int i){ int res=0; while(i\u0026gt;0){ res+=tree[i]; i-=i\u0026amp;(-i); } return res; } } éå°è£…æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //nä¸ºå®é™…é•¿åº¦ ll tree[MAXN],n; void update(int i,int val){ while(i\u0026lt;=n){ tree[i]+=val; i+=i\u0026amp;(-i); } } int query(int i){ int res=0; while(i\u0026gt;0){ res+=tree[i]; i-=i\u0026amp;(-i); } return res; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/fenwicktree/","title":"æ ‘çŠ¶æ•°ç»„æ¨¡æ¿"},{"content":"lazyçº¿æ®µæ ‘æ¨¡æ¿ åŒºé—´ä¿®æ”¹logn åŒºé—´æŸ¥è¯¢logn ï¼ˆç»´æŠ¤å­˜åœ¨äº¤æ¢å¾‹çš„ä¿¡æ¯ï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 const int MAXN=1e5+9; //å¼€4å€ //n ä¸ºç»´æŠ¤çš„æ•°ç»„é•¿åº¦ï¼ŒAä¸ºç»´æŠ¤çš„æ•°ç»„ ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //å¶å­èŠ‚ç‚¹å¯ä»¥ä¸æ›´æ–° if (len \u0026lt;= 1) return; //å‘ä¸‹ä¼ é€’lazyæ ‡è®° tree[p \u0026lt;\u0026lt; 1] += mark[p] * (len - len / 2); mark[p \u0026lt;\u0026lt; 1] += mark[p]; tree[p \u0026lt;\u0026lt; 1 | 1] += mark[p] * (len / 2); mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]; //å‘ä¸‹ä¼ é€’äº†ï¼Œè‡ªç„¶æ¸…é™¤è‡ªèº«çš„tag mark[p] = 0; } void push_up(int p){ //è¿™é‡Œç»´æŠ¤çš„æ˜¯åŒºé—´å’Œ tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //å¦‚æœå¶å­èŠ‚ç‚¹ if (cl == cr) return void(tree[p] = A[cl]); //å·¦å³é€’å½’å»ºæ ‘ int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] += d * (cr - cl + 1); mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/segmenttree/","title":"çº¿æ®µæ ‘æ¨¡æ¿"},{"content":"ã€æ·±è¿›1.ä¾‹1ã€‘æ±‚åŒºé—´å’Œ é¢˜ç›®æè¿° ç»™å®š $n$ ä¸ªæ­£æ•´æ•°ç»„æˆçš„æ•°åˆ— $a_1, a_2, \\cdots, a_n$ å’Œ $m$ ä¸ªåŒºé—´ $[l_i,r_i]$ï¼Œåˆ†åˆ«æ±‚è¿™ $m$ ä¸ªåŒºé—´çš„åŒºé—´å’Œã€‚å¯¹äºæ‰€æœ‰æµ‹è¯•æ•°æ®ï¼Œ$n,m\\le10^5,a_i\\le 10^4$\nè¾“å…¥æ ¼å¼ å…± $n+m+2$ è¡Œã€‚\nç¬¬ä¸€è¡Œï¼Œä¸ºä¸€ä¸ªæ­£æ•´æ•° $n$ ã€‚\nç¬¬äºŒè¡Œï¼Œä¸º $n$ ä¸ªæ­£æ•´æ•° $a_1,a_2, \\cdots ,a_n$\nç¬¬ä¸‰è¡Œï¼Œä¸ºä¸€ä¸ªæ­£æ•´æ•° $m$ ã€‚\nç¬¬ $4$ åˆ°ç¬¬ $n+m+2$ è¡Œï¼Œæ¯è¡Œä¸ºä¸¤ä¸ªæ­£æ•´æ•° $l_i,r_i$ ï¼Œæ»¡è¶³$1\\le l_i\\le r_i\\le n$\nè¾“å‡ºæ ¼å¼ å…± $m$ è¡Œã€‚\nç¬¬ $i$ è¡Œä¸ºç¬¬ $i$ ç»„ç­”æ¡ˆçš„è¯¢é—®ã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 4 4 3 2 1 2 1 4 2 3 æ ·ä¾‹è¾“å‡º #1 1 2 10 5 æç¤º æ ·ä¾‹è§£é‡Šï¼šç¬¬ 1 åˆ°ç¬¬ 4 ä¸ªæ•°åŠ èµ·æ¥å’Œä¸º 10ã€‚ç¬¬ 2 ä¸ªæ•°åˆ°ç¬¬ 3 ä¸ªæ•°åŠ èµ·æ¥å’Œä¸º5ã€‚\nå¯¹äº 50% çš„æ•°æ®ï¼š$n,m\\le 1000$ ï¼›\nå¯¹äº100% çš„æ•°æ®ï¼š$n.m\\le 10^5,a_i\\le 10^4$\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+3; int a[N]; int b[N]; int main() { ios int n,m; cin\u0026gt;\u0026gt;n; FOR(i,0,n){ cin\u0026gt;\u0026gt;a[i]; } FOR(i,1,n+1){ b[i]=b[i-1]+a[i-1]; } cin\u0026gt;\u0026gt;m; int l,r; FOR(i,0,m){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;b[r]-b[l-1]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0001/","title":"æ´›è°·0001â€”â€”æ±‚åŒºé—´å’Œ"},{"content":"æœ€å¤§åŠ æƒçŸ©å½¢ é¢˜ç›®æè¿° ä¸ºäº†æ›´å¥½çš„å¤‡æˆ˜ NOIP2013ï¼Œç”µè„‘ç»„çš„å‡ ä¸ªå¥³å­©å­ LYQ,ZSC,ZHQ è®¤ä¸ºï¼Œæˆ‘ä»¬ä¸å…‰éœ€è¦æœºæˆ¿ï¼Œæˆ‘ä»¬è¿˜éœ€è¦è¿åŠ¨ï¼Œäºæ˜¯å°±å†³å®šæ‰¾æ ¡é•¿ç”³è¯·ä¸€å—ç”µè„‘ç»„çš„è¯¾ä½™è¿åŠ¨åœºåœ°ï¼Œå¬è¯´å¥¹ä»¬éƒ½æ˜¯ç”µè„‘ç»„çš„é«˜æ‰‹ï¼Œæ ¡é•¿æ²¡æœ‰é©¬ä¸Šç­”åº”ä»–ä»¬ï¼Œè€Œæ˜¯å…ˆç»™å¥¹ä»¬å‡ºäº†ä¸€é“æ•°å­¦é¢˜ï¼Œå¹¶ä¸”å‘Šè¯‰å¥¹ä»¬ï¼šä½ ä»¬èƒ½è·å¾—çš„è¿åŠ¨åœºåœ°çš„é¢ç§¯å°±æ˜¯ä½ ä»¬èƒ½æ‰¾åˆ°çš„è¿™ä¸ªæœ€å¤§çš„æ•°å­—ã€‚\næ ¡é•¿å…ˆç»™ä»–ä»¬ä¸€ä¸ª $n\\times n$ çŸ©é˜µã€‚è¦æ±‚çŸ©é˜µä¸­æœ€å¤§åŠ æƒçŸ©å½¢ï¼Œå³çŸ©é˜µçš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½æœ‰ä¸€æƒå€¼ï¼Œæƒå€¼å®šä¹‰åœ¨æ•´æ•°é›†ä¸Šã€‚ä»ä¸­æ‰¾ä¸€çŸ©å½¢ï¼ŒçŸ©å½¢å¤§å°æ— é™åˆ¶ï¼Œæ˜¯å…¶ä¸­åŒ…å«çš„æ‰€æœ‰å…ƒç´ çš„å’Œæœ€å¤§ ã€‚çŸ©é˜µçš„æ¯ä¸ªå…ƒç´ å±äº $[-127,127]$ ,ä¾‹å¦‚\n1 2 3 4 0 â€“2 â€“7 0 9 2 â€“6 2 -4 1 â€“4 1 -1 8 0 â€“2 åœ¨å·¦ä¸‹è§’ï¼š\n1 2 3 9 2 -4 1 -1 8 å’Œä¸º $15$ã€‚\nå‡ ä¸ªå¥³å­©å­æœ‰ç‚¹çŠ¯éš¾äº†ï¼Œäºæ˜¯å°±æ‰¾åˆ°äº†ç”µè„‘ç»„ç²¾æ‰“ç»†ç®—çš„ HZHï¼ŒTZY å°æœ‹å‹å¸®å¿™è®¡ç®—ï¼Œä½†æ˜¯é—æ†¾çš„æ˜¯ä»–ä»¬çš„ç­”æ¡ˆéƒ½ä¸ä¸€æ ·ï¼Œæ¶‰åŠåœŸåœ°çš„äº‹æƒ…æˆ‘ä»¬å¯ä¸èƒ½å«ç³Šï¼Œä½ èƒ½å¸®å¿™è®¡ç®—å‡ºæ ¡é•¿æ‰€ç»™çš„çŸ©å½¢ä¸­åŠ æƒå’Œæœ€å¤§çš„çŸ©å½¢å—ï¼Ÿ\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œï¼š$n$ï¼Œæ¥ä¸‹æ¥æ˜¯ $n$ è¡Œ $n$ åˆ—çš„çŸ©é˜µã€‚\nè¾“å‡ºæ ¼å¼ æœ€å¤§çŸ©å½¢ï¼ˆå­çŸ©é˜µï¼‰çš„å’Œã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 æ ·ä¾‹è¾“å‡º #1 1 15 æç¤º $1 \\leq n\\le 120$\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=123; int a[N][N]; int b[N][N]; int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,0,n){ FOR(j,0,n){ cin\u0026gt;\u0026gt;a[i][j]; } } FOR(i,1,n+1){ FOR(j,1,n+1){ b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i-1][j-1]; } } int ans=-inf; FOR(x1,1,n+1){ FOR(y1,1,n+1){ FOR(x2,x1,n+1){ FOR(y2,y1,n+1){ ans=max(ans,b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1]); } } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0002/","title":"æ´›è°·0002â€”â€”æœ€å¤§åŠ æƒçŸ©å½¢"},{"content":"å˜é‡ç±»å‹ Local Variables æ–¹æ³•ä½“å†…\nInstance Variables æˆå‘˜å˜é‡,ç±»ä¸­æ–¹æ³•ä½“å¤–\nClass Variables ç±»å˜é‡,é™æ€æˆå‘˜å˜é‡,åŒä¸€ç§ç±»åªæœ‰ä¸€ä»½æ‹·è´\nParameters ä¼ å‚\nå¸¸é‡ finalä¿®é¥°,ä¸èƒ½æ›´æ”¹\nä¿®é¥°ç¬¦1 è®¿é—®ä¿®é¥°ç¬¦ default(ä»€ä¹ˆä¹Ÿä¸å†™): åœ¨åŒä¸€åŒ…å†…å¯è§ï¼Œä¸ä½¿ç”¨ä»»ä½•ä¿®é¥°ç¬¦ã€‚ä½¿ç”¨å¯¹è±¡ï¼šç±»ã€æ¥å£ã€å˜é‡ã€æ–¹æ³•ã€‚\nprivate : åœ¨åŒä¸€ç±»å†…å¯è§ã€‚ä½¿ç”¨å¯¹è±¡ï¼šå˜é‡ã€æ–¹æ³•ã€‚ æ³¨æ„ï¼šä¸èƒ½ä¿®é¥°ç±»ï¼ˆå¤–éƒ¨ç±»ï¼‰\npublic : å¯¹æ‰€æœ‰ç±»å¯è§ã€‚ä½¿ç”¨å¯¹è±¡ï¼šç±»ã€æ¥å£ã€å˜é‡ã€æ–¹æ³•\nprotected : å¯¹åŒä¸€åŒ…å†…çš„ç±»å’Œæ‰€æœ‰å­ç±»å¯è§ã€‚ä½¿ç”¨å¯¹è±¡ï¼šå˜é‡ã€æ–¹æ³•ã€‚ æ³¨æ„ï¼šä¸èƒ½ä¿®é¥°ç±»ï¼ˆå¤–éƒ¨ç±»ï¼‰\néè®¿é—®ä¿®é¥°ç¬¦ static ä¿®é¥°ç¬¦ ç”¨æ¥ä¿®é¥°ç±»æ–¹æ³•å’Œç±»å˜é‡ã€‚\né™æ€å˜é‡ static å…³é”®å­—ç”¨æ¥å£°æ˜ç‹¬ç«‹äºå¯¹è±¡çš„é™æ€å˜é‡ï¼Œæ— è®ºä¸€ä¸ªç±»å®ä¾‹åŒ–å¤šå°‘å¯¹è±¡ï¼Œå®ƒçš„é™æ€å˜é‡åªæœ‰ä¸€ä»½æ‹·è´ã€‚ é™æ€å˜é‡ä¹Ÿè¢«ç§°ä¸ºç±»å˜é‡ã€‚å±€éƒ¨å˜é‡ä¸èƒ½è¢«å£°æ˜ä¸º static å˜é‡ã€‚\né™æ€æ–¹æ³• static å…³é”®å­—ç”¨æ¥å£°æ˜ç‹¬ç«‹äºå¯¹è±¡çš„é™æ€æ–¹æ³•ã€‚é™æ€æ–¹æ³•ä¸èƒ½ä½¿ç”¨ç±»çš„éé™æ€å˜é‡ã€‚é™æ€æ–¹æ³•ä»å‚æ•°åˆ—è¡¨å¾—åˆ°æ•°æ®ï¼Œç„¶åè®¡ç®—è¿™äº›æ•°æ®ã€‚\nfinal ä¿®é¥°ç¬¦ ç”¨æ¥ä¿®é¥°ç±»ã€æ–¹æ³•å’Œå˜é‡ï¼Œfinal ä¿®é¥°çš„ç±»ä¸èƒ½å¤Ÿè¢«ç»§æ‰¿ï¼Œä¿®é¥°çš„æ–¹æ³•ä¸èƒ½è¢«ç»§æ‰¿ç±»é‡æ–°å®šä¹‰ï¼Œä¿®é¥°çš„å˜é‡ä¸ºå¸¸é‡ï¼Œæ˜¯ä¸å¯ä¿®æ”¹çš„ã€‚\nfinalå˜é‡ final ä¿®é¥°ç¬¦é€šå¸¸å’Œ static ä¿®é¥°ç¬¦ä¸€èµ·ä½¿ç”¨æ¥åˆ›å»ºç±»å¸¸é‡ã€‚\nfinalæ–¹æ³• çˆ¶ç±»ä¸­çš„ final æ–¹æ³•å¯ä»¥è¢«å­ç±»ç»§æ‰¿ï¼Œä½†æ˜¯ä¸èƒ½è¢«å­ç±»é‡å†™ abstract ä¿®é¥°ç¬¦ï¼Œç”¨æ¥åˆ›å»ºæŠ½è±¡ç±»å’ŒæŠ½è±¡æ–¹æ³•ã€‚\nabstractä¿®é¥°ç¬¦ è¯¦è§æŠ½è±¡\nç»§æ‰¿ å…³é”®è¯ extends è°ƒç”¨çˆ¶ç±»æ–¹æ³• super æˆ‘ä»¬å¯ä»¥é€šè¿‡superå…³é”®å­—æ¥å®ç°å¯¹çˆ¶ç±»æˆå‘˜çš„è®¿é—®ï¼Œç”¨æ¥å¼•ç”¨å½“å‰å¯¹è±¡çš„çˆ¶ç±»ã€‚\nåœ¨æ„é€ ä¸­å­ç±»æ˜¯ä¸ç»§æ‰¿çˆ¶ç±»çš„æ„é€ å™¨ï¼ˆæ„é€ æ–¹æ³•æˆ–è€…æ„é€ å‡½æ•°ï¼‰çš„ï¼Œå®ƒåªæ˜¯è°ƒç”¨ï¼ˆéšå¼æˆ–æ˜¾å¼ï¼‰ã€‚å¦‚æœçˆ¶ç±»çš„æ„é€ å™¨å¸¦æœ‰å‚æ•°ï¼Œåˆ™å¿…é¡»åœ¨å­ç±»çš„æ„é€ å™¨ä¸­æ˜¾å¼åœ°é€šè¿‡ super å…³é”®å­—è°ƒç”¨çˆ¶ç±»çš„æ„é€ å™¨å¹¶é…ä»¥é€‚å½“çš„å‚æ•°åˆ—è¡¨ã€‚å¦‚æœçˆ¶ç±»æ„é€ å™¨æ²¡æœ‰å‚æ•°ï¼Œåˆ™åœ¨å­ç±»çš„æ„é€ å™¨ä¸­ä¸éœ€è¦ä½¿ç”¨ super å…³é”®å­—è°ƒç”¨çˆ¶ç±»æ„é€ å™¨ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è°ƒç”¨çˆ¶ç±»çš„æ— å‚æ„é€ å™¨ã€‚2\nè®°å¾—superæ”¾åœ¨æ„é€ å™¨çš„ç¬¬ä¸€è¡Œ\nå…³é”®è¯this thiså…³é”®å­—ï¼šæŒ‡å‘è‡ªå·±çš„å¼•ç”¨ã€‚ å¦å¤–å‚æ•°å˜é‡åå’Œæˆå‘˜å˜é‡åé‡å¤çš„æ—¶å€™å¸¸ä½¿ç”¨thiså…³é”®è¯åŒºåˆ†\nOverride ä¸ Overload é‡å†™æ–¹æ³• è¿”å›å€¼å’Œå½¢å‚ä¸èƒ½æ”¹ æŠ›å‡ºçš„å¼‚å¸¸ä¸èƒ½å˜å¾—æ¯”çˆ¶ç±»å¹¿æ³› é‡è½½æ–¹æ³• è®¿é—®æƒé™ä¸èƒ½æ›´å° å…¥å‚ä¸èƒ½æ”¹ è¿”å›å€¼å¯ä»¥ä¸åŒ(ä½†æ˜¯å¿…é¡»æ˜¯çˆ¶ç±»è¿”å›å€¼çš„æ´¾ç”Ÿç±») æŠ›å‡ºçš„å¼‚å¸¸å¯ä»¥æ”¹å˜ upcase å’Œ downcase upcase:å­ç±»å¯ä»¥è½¬ä¸ºçˆ¶ç±»ç±»å‹ downcase: åªæœ‰ç”±å­ç±»è½¬æˆçˆ¶ç±»çš„çˆ¶ç±»æ‰å¯ä»¥è½¬ä¸ºå­ç±» å…³é”®è¯instanceof A istanseof Class,å…¶ä¸­ A ä¸ºä¸€ä¸ªå¯¹è±¡ï¼ŒClass è¡¨ç¤ºä¸€ä¸ªç±»æˆ–è€…ä¸€ä¸ªæ¥å£ï¼Œå½“ obj ä¸º Class çš„å¯¹è±¡ï¼Œæˆ–è€…æ˜¯å…¶ç›´æ¥æˆ–é—´æ¥å­ç±»ï¼Œæˆ–è€…æ˜¯å…¶æ¥å£çš„å®ç°ç±»ï¼Œç»“æœéƒ½è¿”å› trueï¼Œå¦åˆ™è¿”å›falseã€‚\næ³¨æ„ javaä¸­ä¸èƒ½å¤šç»§æ‰¿\næŠ½è±¡ å…³é”®è¯abstract ç‰¹ç‚¹ ä¸èƒ½å®ä¾‹åŒ–å¯¹è±¡\næŠ½è±¡æ–¹æ³•ç‰¹ç‚¹ å¦‚æœä¸€ä¸ªç±»åŒ…å«æŠ½è±¡æ–¹æ³•ï¼Œé‚£ä¹ˆè¯¥ç±»å¿…é¡»æ˜¯æŠ½è±¡ç±»ã€‚ ä»»ä½•å­ç±»å¿…é¡»é‡å†™çˆ¶ç±»çš„æŠ½è±¡æ–¹æ³•ï¼Œæˆ–è€…å£°æ˜è‡ªèº«ä¸ºæŠ½è±¡ç±» æ„é€ æ–¹æ³•ï¼Œç±»æ–¹æ³•ï¼ˆç”¨ static ä¿®é¥°çš„æ–¹æ³•ï¼‰ä¸èƒ½å£°æ˜ä¸ºæŠ½è±¡æ–¹æ³• 1 2 3 public abstract class A{ public abstract void ToDo(); } æ¥å£ ç‰¹ç‚¹ éƒ½ä¸ºæŠ½è±¡æ–¹æ³• ä¸æ”¯æŒéfinal/staticä¿®é¥°çš„å˜é‡(ä¸å†™é»˜è®¤ä¸ºstatic final) ä¸éœ€è¦å†™å‡ºabstract ç»§æ‰¿ æ¥å£ç»§æ‰¿æ¥å£:extends3 æ¥å£å…è®¸å¤šç»§æ‰¿\næ¥å£çš„å®ç° å…³é”®è¯:implements ç±»å¯ä»¥å®ç°å¤šä¸ªæ¥å£\nå¼‚å¸¸å¤„ç† å¼‚å¸¸æ•è· 1 2 3 4 5 6 7 8 9 10 11 try{ // ç¨‹åºä»£ç  }catch(å¼‚å¸¸ç±»å‹1 å¼‚å¸¸çš„å˜é‡å1){ // ç¨‹åºä»£ç  }catch(å¼‚å¸¸ç±»å‹2 å¼‚å¸¸çš„å˜é‡å2){ // ç¨‹åºä»£ç  }catch(å¼‚å¸¸ç±»å‹3 å¼‚å¸¸çš„å˜é‡å3){ // ç¨‹åºä»£ç  }finally{ //to-do } finallyæ— è®ºæ˜¯å¦try/catchéƒ½ä¼šè§¦å‘\ntry ä»£ç åä¸èƒ½æ—¢æ²¡catchä¹Ÿæ²¡finally\nthrow throw new Exception(\u0026quot;aaa\u0026quot;);\nthrows è¡¨æ˜å¯èƒ½æŠ›å‡ºå¼‚å¸¸\nå¸¸ç”¨ e.getMessage() è·å–eä¸­çš„å­—ç¬¦ä¸²\nè‡ªå®šä¹‰å¼‚å¸¸ è¿™é‡Œåªå¤„ç†æ£€æµ‹æ€§å¼‚å¸¸\næ¨¡æ¿ 1 2 3 4 5 public class A extends Exception{ public A(String s){ super(s); } } æ³›å‹ æ³›å‹æ ‡è®°ç¬¦ E - Element (åœ¨é›†åˆä¸­ä½¿ç”¨ï¼Œå› ä¸ºé›†åˆä¸­å­˜æ”¾çš„æ˜¯å…ƒç´ ) T - Typeï¼ˆJava ç±»ï¼‰ K - Keyï¼ˆé”®ï¼‰ V - Valueï¼ˆå€¼ï¼‰ N - Numberï¼ˆæ•°å€¼ç±»å‹ï¼‰ ï¼Ÿ - è¡¨ç¤ºä¸ç¡®å®šçš„ java ç±»å‹\næ³›å‹ä¸Šé™/ä¸‹é™ \u0026lt;T extends/implements B\u0026gt; è¡¨ç¤ºæ³›å‹åº”ä¸ºBæˆ–Bçš„å­ç±»\n\u0026lt;T super B\u0026gt; è¡¨ç¤ºæ³›å‹åº”ä¸ºBæˆ–Bçš„çˆ¶ç±»\næ³›å‹ç±»ä¸æ³›å‹æ–¹æ³• 1 2 3 4 5 6 7 public class A\u0026lt;T\u0026gt;{ //todo } public \u0026lt;T\u0026gt; void ff(T t1,T t2){ //todo } å­—ç¬¦ä¸² å­—ç¬¦ä¸²ç›¸ç­‰ equals()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //æºè‡ªèœé¸Ÿæ•™ç¨‹ String s1 = \u0026#34;Hello\u0026#34;; // String ç›´æ¥åˆ›å»º String s2 = \u0026#34;Hello\u0026#34;; // String ç›´æ¥åˆ›å»º String s3 = s1; // ç›¸åŒå¼•ç”¨ String s4 = new String(\u0026#34;Hello\u0026#34;); // String å¯¹è±¡åˆ›å»º String s5 = new String(\u0026#34;Hello\u0026#34;); // String å¯¹è±¡åˆ›å»º s1 == s1; // true, ç›¸åŒå¼•ç”¨ s1 == s2; // true, s1 å’Œ s2 éƒ½åœ¨å…¬å…±æ± ä¸­ï¼Œå¼•ç”¨ç›¸åŒ s1 == s3; // true, s3 ä¸ s1 å¼•ç”¨ç›¸åŒ s1 == s4; // false, ä¸åŒå¼•ç”¨åœ°å€ s4 == s5; // false, å †ä¸­ä¸åŒå¼•ç”¨åœ°å€ s1.equals(s3); // true, ç›¸åŒå†…å®¹ s1.equals(s4); // true, ç›¸åŒå†…å®¹ s4.equals(s5); // true, ç›¸åŒå†…å®¹ å¯å˜æ•°ç»„ 1 import java.util.ArrayList; ArrayList\u0026lt;String\u0026gt; sites = new ArrayList\u0026lt;String\u0026gt;(); get()è®¿é—®å…ƒç´  set(i,\u0026ldquo;xxx\u0026rdquo;)ä¿®æ”¹å…ƒç´  add()æ·»åŠ å…ƒç´  remove(i)åˆ é™¤ä¸‹æ ‡ä¸ºiçš„å…ƒç´  removeAll()åˆ é™¤æ‰€æœ‰å…ƒç´  size()å¤§å°\næ‘˜è‡ªèœé¸Ÿæ•™ç¨‹\u0026#160;\u0026#x21a9;\u0026#xfe0e;\næ‘˜è‡ªèœé¸Ÿæ•™ç¨‹\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nè¯·ä¸æ¥å£çš„å®ç°åŒºåˆ†\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/oop-java/","title":"é¢å‘å¯¹è±¡ä¸Java"},{"content":"ä¸€ç»´å‰ç¼€å’Œ 1 2 3 // S[i] = a[1] + a[2] + ... a[i] // a[l] + ... + a[r] = S[r] - S[l - 1] S[r] - S[l - 1] äºŒç»´å‰ç¼€å’Œ 1 2 3 4 // S[i, j] = ç¬¬iè¡Œjåˆ—æ ¼å­å·¦ä¸Šéƒ¨åˆ†æ‰€æœ‰å…ƒç´ çš„å’Œ b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j] // ä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µçš„å’Œä¸ºï¼š b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1] ä¸€ç»´å·®åˆ† 1 2 // ç»™åŒºé—´[l, r]ä¸­çš„æ¯ä¸ªæ•°åŠ ä¸Šcï¼š B[l] += c, B[r + 1] -= c äºŒç»´å·®åˆ† 1 2 // ç»™ä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ åŠ ä¸Šcï¼š S[x1][y1] += c, S[x2 + 1][y1] -= c, S[x1][y2 + 1] -= c, S[x2 + 1][y2 + 1] += c tips ä»1å¼€å§‹ï¼Œ0å¼€å¤§ï¼Œé˜²ç‰¹åˆ¤ ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/presum/","title":"å‰ç¼€å’Œä¸å·®åˆ†æ¨¡æ¿"},{"content":" A tree is a connected undirected simple graph that contains no simple circuits.\nRooted Trees concept A rooted tree is a tree in which one node has been designated the root.\nEvery edge is directed away from the root.\nGiven a vertex ğ‘£ in a rooted tree ğ‘‡:\nParent: unique vertex ğ‘¢ such that (ğ‘¢,ğ‘£) is an edge (in the direction from root to ğ‘£) Child: any vertex for which ğ‘£ is a parent Siblings : vertices with the same parent(å…„å¼ŸèŠ‚ç‚¹) Ancestors : all vertices from root to ğ‘£ (except itself) Descendants : vertices with ğ‘£ as an ancestors tips A vertex of a tree is called a leaf if it has no children.\nVertices that have children are called internal vertices.\nGame(state) Trees(å†³ç­–æ ‘) Vertices: positions (states) in a game Edges: legal moves from one position (state) to another Leaves: Final positions (states) of a game m-ary Trees(Må‰æ ‘) A rooted tree is called ğ‘š-ary if every internal vertex has no more than ğ‘š children\nIt is called full if every internal (non-leaf) vertex has exactly ğ‘š children. A 2-ary tree is called a binary tree If vertex ğ‘£ is in a tree ğ‘‡, the sub-tree with root ğ‘£ is the tree consisting of ğ‘£ and all its descendants. Balanced Tree(å¹³è¡¡æ ‘) level and height The level of a node is the length of the path from the root to the node (The level of the root is defined to be zero). The height of a tree is maximum level of node.\nbalanced A rooted ğ‘š-ary tree with height â„ is called balanced if all leaves are at levels â„ or â„âˆ’1.\nBinary Search Tree (äºŒå‰æœç´¢æ ‘) å·¦å°å³å¤§\nAlgorithms The presentation of an algorithm (from high level to low level):\ndescriptive method in a natural language pseudo code source code Traversal Algorithm Pre-order traversal Let ğ‘‡ be a rooted tree with root ğ‘Ÿ. If ğ‘‡ consists only of ğ‘Ÿ, then ğ‘Ÿ is the preorder traversal of ğ‘‡. Otherwise, let ğ‘‡1 , ğ‘‡2 , â€¦ , ğ‘‡_ğ‘› be the sub-trees at ğ‘Ÿ from left to right. The preorder traversal of ğ‘‡ will begin by visiting ğ‘Ÿ, then ğ‘‡1 (in preorder), then ğ‘‡2 (in preorder), etc, until ğ‘‡ğ‘› is traversed in preorder\nIn-order traversal Let ğ‘‡ be a rooted tree with root ğ‘Ÿ If ğ‘‡ consists only of ğ‘Ÿ, then ğ‘Ÿ is the in-order traversal of ğ‘‡. Otherwise, let ğ‘‡1 , ğ‘‡2 , â€¦ , ğ‘‡_ğ‘› be the sub-trees at ğ‘Ÿ from left to right. The in-order traversal of ğ‘‡ will begin by visiting ğ‘‡1 (in-order), then the root ğ‘Ÿ, then ğ‘‡2 (in-order), etc, until ğ‘‡ğ‘› is traversed in-order\nPost-order traversal Let ğ‘‡ be a rooted tree with root ğ‘Ÿ If ğ‘‡ consists only of ğ‘Ÿ, then r is the post-order traversal of ğ‘‡. Otherwise, let ğ‘‡1 , ğ‘‡2 , â€¦ , ğ‘‡_ğ‘› be the sub-trees at ğ‘Ÿ from left to right. The post-order traversal of ğ‘‡ will begin by visiting ğ‘‡1 (in post-order), then ğ‘‡2 (in post-order), etc, then ğ‘‡ğ‘› (in post-order) and finally the root ğ‘Ÿ.\nExpression Trees The expression tree for an arithmetic expression consists of\nVertices: numbers, +, âˆ’, âˆ—, /, â†‘(â†‘ represents the power function) Edges: linking parts of an expression Internal vertices(éå¶å­èŠ‚ç‚¹) represent operations Leaves(å¶å­èŠ‚ç‚¹) represent the variables or numbers Spanning Trees(ç”Ÿæˆæ ‘) A spanning tree of a connected undirected graph ğº is a sub-graph of ğº that contains all of ğºâ€™s vertices and enough of its edges to form a tree.\nHow to obtain? To obtain a spanning tree from a connected undirected graph with cycles:\nRemove edges until there are no cycles\nDepth-First Search Depth-First Search (DFS) proceeds along a path from a vertex ğ‘£ as deeply into the graph as possible before backing up (back-tracking). To create a depth-first search (DFS) spanning tree: Traverse the graph using a depth-first search and mark the edges that you follow. After the traversal is complete, the graphâ€™s vertices and marked edges form the spanning tree.\n(If there are multiple choices, choose the next vertex in the alphabetical order.)\nBreadth-First Search Breadth-First Search (BFS) visits every vertex adjacent to a vertex v that it can before visiting any other vertex. To create a breath-first search (BFS) spanning tree Traverse the graph using a bread-first search and mark the edges that you follow. When the traversal is complete, the graphâ€™s vertices and marked edges form the spanning tree.\nMinimum Spanning Trees(æœ€å°ç”Ÿæˆæ ‘) A minimum spanning tree in a connected weighted graph is a spanning tree that has the smallest possible sum of weights of edges.\nThere may be several different minimum spanning trees for a particular graph. But the minimum weight is unique.\nPrim Initially, starts from an empty (no vertices, no edges) sub minimum spanning tree ğ‘‡. Randomly put a vertex ğ‘£ into ğ‘‡. Among all the edges (ğ‘¢,ğ‘ ) such that ğ‘¢ is in ğ‘‡ and ğ‘  is not in ğ‘‡, find the one of the minimum weight. And add the edge and the endpoint to ğ‘‡. Repeat Step 3 for ğ‘›âˆ’1 iterations (because a tree has ğ‘›âˆ’1 edges). Kruskal Initially, starts from a subgraph of all vertices but no edges. Find the edge with the smallest weight. If adding the smallest edge to the subgraph does not create any cycle, add it. (To maintain the tree property.) Otherwise, this edge is not in the MST. So, discard the edge. Repeat steps 2-4 until for ğ‘›âˆ’1 iterations (because a tree has ğ‘›âˆ’1 edges). ","date":"2023-05-01T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/dstree/","title":"ç¦»æ•£æ•°å­¦---Tree"},{"content":"Graph Theory Graph concepts Definition1 A graph G = (V,E) is a pair and consists of two sets V and such that:\nV is the set of vertices(é¡¶ç‚¹) E is the set of edges(è¾¹) Remember V cannot be empty,but E can(endpoint/node) Each edge have 1 or 2 vertices(1 is a ring) Definition2 (u,v) is an edge connetcing vettices u and v u and v are neighbors (adjacent). (u,v) connects u and v ((u,v) is incident on u and v). Simple graphs each edge connects two different vertices and where no two edges connect the same pair of vertices. Multigraph A multigraph is a graph that may have multiple edges connecting the same pair of vertices. If there are m different edges associated to the same unordered pair of vertices u and v, (u, v) is an edge of multiplicity. Loops(è‡ªç¯) A loop is an edge that connects one vertex to itself. Graphs that may include loops, and possibly multiples edges connecting the same pair of vertices are called pseudo-graphs. Directed Graph(æœ‰å‘å›¾) A directed graph (V,E) consists of a nonempty set V and a set of directed edges E\ntips The edge (u,v) in a directed graph starts at u and ends at v.\nDegree(åº¦) The degree of a vertex in an undirected graph is the number of edges connected with it except that a loop at a vertex(è‡ªç¯ç®—2)contribute twice to the degree of that vertex.\nIn-Degree and Out-Degree(å…¥åº¦ã€å‡ºåº¦) $In:def^-(v)$\n$Out:def^+(v)$\nHandshaking Theorem For an undirected graph G= (V,E):\n$$2|E|=\\sum_{v \\in V}deg(v)$$\nOdd Degree Theorem In a directed graph G = (V,E) $$|E|=\\sum_{v \\in V}deg^-(v)=\\sum_{v \\in V}deg^+(v)$$\nSpecial graphs Complete graphs(å®Œå…¨å›¾) A complete graph is a simple graph in which there is an edge between each pair of distinct vertices, denoted by $K_n$ where n is the number of nodes in the graph\nCycles A cycle is a graph that contains (n â‰¥ 3) vertices {V1, V2, â€¦ ,Vn } and n edges (V1, V2), (V2, V3), â€¦, (Vn, V1), denoted by $C_n$ where is the number of nodes in the graph.\nWheels $Cn$åŠ ä¸Šä¸­é—´ä¸€ä¸ªç‚¹ä»¥åŠè¿è¾¹ï¼Œè®°åš$W_n$\nCubes A cube of dimension n($Q_n$)is a simple graph of $2^n$ vertices, where each vertex represents a bit string of length n. Two vertices are adjacent if and only if they differ by one bit.\nBipartite Graphs(äºŒåˆ†å›¾) A simple graph G = (V,E ) is called bipartite if its vertex set V can be partitioned into two disjoint set V1 and V2 such that every edge in the graph connects a vertex in V1 and a vertex in V2. V1 and V2 are called a bipartite of the vertex set V of G Theorem(æŸ“è‰²æ³•) å‰ç½®çŸ¥è¯†ï¼šäºŒåˆ†å›¾ä¸å­˜åœ¨å¥‡æ•°ç¯\nA simple graph G= (V,E) is bipartite if and only if it is possible to color each vertex with one of two colors so that no adjacent vertices have the same color.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int n; // nè¡¨ç¤ºç‚¹æ•° int h[N], e[M], ne[M], idx; // é‚»æ¥è¡¨å­˜å‚¨å›¾ int color[N]; // è¡¨ç¤ºæ¯ä¸ªç‚¹çš„é¢œè‰²ï¼Œ-1è¡¨ç¤ºæœªæŸ“è‰²ï¼Œ0è¡¨ç¤ºç™½è‰²ï¼Œ1è¡¨ç¤ºé»‘è‰² // å‚æ•°ï¼šuè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ï¼Œcè¡¨ç¤ºå½“å‰ç‚¹çš„é¢œè‰² bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i \u0026lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } //sourceï¼šhttps://www.acwing.com/blog/content/405/ Complete Bipartite Graphs(å®Œå…¨äºŒåˆ†å›¾) $K_{m,n} $\nIn a complete bipartite graph, for any vertex in a subset,there is an edge between it and each vertex in another set.\nOutline Subgraphs and Proper Subgraphs A subgraph H = (W,F) of graph G = (V,E) is made up of vertices W âŠ† V and edges F âŠ† E. A subgraph H of G is a proper subgraph if H â‰  G. Union of Simple Graphs The union of two simple graphs G1 = (V1, E1) and G2 = (V2, E2) is the simple graph G = (V, E) such that V = V1 âˆª V2 and E = E1 âˆª E2\nRepresenting Graphs Adjacency matrix(é‚»æ¥çŸ©é˜µ):dense graph Adjacency table(é‚»æ¥è¡¨):sparse graph Graph Isomorphism(åŒæ„å›¾) åˆ¤æ–­åŒæ„ï¼šæ¨èä½¿ç”¨é‚»æ¥çŸ©é˜µåˆ¤æ–­\nGraph Connectivity Path path of length m from vertexu to vertex v is a sequence of edges e1, e2, â€¦ , $e_n$ such that e1 starts at u and $e_n$ ends at v.\nCircuit A circuit is a path that begins and ends at the same vertex in graph.\nSimple path or circuit A simple path or circuit does not pass through the same edge twice or more.\nGraph Connectedness An undirected graph is connected if there is a path between every pair of distinct vertices A directed graph is strongly connected if there is a path from a to b and from b to a whenever a and b are vertices in the graph Euler Paths An Euler path in G is a simple path containing every edge of G An Euler circuit in a graph G is a simple circuit containing every edge of G THEOREM A connected multi-graph has an Euler circuit if and only if each vertex has even degree.\nHamilton Circuits A Hamilton path is a path that traverses each vertex in G exactly once A Hamilton circuit is a circuit that traverses each vertex in G exactly once. Oreâ€™s theorem If for every pair of nonadjacent vertices u and v in the simple graph G with n vertices, deg(u) + deg(v) â‰¥ n ,then has a Hamilton circuit.\nDiracâ€™s theorem If the degree of each vertex is great than or equals n/2 in the connected simple graph G with n vertices where n â‰¥ 3, then G has a Hamilton circuit.\nPlanar Graphs In a planar representation of\ne: number of edges v: number of vertices r: number of regions $r= e â€“ v + 2$ Eulerâ€™s Formula G is a connected planar simple graph\nv â‰¥ 3, then e â‰¤ 3v â€“ 6 G has a vertex of degree not exceeding 5 if v\u0026gt;=3 and no circuits of length 3,then e\u0026lt;=2v-4 ","date":"2023-05-01T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/dmgraph/","title":"ç¦»æ•£æ•°å­¦â€”â€”â€”â€”Graph"},{"content":"açš„bæ¬¡æ–¹å¯¹på–æ¨¡ å‰ç½®çŸ¥è¯† qpow math:$(a+b)%p=(a%p+b%p)%p$ code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // æ±‚ açš„ bæ¬¡æ–¹å¯¹ på–æ¨¡çš„å€¼ã€‚ // è¾“å…¥æ ¼å¼ // ä¸‰ä¸ªæ•´æ•° a,b,pï¼Œåœ¨åŒä¸€è¡Œç”¨ç©ºæ ¼éš”å¼€ã€‚ // è¾“å‡ºæ ¼å¼ // è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºa^b mod pçš„å€¼ã€‚ // æ•°æ®èŒƒå›´ // 0â‰¤a,bâ‰¤10^9 // 1â‰¤pâ‰¤109 // è¾“å…¥æ ·ä¾‹ï¼š // 3 2 7 // è¾“å‡ºæ ·ä¾‹ï¼š // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; // é˜²æ­¢å½“b=0ï¼Œp=1æ—¶è¢«å¡ res=1%p; while(b){ if(b\u0026amp;1)res=(res*a)%p; a*=a; a%=p; b\u0026gt;\u0026gt;=1; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } a*bå¯¹på–æ¨¡ å‰ç½®çŸ¥è¯† qpow math:(a+b)%p=(a%p+b%p)%p code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // æ±‚ a // ä¹˜ b // å¯¹ p // å–æ¨¡çš„å€¼ã€‚ // è¾“å…¥æ ¼å¼ // ç¬¬ä¸€è¡Œè¾“å…¥æ•´æ•°a // ï¼Œç¬¬äºŒè¡Œè¾“å…¥æ•´æ•°b // ï¼Œç¬¬ä¸‰è¡Œè¾“å…¥æ•´æ•°p // ã€‚ // è¾“å‡ºæ ¼å¼ // è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºa*b mod pçš„å€¼ã€‚ // æ•°æ®èŒƒå›´ // 1â‰¤a,b,pâ‰¤1018 // è¾“å…¥æ ·ä¾‹ï¼š // 3 // 4 // 5 // è¾“å‡ºæ ·ä¾‹ï¼š // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res=0; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; while(b){ if(b\u0026amp;1)res=(res+a)%p; b\u0026gt;\u0026gt;=1; a*=2; a%=p; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } æœ€çŸ­Hamiltonè·¯å¾„ å‰ç½®çŸ¥è¯†\næ—…è¡Œå•†é—®é¢˜:NPå®Œå…¨,æ²¡æœ‰å¤šé¡¹å¼æ—¶é—´è§£æ³• ä½è¿ç®— çŠ¶å‹DP bitset:STL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // ç»™å®šä¸€å¼  nä¸ªç‚¹çš„å¸¦æƒæ— å‘å›¾ï¼Œç‚¹ä» 0âˆ¼nâˆ’1æ ‡å·ï¼Œæ±‚èµ·ç‚¹ 0åˆ°ç»ˆç‚¹ nâˆ’1çš„æœ€çŸ­ Hamilton è·¯å¾„ã€‚ // Hamilton è·¯å¾„çš„å®šä¹‰æ˜¯ä» 0åˆ° nâˆ’1ä¸é‡ä¸æ¼åœ°ç»è¿‡æ¯ä¸ªç‚¹æ°å¥½ä¸€æ¬¡ã€‚è¾“å…¥æ ¼å¼ // ç¬¬ä¸€è¡Œè¾“å…¥æ•´æ•° nã€‚ // æ¥ä¸‹æ¥ nè¡Œæ¯è¡Œ nä¸ªæ•´æ•°ï¼Œå…¶ä¸­ç¬¬ iè¡Œç¬¬ jä¸ªæ•´æ•°è¡¨ç¤ºç‚¹ iåˆ° jçš„è·ç¦»ï¼ˆè®°ä¸º a[i,j]ï¼‰ã€‚ // å¯¹äºä»»æ„çš„ x,y,zï¼Œæ•°æ®ä¿è¯ a[x,x]=0ï¼Œa[x,y]=a[y,x]å¹¶ä¸” a[x,y]+a[y,z]â‰¥a[x,z]ã€‚ // è¾“å‡ºæ ¼å¼ // è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ€çŸ­ Hamilton è·¯å¾„çš„é•¿åº¦ã€‚ // æ•°æ®èŒƒå›´ // 1â‰¤nâ‰¤20 // 0â‰¤a[i,j]â‰¤107 // è¾“å…¥æ ·ä¾‹ï¼š // 5 // 0 2 4 5 1 // 2 0 6 5 3 // 4 6 0 8 3 // 5 5 8 0 5 // 1 3 3 5 0 // è¾“å‡ºæ ·ä¾‹ï¼š // 18 #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) #define inf 0x3f const int N=20,M=1\u0026lt;\u0026lt;20; int n; //å¤§æ•°ç»„å¼€åˆ°å…¨å±€é‡Œï¼Œé˜²æ­¢çˆ†æ ˆ //f[i][j]: i:ç»è¿‡çŠ¶æ€ï¼Œj:jç‚¹æœ€çŸ­è·¯ int f[M][N],w[N][N]; int main(){ cin\u0026gt;\u0026gt;n; For(i,0,n){ For(j,0,n){ cin\u0026gt;\u0026gt;w[i][j]; } } memset(f,inf,sizeof(f)); f[1][0]=0; For(i,0,1\u0026lt;\u0026lt;n){ For(j,0,n){ if(i\u0026gt;\u0026gt;j\u0026amp;1){ //int p=i^(1\u0026lt;\u0026lt;j) int p=i-(1\u0026lt;\u0026lt;j); For(k,0,n){ if(p\u0026amp;(1\u0026lt;\u0026lt;k)) // if(p\u0026gt;\u0026gt;k\u0026amp;1) f[i][j]=min(f[i][j],f[p][k]+w[k][j]); } } } } cout\u0026lt;\u0026lt;f[(1\u0026lt;\u0026lt;n)-1][n-1]\u0026lt;\u0026lt;endl; return 0; } èµ·åºŠå›°éš¾ç»¼åˆç—‡ å‰ç½®çŸ¥è¯† ä½è¿ç®—æ€§è´¨ :ä¸æˆ–éè¿ç®—åœ¨äºŒè¿›åˆ¶è¡¨ç¤ºä¸‹ä¸è¿›ä½ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªbitä¹‹é—´ç‹¬ç«‹ä½è¿ç®— è´ªå¿ƒ é¢˜ç›®æè¿° 21ä¸–çºªï¼Œè®¸å¤šäººå¾—äº†ä¸€ç§å¥‡æ€ªçš„ç—…ï¼šèµ·åºŠå›°éš¾ç»¼åˆç—‡ï¼Œå…¶ä¸´åºŠè¡¨ç°ä¸ºï¼šèµ·åºŠéš¾ï¼Œèµ·åºŠåç²¾ç¥ä¸ä½³ã€‚ä½œä¸ºä¸€åé’æ˜¥é˜³å…‰å¥½å°‘å¹´ï¼Œatm ä¸€ç›´åšæŒä¸èµ·åºŠå›°éš¾ç»¼åˆç—‡ä½œæ–—äº‰ã€‚é€šè¿‡ç ”ç©¶ç›¸å…³æ–‡çŒ®ï¼Œä»–æ‰¾åˆ°äº†è¯¥ç—…çš„å‘ç—…åŸå› ï¼š åœ¨æ·±é‚ƒçš„å¤ªå¹³æ´‹æµ·åº•ä¸­ï¼Œå‡ºç°äº†ä¸€æ¡åä¸º drd çš„å·¨é¾™ï¼Œå®ƒæŒæ¡ç€ç¡çœ ä¹‹ç²¾é«“ï¼Œèƒ½éšæ„å»¶é•¿å¤§å®¶çš„ç¡çœ æ—¶é—´ã€‚ æ­£æ˜¯ç”±äº drd çš„æ´»åŠ¨ï¼Œèµ·åºŠå›°éš¾ç»¼åˆç—‡æ„ˆæ¼”æ„ˆçƒˆï¼Œ ä»¥æƒŠäººçš„é€Ÿåº¦åœ¨ä¸–ç•Œä¸Šä¼ æ’­ã€‚ ä¸ºäº†å½»åº•æ¶ˆç­è¿™ç§ç—…ï¼Œatm å†³å®šå‰å¾€æµ·åº•ï¼Œæ¶ˆç­è¿™æ¡æ¶é¾™ã€‚ å†ç»åƒè¾›ä¸‡è‹¦ï¼Œatm ç»ˆäºæ¥åˆ°äº† drd æ‰€åœ¨çš„åœ°æ–¹ï¼Œå‡†å¤‡ä¸å…¶å±•å¼€è‰°è‹¦å“ç»çš„æˆ˜æ–—ã€‚ drd æœ‰ç€ååˆ†ç‰¹æ®Šçš„æŠ€èƒ½ï¼Œä»–çš„é˜²å¾¡æˆ˜çº¿èƒ½å¤Ÿä½¿ç”¨ä¸€å®šçš„è¿ç®—æ¥æ”¹å˜ä»–å—åˆ°çš„ä¼¤å®³ã€‚\nå…·ä½“è¯´æ¥ï¼Œdrd çš„é˜²å¾¡æˆ˜çº¿ç”± næ‰‡é˜²å¾¡é—¨ç»„æˆã€‚ æ¯æ‰‡é˜²å¾¡é—¨åŒ…æ‹¬ä¸€ä¸ªè¿ç®— opå’Œä¸€ä¸ªå‚æ•° t ï¼Œå…¶ä¸­è¿ç®—ä¸€å®šæ˜¯ OR,XOR,ANDä¸­çš„ä¸€ç§ï¼Œå‚æ•°åˆ™ä¸€å®šä¸ºéè´Ÿæ•´æ•°ã€‚\nå¦‚æœè¿˜æœªé€šè¿‡é˜²å¾¡é—¨æ—¶æ”»å‡»åŠ›ä¸º x åˆ™å…¶é€šè¿‡è¿™æ‰‡é˜²å¾¡é—¨åæ”»å‡»åŠ›å°†å˜ä¸º x op t\næœ€ç»ˆ drd å—åˆ°çš„ä¼¤å®³ä¸ºå¯¹æ–¹åˆå§‹æ”»å‡»åŠ› x ä¾æ¬¡ç»è¿‡æ‰€æœ‰ næ‰‡é˜²å¾¡é—¨åè½¬å˜å¾—åˆ°çš„æ”»å‡»åŠ›ã€‚\nç”±äº atm æ°´å¹³æœ‰é™ï¼Œä»–çš„åˆå§‹æ”»å‡»åŠ›åªèƒ½ä¸º 0 åˆ° mä¹‹é—´çš„ä¸€ä¸ªæ•´æ•°ï¼ˆå³ä»–çš„åˆå§‹æ”»å‡»åŠ›åªèƒ½åœ¨ 0,1,â€¦,mä¸­ä»»é€‰ï¼Œ ä½†åœ¨é€šè¿‡é˜²å¾¡é—¨ä¹‹åçš„æ”»å‡»åŠ›ä¸å— mçš„é™åˆ¶ï¼‰ã€‚\nä¸ºäº†èŠ‚çœä½“åŠ›ï¼Œä»–å¸Œæœ›é€šè¿‡é€‰æ‹©åˆé€‚çš„åˆå§‹æ”»å‡»åŠ›ä½¿å¾—ä»–çš„æ”»å‡»èƒ½è®© drd å—åˆ°æœ€å¤§çš„ä¼¤å®³ï¼Œè¯·ä½ å¸®ä»–è®¡ç®—ä¸€ä¸‹ï¼Œä»–çš„ä¸€æ¬¡æ”»å‡»æœ€å¤šèƒ½ä½¿ drd å—åˆ°å¤šå°‘ä¼¤å®³ã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ 1è¡ŒåŒ…å« 2ä¸ªæ•´æ•°ï¼Œä¾æ¬¡ä¸º n,mï¼Œè¡¨ç¤º drd æœ‰ næ‰‡é˜²å¾¡é—¨ï¼Œatm çš„åˆå§‹æ”»å‡»åŠ›ä¸º 0åˆ° mä¹‹é—´çš„æ•´æ•°ã€‚\næ¥ä¸‹æ¥ n è¡Œï¼Œä¾æ¬¡è¡¨ç¤ºæ¯ä¸€æ‰‡é˜²å¾¡é—¨ã€‚æ¯è¡ŒåŒ…æ‹¬ä¸€ä¸ªå­—ç¬¦ä¸² op å’Œä¸€ä¸ªéè´Ÿæ•´æ•° t ï¼Œä¸¤è€…ç”±ä¸€ä¸ªç©ºæ ¼éš”å¼€ï¼Œä¸” op åœ¨å‰ï¼Œt åœ¨åï¼Œop è¡¨ç¤ºè¯¥é˜²å¾¡é—¨æ‰€å¯¹åº”çš„æ“ä½œï¼Œt è¡¨ç¤ºå¯¹åº”çš„å‚æ•°ã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤º atm çš„ä¸€æ¬¡æ”»å‡»æœ€å¤šä½¿ drd å—åˆ°å¤šå°‘ä¼¤å®³ã€‚\næ•°æ®èŒƒå›´ è¾“å…¥æ ·ä¾‹ï¼š 3 10\nAND 5\nOR 6\nXOR 7\nè¾“å‡ºæ ·ä¾‹ï¼š 1\næ ·ä¾‹è§£é‡Š atmå¯ä»¥é€‰æ‹©çš„åˆå§‹æ”»å‡»åŠ›ä¸º 0,1,â€¦,10\nå‡è®¾åˆå§‹æ”»å‡»åŠ›ä¸º 4ï¼Œæœ€ç»ˆæ”»å‡»åŠ›ç»è¿‡äº†å¦‚ä¸‹è®¡ç®—\n4 AND 5 = 4\n4 OR 6 = 6 6 XOR 7 = 1 ç±»ä¼¼çš„ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—å‡ºåˆå§‹æ”»å‡»åŠ›ä¸º 1,3,5,7,9 æ—¶æœ€ç»ˆæ”»å‡»åŠ›ä¸º 0 ï¼Œåˆå§‹æ”»å‡»åŠ›ä¸º 0,2,4,6,8,10 æ—¶æœ€ç»ˆæ”»å‡»åŠ›ä¸º 1 ï¼Œå› æ­¤ atm çš„ä¸€æ¬¡æ”»å‡»æœ€å¤šä½¿ drd å—åˆ°çš„ä¼¤å®³å€¼ä¸º 1\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) const int N=1e6; vector\u0026lt;pair\u0026lt;string,int\u0026gt;\u0026gt; a(N); string op; int t; int n,m; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int change(int p,int q){ For(i,0,n){ int x=a[i].second\u0026gt;\u0026gt;p\u0026amp;1; if(a[i].first==\u0026#34;AND\u0026#34;)q\u0026amp;=x; else if(a[i].first==\u0026#34;OR\u0026#34;)q|=x; else {q^=x;} } return q; } int main(){ ios cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; For(i,0,n){ cin\u0026gt;\u0026gt;a[i].first; cin\u0026gt;\u0026gt;a[i].second; } int pre=0,aft=0; For(i,0,30){ int p=29-i; int pos1=change(p,0); int pos2=change(p,1); if(pre+(1\u0026lt;\u0026lt;p)\u0026lt;=m \u0026amp;\u0026amp; pos2\u0026gt;pos1){ pre+=1\u0026lt;\u0026lt;p; aft+=pos2\u0026lt;\u0026lt;p; } else aft+=pos1\u0026lt;\u0026lt;p; } cout\u0026lt;\u0026lt;aft\u0026lt;\u0026lt;endl; } XORæˆå¯¹å˜æ¢ 1 2 3 4 if n\u0026amp;1: n^1==n-1 else: n^1==n+1 lowbit n\u0026amp;(-n)\n","date":"2023-04-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue01/","title":"å°è“ä¹¦0X01ä½è¿ç®—"},{"content":"æ¿€å…‰ç‚¸å¼¹ é¢˜ç›® åœ°å›¾ä¸Šæœ‰ $N$ ä¸ªç›®æ ‡ï¼Œç”¨æ•´æ•° $X_i,Y_i$ è¡¨ç¤ºç›®æ ‡åœ¨åœ°å›¾ä¸Šçš„ä½ç½®ï¼Œæ¯ä¸ªç›®æ ‡éƒ½æœ‰ä¸€ä¸ªä»·å€¼ $W_i$ã€‚\næ³¨æ„ï¼šä¸åŒç›®æ ‡å¯èƒ½åœ¨åŒä¸€ä½ç½®ã€‚\nç°åœ¨æœ‰ä¸€ç§æ–°å‹çš„æ¿€å…‰ç‚¸å¼¹ï¼Œå¯ä»¥æ‘§æ¯ä¸€ä¸ªåŒ…å« $R \\times R$ ä¸ªä½ç½®çš„æ­£æ–¹å½¢å†…çš„æ‰€æœ‰ç›®æ ‡ã€‚\næ¿€å…‰ç‚¸å¼¹çš„æŠ•æ”¾æ˜¯é€šè¿‡å«æ˜Ÿå®šä½çš„ï¼Œä½†å…¶æœ‰ä¸€ä¸ªç¼ºç‚¹ï¼Œå°±æ˜¯å…¶çˆ†ç‚¸èŒƒå›´ï¼Œå³é‚£ä¸ªæ­£æ–¹å½¢çš„è¾¹å¿…é¡»å’Œ $x,y$ è½´å¹³è¡Œã€‚\næ±‚ä¸€é¢—ç‚¸å¼¹æœ€å¤šèƒ½ç‚¸æ‰åœ°å›¾ä¸Šæ€»ä»·å€¼ä¸ºå¤šå°‘çš„ç›®æ ‡ã€‚\nè¾“å…¥æ ¼å¼\nç¬¬ä¸€è¡Œè¾“å…¥æ­£æ•´æ•° $N$ å’Œ $R$ï¼Œåˆ†åˆ«ä»£è¡¨åœ°å›¾ä¸Šçš„ç›®æ ‡æ•°ç›®å’Œæ­£æ–¹å½¢åŒ…å«çš„æ¨ªçºµä½ç½®æ•°é‡ï¼Œæ•°æ®ç”¨ç©ºæ ¼éš”å¼€ã€‚\næ¥ä¸‹æ¥ $N$ è¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸€ç»„æ•°æ®ï¼Œæ¯ç»„æ•°æ®åŒ…æ‹¬ä¸‰ä¸ªæ•´æ•° $X_i,Y_i,W_i$ï¼Œåˆ†åˆ«ä»£è¡¨ç›®æ ‡çš„ $x$ åæ ‡ï¼Œ$y$ åæ ‡å’Œä»·å€¼ï¼Œæ•°æ®ç”¨ç©ºæ ¼éš”å¼€ã€‚\nè¾“å‡ºæ ¼å¼\nè¾“å‡ºä¸€ä¸ªæ­£æ•´æ•°ï¼Œä»£è¡¨ä¸€é¢—ç‚¸å¼¹æœ€å¤šèƒ½ç‚¸æ‰åœ°å›¾ä¸Šç›®æ ‡çš„æ€»ä»·å€¼æ•°ç›®ã€‚\næ•°æ®èŒƒå›´\n$0 \\le R \\le 10^9$\n$0 \u0026lt; N \\le 10^4, 0 \\le X_i, Y_i \\le 5000, 0 \\le W_i \\le 1000$\nè¾“å…¥æ ·ä¾‹ï¼š\n2 1\n0 0 1\n1 1 1\nè¾“å‡ºæ ·ä¾‹ï¼š\n1\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5000+3; int b[N][N]; int main() { ios int r,x,y,w,t; cin\u0026gt;\u0026gt;t\u0026gt;\u0026gt;r; while(t--){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;w; //æ ‡å‡†å¼€å¤§ä¸€æ ¼ b[x+1][y+1]+=w; } FOR(i,1,N) FOR(j,1,N) //é¢˜ç›®å¡å†…å­˜ï¼Œåªèƒ½å¼€ä¸€ä¸ªæ•°ç»„ï¼ŒåŸåœ°ä¿®æ”¹ b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+b[i][j]; int ans=0; // æ³¨æ„ç»†èŠ‚ r=min(N-1,r); FOR(i,r,N){ FOR(j,r,N){ ans=max(b[i][j]-b[i-r][j]-b[i][j-r]+b[i-r][j-r],ans); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } IncDecåºåˆ— å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬å°†åŒºé—´æ“ä½œè½¬æ¢ä¸ºå·®åˆ†åºåˆ—çš„å•ç‚¹æ“ä½œï¼Œä»¥é™ä½éš¾åº¦\né¢˜ç›®æè¿° ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°åˆ— $a_1,a_2,\\dots,a_n$ï¼Œæ¯æ¬¡å¯ä»¥é€‰æ‹©ä¸€ä¸ªåŒºé—´ $[l,r]$ï¼Œä½¿ä¸‹æ ‡åœ¨è¿™ä¸ªåŒºé—´å†…çš„æ•°éƒ½åŠ ä¸€æˆ–è€…éƒ½å‡ä¸€ã€‚\næ±‚è‡³å°‘éœ€è¦å¤šå°‘æ¬¡æ“ä½œæ‰èƒ½ä½¿æ•°åˆ—ä¸­çš„æ‰€æœ‰æ•°éƒ½ä¸€æ ·ï¼Œå¹¶æ±‚å‡ºåœ¨ä¿è¯æœ€å°‘æ¬¡æ•°çš„å‰æä¸‹ï¼Œæœ€ç»ˆå¾—åˆ°çš„æ•°åˆ—å¯èƒ½æœ‰å¤šå°‘ç§ã€‚\nè¾“å…¥æ ¼å¼\nç¬¬ä¸€è¡Œè¾“å…¥æ­£æ•´æ•° $n$ã€‚\næ¥ä¸‹æ¥ $n$ è¡Œï¼Œæ¯è¡Œè¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼Œç¬¬ $i+1$ è¡Œçš„æ•´æ•°ä»£è¡¨ $a_i$ã€‚\nè¾“å‡ºæ ¼å¼\nç¬¬ä¸€è¡Œè¾“å‡ºæœ€å°‘æ“ä½œæ¬¡æ•°ã€‚\nç¬¬äºŒè¡Œè¾“å‡ºæœ€ç»ˆèƒ½å¾—åˆ°å¤šå°‘ç§ç»“æœã€‚\næ•°æ®èŒƒå›´\n$0\u0026lt;n\\le 10^5$, $0\\le a_i\u0026lt;2^{31}$\nè¾“å…¥æ ·ä¾‹ï¼š\n4\n1\n1\n2\n2\nè¾“å‡ºæ ·ä¾‹ï¼š\n1\n2\ntag æ€ç»´ è´ªå¿ƒ code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+3; ll a[N]; int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,1,n+1){ cin\u0026gt;\u0026gt;a[i]; } // æ³¨æ„è¿™é‡Œå€’ç€ for(int i=n;i\u0026gt;0;i--)a[i]-=a[i-1]; ll cnt=0,cnt2=0; FOR(i,2,n+1){ if(a[i]\u0026gt;0)cnt+=a[i]; else cnt2-=a[i]; } cout\u0026lt;\u0026lt;max(cnt,cnt2)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;abs(cnt2-cnt)+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } æœ€é«˜çš„ç‰› é¢˜ç›® æœ‰ N å¤´ç‰›ç«™æˆä¸€è¡Œï¼Œè¢«ç¼–é˜Ÿä¸º 1ã€2ã€3â€¦Nï¼Œæ¯å¤´ç‰›çš„èº«é«˜éƒ½ä¸ºæ•´æ•°ã€‚\nå½“ä¸”ä»…å½“ä¸¤å¤´ç‰›ä¸­é—´çš„ç‰›èº«é«˜éƒ½æ¯”å®ƒä»¬çŸ®æ—¶ï¼Œä¸¤å¤´ç‰›æ–¹å¯çœ‹åˆ°å¯¹æ–¹ã€‚\nç°åœ¨ï¼Œæˆ‘ä»¬åªçŸ¥é“å…¶ä¸­æœ€é«˜çš„ç‰›æ˜¯ç¬¬ P å¤´ï¼Œå®ƒçš„èº«é«˜æ˜¯ Hï¼Œå‰©ä½™ç‰›çš„èº«é«˜æœªçŸ¥ã€‚\nä½†æ˜¯ï¼Œæˆ‘ä»¬è¿˜çŸ¥é“è¿™ç¾¤ç‰›ä¹‹ä¸­å­˜åœ¨ç€ M å¯¹å…³ç³»ï¼Œæ¯å¯¹å…³ç³»éƒ½æŒ‡æ˜äº†æŸä¸¤å¤´ç‰› A å’Œ B å¯ä»¥ç›¸äº’çœ‹è§ã€‚\næ±‚æ¯å¤´ç‰›çš„èº«é«˜çš„æœ€å¤§å¯èƒ½å€¼æ˜¯å¤šå°‘ã€‚\nè¾“å…¥æ ¼å¼\nç¬¬ä¸€è¡Œè¾“å…¥æ•´æ•° N,P,H,Mï¼Œæ•°æ®ç”¨ç©ºæ ¼éš”å¼€ã€‚\næ¥ä¸‹æ¥ M è¡Œï¼Œæ¯è¡Œè¾“å‡ºä¸¤ä¸ªæ•´æ•° A å’Œ Bï¼Œä»£è¡¨ç‰› A å’Œç‰› B å¯ä»¥ç›¸äº’çœ‹è§ï¼Œæ•°æ®ç”¨ç©ºæ ¼éš”å¼€ã€‚\nè¾“å‡ºæ ¼å¼\nä¸€å…±è¾“å‡º N è¡Œæ•°æ®ï¼Œæ¯è¡Œè¾“å‡ºä¸€ä¸ªæ•´æ•°ã€‚\nç¬¬ i è¡Œè¾“å‡ºçš„æ•´æ•°ä»£è¡¨ç¬¬ i å¤´ç‰›å¯èƒ½çš„æœ€å¤§èº«é«˜ã€‚\næ•°æ®èŒƒå›´\n$1â‰¤Nâ‰¤5000$ï¼Œ$1â‰¤Hâ‰¤1000000$ï¼Œ$1â‰¤A,Bâ‰¤10000$ï¼Œ$0â‰¤Mâ‰¤10000$\nè¾“å…¥æ ·ä¾‹ï¼š\n1 2 3 4 5 6 9 3 5 5 1 3 5 3 4 3 3 7 9 8 è¾“å‡ºæ ·ä¾‹ï¼š\n1 2 3 4 5 6 7 8 9 5 4 5 3 4 4 5 5 5 æ³¨æ„ï¼šæ­¤é¢˜ä¸­ç»™å‡ºçš„å…³ç³»å¯¹å¯èƒ½å­˜åœ¨é‡å¤ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5000+3; set\u0026lt;pii\u0026gt; used; int d[N]; int main() { ios int n,p,h,m,a,b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;p\u0026gt;\u0026gt;h\u0026gt;\u0026gt;m; while(m--){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(a\u0026gt;b)swap(a,b); if(used.count(make_pair(a,b)))continue; d[a+1]--; d[b]++; used.insert(make_pair(a,b)); } d[0]=h; FOR(i,1,n+1){ d[i]+=d[i-1]; cout\u0026lt;\u0026lt;d[i]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } ","date":"2023-04-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue03/","title":"å°è“ä¹¦0X03å‰ç¼€å’Œä¸å·®åˆ†"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/message/","title":"ğŸ—ï¸ä¸‹é¢å·²ç»ç©ºç©ºå¦‚ä¹Ÿå•¦~"}]