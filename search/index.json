[{"content":"c++ 快读模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } 精简模板 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6; int main() { ios cout \u0026lt;\u0026lt; \u0026#34;Hello, ACM.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 完全模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #define _USE_MATH_DEFINES // C #include \u0026lt;cassert\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;ctime\u0026gt; //io #include \u0026lt;iostream\u0026gt; //基本输入输出流 #include \u0026lt;iomanip\u0026gt; #include \u0026lt;sstream\u0026gt; //基于字符串的流 //标准异常类 #include \u0026lt;stdexcept\u0026gt; //algorithm #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;functional\u0026gt; //定义运算函数（代替运算符） #include \u0026lt;complex\u0026gt; //复数类 #include \u0026lt;random\u0026gt; //STL #include \u0026lt;string\u0026gt; //字符串类 #include \u0026lt;list\u0026gt; //线性列表容器 #include \u0026lt;vector\u0026gt; //动态数组容器 #include \u0026lt;stack\u0026gt; //堆栈容器 #include \u0026lt;queue\u0026gt; //队列容器 #include \u0026lt;deque\u0026gt; //双端队列容器 #include \u0026lt;bitset\u0026gt; //比特集合 #include \u0026lt;set\u0026gt; //集合容器 #include \u0026lt;map\u0026gt; //映射容器 #include \u0026lt;unordered_set\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; //fast ios #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define ALL(a) (a).begin(),(a).end() #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define RFOR(w, a, n) for(int w=(n)-1;w\u0026gt;=(a);--w) #define REP(w, n) for(int w=0;w\u0026lt;int(n);++w) #define RREP(w, n) for(int w=int(n)-1;w\u0026gt;=0;--w) #define IN(a, x, b) (a\u0026lt;=x \u0026amp;\u0026amp; x\u0026lt;b) #define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) template \u0026lt;typename Arg1\u0026gt; void __f(const char* name, Arg1\u0026amp;\u0026amp; arg1){ cerr \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; endl; } template \u0026lt;typename Arg1, typename... Args\u0026gt; void __f(const char* names, Arg1\u0026amp;\u0026amp; arg1, Args\u0026amp;\u0026amp;... args){ const char* comma = strchr(names + 1, \u0026#39;,\u0026#39;); cerr.write(names, comma - names) \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; \u0026#34; |\u0026#34;; __f(comma + 1, args...); } typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const double PI = acos(-1.0); const double eps = 1e-6; const int INF = 1 \u0026lt;\u0026lt; 29; const int MOD = 1e9 + 7; const int MAXN = 100; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, ACM.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys import heapq import random from math import ceil,floor,fmod,gcd,sqrt,inf from bisect import bisect_left from collections import defaultdict,Counter,deque,OrderedDict from functools import lru_cache,cmp_to_key #sys.setrecursionlimit(1000000) # 输入1 def ii(): return int(sys.stdin.readline().strip()) # 输入2 def iin(): return map(int,sys.stdin.readline().split()) def inn(): return sys.stdin.readline().strip() java go ","date":"2023-05-08T00:03:00Z","image":"https://open17.github.io/CpHugo/p/template/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://open17.github.io/CpHugo/p/template/","title":"算法输入输出模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 vector\u0026lt;int\u0026gt; get_prefix_table(string pattern) { int n = pattern.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = pi[j-1]; } if (pattern[i] == pattern[j]) { j++; } pi[i] = j; } return pi; } vector\u0026lt;int\u0026gt; kmp(string text, string pattern) { vector\u0026lt;int\u0026gt; pi = get_prefix_table(pattern); vector\u0026lt;int\u0026gt; matches; for (int i = 0, j = 0; i \u0026lt; text.length(); i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; text[i] != pattern[j]) { j = pi[j-1]; } if (text[i] == pattern[j]) { j++; } if (j == pattern.length()) { matches.push_back(i - j + 1); j = pi[j-1]; } } return matches; } 【模板】KMP字符串匹配 题目描述 给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。\n现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。\n定义一个字符串 $s$ 的 border 为 $s$ 的一个非 $s$ 本身的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。\n对于 $s_2$，你还需要求出对于其每个前缀 $s\u0026rsquo;$ 的最长 border $t\u0026rsquo;$ 的长度。\n输入格式 第一行为一个字符串，即为 $s_1$。\n第二行为一个字符串，即为 $s_2$。\n输出格式 首先输出若干行，每行一个整数，按从小到大的顺序输出 $s_2$ 在 $s_1$ 中出现的位置。\n最后一行输出 $|s_2|$ 个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。\n样例 #1 样例输入 #1 1 2 ABABABC ABA 样例输出 #1 1 2 3 1 3 0 0 1 提示 样例 1 解释 。\n对于 $s_2$ 长度为 $3$ 的前缀 ABA，字符串 A 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。\n数据规模与约定 本题采用多测试点捆绑测试，共有 3 个子任务。\nSubtask 1（30 points）：$|s_1| \\leq 15$，$|s_2| \\leq 5$。 Subtask 2（40 points）：$|s_1| \\leq 10^4$，$|s_2| \\leq 10^2$。 Subtask 3（30 points）：无特殊约定。 对于全部的测试点，保证 $1 \\leq |s_1|,|s_2| \\leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; get_prefix_table(string pattern) { int n = pattern.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = pi[j-1]; } if (pattern[i] == pattern[j]) { j++; } pi[i] = j; } return pi; } vector\u0026lt;int\u0026gt; kmp(string text, string pattern) { vector\u0026lt;int\u0026gt; pi = get_prefix_table(pattern); vector\u0026lt;int\u0026gt; matches; for (int i = 0, j = 0; i \u0026lt; text.length(); i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; text[i] != pattern[j]) { j = pi[j-1]; } if (text[i] == pattern[j]) { j++; } if (j == pattern.length()) { matches.push_back(i - j + 1); j = pi[j-1]; } } return matches; } int main() { string s1, s2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; // 使用 KMP 算法查找所有出现位置 vector\u0026lt;int\u0026gt; matches = kmp(s1, s2); // 输出出现位置 for (int i = 0; i \u0026lt; matches.size(); i++) { cout \u0026lt;\u0026lt; matches[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // 计算 s2 的前缀的最长 border 长度 vector\u0026lt;int\u0026gt; pi = get_prefix_table(s2); for (int i = 0; i \u0026lt; s2.length(); i++) { cout \u0026lt;\u0026lt; pi[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/kmp/","title":"KMP模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const int MAXN = 1e5 + 5; // 最大数组长度 const int MAXK = 25; // log2(MAXN) 向上取整 int a[MAXN]; // 输入数组 int st[MAXN][MAXK + 1]; // ST表 int Log2[MAXN]; void build(int n) { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; // 初始化第一列 } for (int j = 1; j \u0026lt;= MAXK; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = min(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); // 更新ST表 } } for (int i = 2; i \u0026lt;= n; ++i) Log2[i] = Log2[i / 2] + 1; } int query(int l, int r) { int k = Log2[r - l + 1]; // 计算区间长度的对数，向下取整 return min(st[l][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); // 返回区间最小值 } 【模板】ST 表 题目背景 这是一道 ST 表经典题——静态区间最大值\n请注意最大数据时限只有 0.8s，数据强度不低，请务必保证你的每次查询复杂度为 $O(1)$。若使用更高时间复杂度算法不保证能通过。\n如果您认为您的代码时间复杂度正确但是 TLE，可以尝试使用快速读入：\n1 2 3 4 5 6 7 inline int read() { int x=0,f=1;char ch=getchar(); while (ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if (ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while (ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-48;ch=getchar();} return x*f; } 函数返回值为读入的第一个整数。\n快速读入作用仅为加快读入，并非强制使用。\n题目描述 给定一个长度为 $N$ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。\n输入格式 第一行包含两个整数 $N,M$，分别表示数列的长度和询问的个数。\n第二行包含 $N$ 个整数（记为 $a_i$），依次表示数列的第 $i$ 项。\n接下来 $M$ 行，每行包含两个整数 $l_i,r_i$，表示查询的区间为 $[l_i,r_i]$。\n输出格式 输出包含 $M$ 行，每行一个整数，依次表示每一次询问的结果。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 8 9 10 8 8 9 3 1 7 5 6 0 8 1 6 1 5 2 7 2 6 1 8 4 8 3 7 1 8 样例输出 #1 1 2 3 4 5 6 7 8 9 9 7 7 9 8 7 9 提示 对于 $30%$ 的数据，满足 $1\\le N,M\\le 10$。\n对于 $70%$ 的数据，满足 $1\\le N,M\\le {10}^5$。\n对于 $100%$ 的数据，满足 $1\\le N\\le {10}^5$，$1\\le M\\le 2\\times{10}^6$，$a_i\\in[0,{10}^9]$，$1\\le l_i\\le r_i\\le N$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAXN = 1e5 + 5; // 最大数组长度 const int MAXK = 25; // log2(MAXN) 向上取整 int a[MAXN]; // 输入数组 int st[MAXN][MAXK + 1]; // ST表 int Log2[MAXN]; void build(int n) { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; // 初始化第一列 } for (int j = 1; j \u0026lt;= MAXK; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = max(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); // 更新ST表 } } for (int i = 2; i \u0026lt;= n; ++i) Log2[i] = Log2[i / 2] + 1; } int query(int l, int r) { int k = Log2[r - l + 1]; // 计算区间长度的对数，向下取整 return max(st[l][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); // 返回区间最小值 } inline int read() { int x=0,f=1;char ch=getchar(); while (ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if (ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while (ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-48;ch=getchar();} return x*f; } int main() { int n,m; n=read(); m=read(); for(int i=1;i\u0026lt;=n;i++){ a[i]=read(); } build(n); while(m--){ int l=read(),r=read(); printf(\u0026#34;%d\\n\u0026#34;,query(l,r)); } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/st/","title":"ST表模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 深度优先搜索，用于求每个节点的深度和祖先信息 void dfs(int u, int fa) { depth[u] = depth[fa] + 1; // 当前节点的深度为父节点的深度加一 p[u][0] = fa; // 当前节点的 2^0 级祖先为父节点 // 递推求出当前节点的 2^i 级祖先 for (int i = 1; i \u0026lt; M; i ++ ) p[u][i] = p[p[u][i - 1]][i - 1]; // 遍历当前节点的每一个儿子，递归调用 dfs 函数 for (auto v : g[u]) if (v != fa) // 避免向父节点递归 dfs(v, u); } // 求两个节点的最近公共祖先 int lca(int a, int b) { if (depth[a] \u0026lt; depth[b]) swap(a, b); // 保证 a 深度不小于 b // 先将 a 跳到和 b 同一深度 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (depth[p[a][i]] \u0026gt;= depth[b]) a = p[a][i]; if (a == b) return a; // 特判 a 和 b 在同一条链上的情况 // 一起向上跳，直到 a 和 b 的第一个不同的祖先 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (p[a][i] != p[b][i]) { a = p[a][i]; b = p[b][i]; } return p[a][0]; // 返回 a 的父节点，即为 LCA } 【模板】最近公共祖先（LCA） 题目描述 如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。\n输入格式 第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。\n接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。\n接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。\n输出格式 输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 8 9 10 5 5 4 3 1 2 4 5 1 1 4 2 4 3 2 3 5 1 2 4 5 样例输出 #1 1 2 3 4 5 4 4 1 4 4 提示 对于 $30%$ 的数据，$N\\leq 10$，$M\\leq 10$。\n对于 $70%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。\n对于 $100%$ 的数据，$1 \\leq N,M\\leq 500000$，$1 \\leq x, y,a ,b \\leq N$，不保证 $a \\neq b$。\n样例说明：\n该树结构如下：\n第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。\n第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。\n第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。\n第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。\n第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。\n故输出依次为 $4, 4, 1, 4, 4$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N = 500010, M = 20; int n, m, s; // n：节点数，m：查询次数，s：根节点编号 int depth[N], p[N][M]; // depth：每个节点的深度，p：每个节点的 2^i 级祖先 vector\u0026lt;int\u0026gt; g[N]; // g：树的邻接表表示 // 深度优先搜索，用于求每个节点的深度和祖先信息 void dfs(int u, int fa) { depth[u] = depth[fa] + 1; // 当前节点的深度为父节点的深度加一 p[u][0] = fa; // 当前节点的 2^0 级祖先为父节点 // 递推求出当前节点的 2^i 级祖先 for (int i = 1; i \u0026lt; M; i ++ ) p[u][i] = p[p[u][i - 1]][i - 1]; // 遍历当前节点的每一个儿子，递归调用 dfs 函数 for (auto v : g[u]) if (v != fa) // 避免向父节点递归 dfs(v, u); } // 求两个节点的最近公共祖先 int lca(int a, int b) { if (depth[a] \u0026lt; depth[b]) swap(a, b); // 保证 a 深度不小于 b // 先将 a 跳到和 b 同一深度 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (depth[p[a][i]] \u0026gt;= depth[b]) a = p[a][i]; if (a == b) return a; // 特判 a 和 b 在同一条链上的情况 // 一起向上跳，直到 a 和 b 的第一个不同的祖先 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (p[a][i] != p[b][i]) { a = p[a][i]; b = p[b][i]; } return p[a][0]; // 返回 a 的父节点，即为 LCA } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; // 读入节点数、查询次数和根节点编号 // 逐个读入每条边，构建树的邻接表表示 for (int i = 1; i \u0026lt; n; i ++ ) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].push_back(b); g[b].push_back(a); } dfs(s, 0); // 求每个节点的深度和祖先信息 while (m -- ) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // 读入查询 cout \u0026lt;\u0026lt; lca(a, b) \u0026lt;\u0026lt; endl; // 输出 } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/lca/","title":"倍增LCA模板"},{"content":"模板 只适用于模数为质数的情况(费马小定理) 1 2 3 4 5 6 7 vector\u0026lt;long long\u0026gt; inv_vec(long long n, long long m) { vector\u0026lt;long long\u0026gt; inv(n + 1, 1); for (long long i = 2; i \u0026lt;= n; i++) { inv[i] = (m - m / i) * inv[m % i] % m; } return inv; } 【模板】乘法逆元 题目背景 这是一道模板题\n题目描述 给定 $n,p$ 求 $1\\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。\n这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\\equiv1\\pmod p$ 的解。\n输入格式 一行两个正整数 $n,p$。\n输出格式 输出 $n$ 行，第 $i$ 行表示 $i$ 在模 $p$ 下的乘法逆元。\n样例 #1 样例输入 #1 1 10 13 样例输出 #1 1 2 3 4 5 6 7 8 9 10 1 7 9 10 8 11 2 5 3 4 提示 $ 1 \\leq n \\leq 3 \\times 10 ^ 6, n \u0026lt; p \u0026lt; 20000528 $\n输入保证 $ p $ 为质数。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;iostream\u0026gt; using namespace std; const int N=3e6+2; long long inv[N]; void inv_vec(long long n, long long m) { inv[0]=1; inv[1]=1; for (long long i = 2; i \u0026lt;= n; i++) { inv[i] = (m - m / i) * inv[m % i] % m; printf(\u0026#34;%lld\\n\u0026#34;,inv[i]); } } int main(){ int n,p; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;p); printf(\u0026#34;1\\n\u0026#34;); inv_vec(n,p); return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/inv2/","title":"乘法逆元递推（费马小定理版）模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 long long extgcd(long long a, long long b, long long \u0026amp;x, long long \u0026amp;y) { if (b == 0) { x = 1; y = 0; return a; } long long d = extgcd(b, a % b, y, x); y -= a / b * x; return d; } long long inv(long long a, long long m) { long long x, y; if (extgcd(a, m, x, y) != 1) { return -1; // 不存在乘法逆元 } return (x % m + m) % m; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/inv1/","title":"乘法逆元模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 FOR(p,0,n){ while(!maxs.empty()\u0026amp;\u0026amp;maxs.back()\u0026lt;a[p])maxs.pop_back(); while(!mins.empty()\u0026amp;\u0026amp;mins.back()\u0026gt;a[p])mins.pop_back(); maxs.push_back(a[p]); mins.push_back(a[p]); ans1[p]=maxs.front(); ans2[p]=mins.front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;maxs.front()==a[p-k+1])maxs.pop_front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;mins.front()==a[p-k+1])mins.pop_front(); } 滑动窗口 /【模板】单调队列 题目描述 有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。\n例如：\nThe array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$。\n输入格式 输入一共有两行，第一行有两个正整数 $n,k$。 第二行 $n$ 个整数，表示序列 $a$\n输出格式 输出共两行，第一行为每次窗口滑动的最小值\n第二行为每次窗口滑动的最大值\n样例 #1 样例输入 #1 1 2 8 3 1 3 -1 -3 5 3 6 7 样例输出 #1 1 2 -1 -3 -3 -3 3 3 3 3 5 5 6 7 提示 【数据范围】 对于 $50%$ 的数据，$1 \\le n \\le 10^5$；\n对于 $100%$ 的数据，$1\\le k \\le n \\le 10^6$，$a_i \\in [-2^{31},2^{31})$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int a[N],ans1[N],ans2[N]; deque\u0026lt;int\u0026gt; maxs,mins; int main() { ios int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; FOR(i,0,n){ cin\u0026gt;\u0026gt;a[i]; } FOR(p,0,n){ while(!maxs.empty()\u0026amp;\u0026amp;maxs.back()\u0026lt;a[p])maxs.pop_back(); while(!mins.empty()\u0026amp;\u0026amp;mins.back()\u0026gt;a[p])mins.pop_back(); maxs.push_back(a[p]); mins.push_back(a[p]); ans1[p]=maxs.front(); ans2[p]=mins.front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;maxs.front()==a[p-k+1])maxs.pop_front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;mins.front()==a[p-k+1])mins.pop_front(); } FOR(i,k-1,n){ cout\u0026lt;\u0026lt;ans2[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; FOR(i,k-1,n){ cout\u0026lt;\u0026lt;ans1[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/monotonicqueue/","title":"单调队列模板"},{"content":"欧拉筛 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const int N=100; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 【模板】线性筛素数 题目背景 本题已更新，从判断素数改为了查询第 $k$ 小的素数\n提示：如果你使用 cin 来读入，建议使用 std::ios::sync_with_stdio(0) 来加速。\n题目描述 如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。\n输入格式 第一行包含两个正整数 $n,q$，分别表示查询的范围和查询的个数。\n接下来 $q$ 行每行一个正整数 $k$，表示查询第 $k$ 小的素数。\n输出格式 输出 $q$ 行，每行一个正整数表示答案。\n样例 #1 样例输入 #1 1 2 3 4 5 6 100 5 1 2 3 4 5 样例输出 #1 1 2 3 4 5 2 3 5 7 11 提示 【数据范围】\n对于 $100%$ 的数据，$n = 10^8$，$1 \\le q \\le 10^6$，保证查询的素数不大于 $n$。\nData by NaCly_Fish.\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e8; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int main() { ios int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; get_primes(n); while(q--){ int x; cin\u0026gt;\u0026gt;x; cout\u0026lt;\u0026lt;primes[x-1]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/eulersieve/","title":"欧拉筛模板"},{"content":"按序合并路径压缩优化并查集 封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Buf { public: Buf(int sz) : root(sz), rank(sz) { for (int i = 0; i \u0026lt; sz; i++) { root[i] = i; rank[i] = 1; } } int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] \u0026lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(int x, int y) { return find(x) == find(y); } private: vector\u0026lt;int\u0026gt; root; vector\u0026lt;int\u0026gt; rank; }; 非封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ll root[MAXN],rank[MAXN],n; void initbuf(ll n){ for (ll i = 0; i \u0026lt; n; i++) { root[i] = i; } } ll find(ll x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(ll x, ll y) { ll rootX = find(x); ll rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) root[rootY] = rootX; else if (rank[rootX] \u0026lt; rank[rootY])root[rootX] = rootY; else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(ll x, ll y) { return find(x) == find(y); } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/buf/","title":"并查集模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 ll qpow(ll a,ll b,ll p){ ll ans=1%p; while(b){ if(b\u0026amp;1)ans=(ans*a)%p; b\u0026gt;\u0026gt;=1; a=(a*a)%p; } return ans; } 题目描述 给你三个整数 $a,b,p$，求 $a^b \\bmod p$。\n输入格式 输入只有一行三个整数，分别代表 $a,b,p$。\n输出格式 输出一行一个字符串 a^b mod p=s，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。\n样例 #1 样例输入 #1 1 2 10 9 样例输出 #1 1 2^10 mod 9=7 提示 样例解释\n$2^{10} = 1024$，$1024 \\bmod 9 = 7$。\n数据规模与约定\n对于 $100%$ 的数据，保证 $0\\le a,b \u0026lt; 2^{31}$，$a+b\u0026gt;0$，$2 \\leq p \\lt 2^{31}$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; ll qpow(ll a,ll b,ll p){ ll ans=1%p; while(b){ if(b\u0026amp;1)ans=(ans*a)%p; b\u0026gt;\u0026gt;=1; a=(a*a)%p; } return ans; } int main() { ios ll a,b,p; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; ll res=qpow(a,b,p); cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;^\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; mod \u0026#34;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#34;=\u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/qpowp/","title":"快速幂取余模板"},{"content":"【模板】并查集 题目描述 如题，现在有一个并查集，你需要完成合并和查询操作。\n输入格式 第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。\n接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。\n当 $Z_i=1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。\n当 $Z_i=2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出 Y ；否则输出 N 。\n输出格式 对于每一个 $Z_i=2$ 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 8 4 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 样例输出 #1 1 2 3 4 N Y N Y 提示 对于 $30%$ 的数据，$N \\le 10$，$M \\le 20$。\n对于 $70%$ 的数据，$N \\le 100$，$M \\le 10^3$。\n对于 $100%$ 的数据，$1\\le N \\le 10^4$，$1\\le M \\le 2\\times 10^5$，$1 \\le X_i, Y_i \\le N$，$Z_i \\in { 1, 2 }$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; class Buf { public: Buf(int sz) : root(sz), rank(sz) { for (int i = 0; i \u0026lt; sz; i++) { root[i] = i; rank[i] = 1; } } int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] \u0026lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(int x, int y) { return find(x) == find(y); } private: vector\u0026lt;int\u0026gt; root; vector\u0026lt;int\u0026gt; rank; }; int main() { ios int n,m,y,x,z; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; Buf a=Buf(n+1); while(m--){ cin\u0026gt;\u0026gt;z\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(z==1){ a.unionSet(x,y); } else{ if(a.connected(x,y))cout\u0026lt;\u0026lt;\u0026#34;Y\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; cout\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0003/","title":"洛谷0003——并查集"},{"content":"[TJOI2009] 开关 题目描述 现有 $n$ 盏灯排成一排，从左到右依次编号为：$1$，$2$，……，$n$。然后依次执行 $m$ 项操作。\n操作分为两种：\n指定一个区间 $[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）； 指定一个区间 $[a,b]$，要求你输出这个区间内有多少盏灯是打开的。 灯在初始时都是关着的。\n输入格式 第一行有两个整数 $n$ 和 $m$，分别表示灯的数目和操作的数目。\n接下来有 $m$ 行，每行有三个整数，依次为：$c$、$a$、$b$。其中 $c$ 表示操作的种类。\n当 $c$ 的值为 $0$ 时，表示是第一种操作。 当 $c$ 的值为 $1$ 时，表示是第二种操作。 $a$ 和 $b$ 则分别表示了操作区间的左右边界。\n输出格式 每当遇到第二种操作时，输出一行，包含一个整数，表示此时在查询的区间中打开的灯的数目。\n样例 #1 样例输入 #1 1 2 3 4 5 6 4 5 0 1 2 0 2 4 1 2 3 0 2 4 1 1 4 样例输出 #1 1 2 1 2 提示 数据规模与约定 对于全部的测试点，保证 $2\\le n\\le 10^5$，$1\\le m\\le 10^5$，$1\\le a,b\\le n$，$c\\in{0,1}$。\\\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e5+9; //开4倍 //n 为维护的数组长度，A为维护的数组 ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //叶子节点可以不更新 if (len \u0026lt;= 1) return; //向下传递lazy标记 if(mark[p]%2)tree[p \u0026lt;\u0026lt; 1] = (len - len / 2)-tree[p\u0026lt;\u0026lt;1]; mark[p \u0026lt;\u0026lt; 1] += mark[p]%2; if(mark[p]%2)tree[p \u0026lt;\u0026lt; 1 | 1] = (len / 2)-tree[p\u0026lt;\u0026lt;1|1]; mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]%2; //向下传递了，自然清除自身的tag mark[p] = 0; } void push_up(int p){ //这里维护的是区间和 tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //如果叶子节点 if (cl == cr) return void(tree[p] = A[cl]); //左右递归建树 int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] = d * (cr - cl + 1)-tree[p]; mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } int main() { ios int m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; build(); int op,x,y; while(m--){ cin\u0026gt;\u0026gt;op; if(op==0){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; update(x,y,1); } else{ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll res=query(x,y); cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0004/","title":"洛谷0004——[TJOI2009] 开关"},{"content":"【模板】线段树 1 题目描述 如题，已知一个数列，你需要进行下面两种操作：\n将某区间每一个数加上 $k$。 求出某区间每一个数的和。 输入格式 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。\n第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。\n接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：\n1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 输出格式 输出包含若干行整数，即为所有操作 2 的结果。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 1 2 3 11 8 20 提示 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。\n对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。\n对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。\n保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。\n【样例解释】\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e5+9; //开4倍 //n 为维护的数组长度，A为维护的数组 ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //叶子节点可以不更新 if (len \u0026lt;= 1) return; //向下传递lazy标记 tree[p \u0026lt;\u0026lt; 1] += mark[p] * (len - len / 2); mark[p \u0026lt;\u0026lt; 1] += mark[p]; tree[p \u0026lt;\u0026lt; 1 | 1] += mark[p] * (len / 2); mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]; //向下传递了，自然清除自身的tag mark[p] = 0; } void push_up(int p){ //这里维护的是区间和 tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //如果叶子节点 if (cl == cr) return void(tree[p] = A[cl]); //左右递归建树 int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] += d * (cr - cl + 1); mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } int main() { ios int m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; FOR(i,1,n+1){ cin\u0026gt;\u0026gt;A[i]; } build(); int op,x,y,k; while(m--){ cin\u0026gt;\u0026gt;op; if(op==1){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;k; update(x,y,k); } else{ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll res=query(x,y); cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0005/","title":"洛谷0005——【模板】线段树 1"},{"content":"封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class FenwickTree{ public: int n; vector\u0026lt;int\u0026gt; tree; FenwickTree(int i): n(i),tree(i+1){ for(int a=0;a\u0026lt;=i;a++){ tree[a]=0; } } void update(int i,int val){ while(i\u0026lt;=n){ tree[i]+=val; i+=i\u0026amp;(-i); } } int query(int i){ int res=0; while(i\u0026gt;0){ res+=tree[i]; i-=i\u0026amp;(-i); } return res; } } 非封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //n为实际长度 ll tree[MAXN],n; void update(int i,int val){ while(i\u0026lt;=n){ tree[i]+=val; i+=i\u0026amp;(-i); } } int query(int i){ int res=0; while(i\u0026gt;0){ res+=tree[i]; i-=i\u0026amp;(-i); } return res; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/fenwicktree/","title":"树状数组模板"},{"content":"lazy线段树模板 区间修改logn 区间查询logn （维护存在交换律的信息） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 const int MAXN=1e5+9; //开4倍 //n 为维护的数组长度，A为维护的数组 ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //叶子节点可以不更新 if (len \u0026lt;= 1) return; //向下传递lazy标记 tree[p \u0026lt;\u0026lt; 1] += mark[p] * (len - len / 2); mark[p \u0026lt;\u0026lt; 1] += mark[p]; tree[p \u0026lt;\u0026lt; 1 | 1] += mark[p] * (len / 2); mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]; //向下传递了，自然清除自身的tag mark[p] = 0; } void push_up(int p){ //这里维护的是区间和 tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //如果叶子节点 if (cl == cr) return void(tree[p] = A[cl]); //左右递归建树 int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] += d * (cr - cl + 1); mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/segmenttree/","title":"线段树模板"},{"content":"【深进1.例1】求区间和 题目描述 给定 $n$ 个正整数组成的数列 $a_1, a_2, \\cdots, a_n$ 和 $m$ 个区间 $[l_i,r_i]$，分别求这 $m$ 个区间的区间和。对于所有测试数据，$n,m\\le10^5,a_i\\le 10^4$\n输入格式 共 $n+m+2$ 行。\n第一行，为一个正整数 $n$ 。\n第二行，为 $n$ 个正整数 $a_1,a_2, \\cdots ,a_n$\n第三行，为一个正整数 $m$ 。\n第 $4$ 到第 $n+m+2$ 行，每行为两个正整数 $l_i,r_i$ ，满足$1\\le l_i\\le r_i\\le n$\n输出格式 共 $m$ 行。\n第 $i$ 行为第 $i$ 组答案的询问。\n样例 #1 样例输入 #1 1 2 3 4 5 4 4 3 2 1 2 1 4 2 3 样例输出 #1 1 2 10 5 提示 样例解释：第 1 到第 4 个数加起来和为 10。第 2 个数到第 3 个数加起来和为5。\n对于 50% 的数据：$n,m\\le 1000$ ；\n对于100% 的数据：$n.m\\le 10^5,a_i\\le 10^4$\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+3; int a[N]; int b[N]; int main() { ios int n,m; cin\u0026gt;\u0026gt;n; FOR(i,0,n){ cin\u0026gt;\u0026gt;a[i]; } FOR(i,1,n+1){ b[i]=b[i-1]+a[i-1]; } cin\u0026gt;\u0026gt;m; int l,r; FOR(i,0,m){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;b[r]-b[l-1]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0001/","title":"洛谷0001——求区间和"},{"content":"最大加权矩形 题目描述 为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。\n校长先给他们一个 $n\\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如\n1 2 3 4 0 –2 –7 0 9 2 –6 2 -4 1 –4 1 -1 8 0 –2 在左下角：\n1 2 3 9 2 -4 1 -1 8 和为 $15$。\n几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？\n输入格式 第一行：$n$，接下来是 $n$ 行 $n$ 列的矩阵。\n输出格式 最大矩形（子矩阵）的和。\n样例 #1 样例输入 #1 1 2 3 4 5 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 样例输出 #1 1 15 提示 $1 \\leq n\\le 120$\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=123; int a[N][N]; int b[N][N]; int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,0,n){ FOR(j,0,n){ cin\u0026gt;\u0026gt;a[i][j]; } } FOR(i,1,n+1){ FOR(j,1,n+1){ b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i-1][j-1]; } } int ans=-inf; FOR(x1,1,n+1){ FOR(y1,1,n+1){ FOR(x2,x1,n+1){ FOR(y2,y1,n+1){ ans=max(ans,b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1]); } } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0002/","title":"洛谷0002——最大加权矩形"},{"content":"一维前缀和 1 2 3 // S[i] = a[1] + a[2] + ... a[i] // a[l] + ... + a[r] = S[r] - S[l - 1] S[r] - S[l - 1] 二维前缀和 1 2 3 4 // S[i, j] = 第i行j列格子左上部分所有元素的和 b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j] // 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1] 一维差分 1 2 // 给区间[l, r]中的每个数加上c： B[l] += c, B[r + 1] -= c 二维差分 1 2 // 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1][y1] += c, S[x2 + 1][y1] -= c, S[x1][y2 + 1] -= c, S[x2 + 1][y2 + 1] += c tips 从1开始，0开大，防特判 ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/presum/","title":"前缀和与差分模板"},{"content":" 1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\u0026#34;); return 0; } 基础知识 分号 每个语句必须以分号结束\n符号类型 一定要是英文符号\n注释 单行注释 多行注释(也可单行) 1 2 3 //单行注释 /*多行注释*/ 数据类型 TYPE BYTE MORE char 1 字节 -128 到 127 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 ——— unsigned int 2 或 4 字节 ——— short 2 字节 ——— unsigned short 2 字节 ——— long 4 字节 ——— unsigned long 4 字节 ——— float 4 字节 6 位有效位 double 8 字节 15 位有效位 long double 16 字节 19 位有效位 1 2 3 4 5 6 7 //sizeof可以获取储存字节大小 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;int 存储大小 : %lu \\n\u0026#34;,sizeof(int)); return 0; } 常量 整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。\n浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。\n字符常量 单引号内 char -\u0026gt; 1字节 转义字符 \\n 换行符号 \\b 退格 \\ (特殊符号) 本身 字符串常量 双引号中\n多行时\n定义常量 1 2 //name=value #define name value 变量 变量名可以是字母、数字和下划线的组合\n规则\n开头必须是字母或 下划线（可以下划线） 不可以是C语言关键字 不能有空格 类型转换 显示转换 1 2 3 c=1.2F b=(int)c //要注意在c中强制转换不是一个函数式转换 隐式转换 方向： 精度上升 特殊： scanf/printf 只能int-chr转换(精度上升的转换都不行？) char - int 转换(显/隐) 详见字符ascii 储存类（不考） 运算符 算数运算符 + - * / 小心隐式转换（加减也会） 除法取全舍去（负时偏向绝对值） 1 2 3 //例如 10/3==-3; 10/(-3)==-3 取模 % 在算法中常/与%使用依次去位数\n(高精度模板题)\n++\u0026ndash; 自增自减 注意Attention！\na++ 先赋值后运算\n++a 先运算后赋值\n赋值运算符 形式： (算数运算符)$=$\n如 a += 1\n关系运算符\n== != \u0026gt; \u0026lt; \u0026lt;= \u0026gt;= 注意Attention！\n在c中不能1\u0026lt;a\u0026lt;b这样判断\n逻辑运算符 与 \u0026amp;\u0026amp; 或 || 非 ! 位运算符号\n详见 位运算 输入输出 输入流 stdin 未读取的不会清空，共享\n1 2 3 4 5 6 //手动清空输入流 //通过连续读取来清空输入流 int r=getchar(); while (r!=EOF){ r=getchar() } 输出流 stdout 连续，不会自动换行 -\u0026gt; \\n的重要性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int main(){ char a; //其实getchar()返回的是int，不过由于char-int的隐式转换，也无所谓 //每当按下回车时getchar会读取stdin中第一个，并将其从stdin中弹出 a=getchar(); //putchar 接收的也是int putchar(a); //scanf 记得占位符正确和写寻地址符 //当然数组名本身即使地址，不要寻地址符 //每当按下回车时getchar会读取stdin中前n个（取决于占位符），并将其从stdin中弹出 scanf(\u0026#34;%c\u0026#34;,\u0026amp;a); //一般函数最后输出结尾都会加上\\n printf(\u0026#34;%c\\n\u0026#34;,a); return 0; } 占位符 占位符 类型 %d int %c char %s str(char[]) %f float %.3f 3位 %lf double %p pointer 字符ascii 32 空格 48-57 数字0-9 65-90 大写字母 97-122 小写字母 1 2 3 4 5 6 7 8 9 10 // 标准输入输出库 #include \u0026lt;stdio.h\u0026gt; int main(){ //隐式转换 97 a int c = \u0026#39;a\u0026#39;; printf(\u0026#34;%c %d\u0026#34;,c,c); //在c中取ascii码值可直接类型转换得出 //而由“11”(str)取得11(int)可调库，或者哈希映射（自建数组下表映射或者ascii映射(+48)) return 0; } 更多输入输出 详见字符串\n文件读写 文件打开和关闭 不要忘记关闭文件\n1 2 3 4 // open FILE *fopen( const char *filename, const char *mode ); // close fclose( FILE *fp ); filename 文件路径 mode 访问模式 mode description r read 只读 w write 只写，重写/新建(会覆盖) a add 只写，追加/新建(不会覆盖) r+ 读写 w+ 读写，重写/新建(会覆盖) a+ 读写，追加/新建(不会覆盖) 二进制模式 \u0026ldquo;rb\u0026rdquo;, \u0026ldquo;wb\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;rb+\u0026rdquo;, \u0026ldquo;r+b\u0026rdquo;, \u0026ldquo;wb+\u0026rdquo;, \u0026ldquo;w+b\u0026rdquo;, \u0026ldquo;ab+\u0026rdquo;, \u0026ldquo;a+b\u0026rdquo;\nEOF 1 2 //在c中EOF标识符实际为-1 #define EOF -1 读取文件 注意fscanf()先要传入fp，和其它相反\n1 2 3 4 //char *buf 为缓冲区（自己开一个数组） int fgetc( FILE * fp ); char *fgets( char *buf, int n, FILE *fp ); int fscanf(FILE *fp ,const char *s, char *buf); 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 \u0026lsquo;\\n\u0026rsquo; 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符 int fscanf(FILE *fp, const char *format, \u0026hellip;) 函数文件中读取字符串在遇到第一个空格和换行符时，会停止读取\n写入文件 注意fprintf()先要传入fp，和其它相反\n1 2 3 4 // 失败时返回EOF int fputc( int c, FILE *fp ); int fputs( const char *s, FILE *fp ); int fprintf(FILE * fp,const char*s); 二进制读写 1 2 fread(); fwrite(); 二进制 比特与字节 bit 二进制一个数位 1 byte = 8 bit 进制转换 10进制-\u0026gt;2进制： 除2法取余数 2进制-\u0026gt;10进制： 从右到左依次乘从$2^0$开始到$2^n$的和\n位运算 与 \u0026amp; 或 | 取反 ~ 异或 ^ 左右移 \u0026laquo;\u0026lt; \u0026raquo;\u0026gt; 1 2 3 4 5 6 int a=4; //二进制右移1位即除以2，左一乘以2 //同理，十进制则1位乘除10，注意c中左右移符号是二进制的移动 if (a\u0026gt;\u0026gt;1==a/2){ printf(\u0026#34;True\u0026#34;); } 常见性质(略) 二进制算法 二进制枚举 快速幂 基础结构 分支结构 1 2 3 4 5 6 7 8 9 10 11 12 13 //分支 if (){ } else if (){ } else{ } //三元 a==0?printf(\u0026#34;a=0\u0026#34;):printf(\u0026#34;a!=0\u0026#34;); !!!注意\n如果switch没有break则会继续执行（会触发default或者其它case）\nexpression必须是常量表达式，必须是一个整型或枚举类型\n1 2 3 4 5 6 7 8 9 10 11 12 switch(expression){ case constant-expression : statement(s); break; /* 可选的 */ case constant-expression : statement(s); break; /* 可选的 */ /* 您可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s); } 循环结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int a=10; while(1){ a--; if (a\u0026gt;5){ continue; } printf(\u0026#34;NO\u0026#34;) if (a\u0026lt;4) break; } for(a=10;a\u0026lt;3;a--){ printf(\u0026#34;%d,a\u0026#34;); } do{ printf(\u0026#34;%d\u0026#34;,a); a-=1 }while(a); 省略 如果只跟一个句子，可以省略大括号 单数字作为条件时0假其它真 如下面的句子是合法的\n1 2 3 4 5 6 7 8 9 10 for(int i=0;i\u0026lt;10;i++) for(int j=i;j\u0026lt;10;j++) printf(\u0026#34;%d\u0026#34;,j); if(a==0) printf(\u0026#34;YES!!!\u0026#34;); int a=0; if(!a){ printf(\u0026#34;a is zero\u0026#34;); } 数组与字符串 一维数组 声明格式 type arrayName [ arraySize ]; 1 int a[50]; 初始化(大括号) 1 2 3 4 5 6 7 8 9 //标准初始化 int a[2]={1,2}; //可以只初始化少初始化，但不能多初始化 //即大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目 int a[10]={1,4,3,5}; //如果没有指定数组大小，则其等于初始化个数 int a[]={1,2,4}; 两种访问 下标（索引）从0开始 指针访问（数组名指向数组第一个元素的地址，数组储存连续） 详见指针 高维数组 声明与初始化\n(要记得大小从1开始，但索引从0开始) 1 2 3 4 5 // int a[2][2][2]; // // int a[2][3]={1,2,3,2,4,6} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 - 两种访问 - 下标（索引）从0开始 - 指针访问 - 列指针与行指针 - 单指针（利用连续性） [详见指针](#指针) ### 字符串 \u0026gt;everal ways to initialize a string **一定**以 ***\u0026#39;\\0\u0026#39;*** 结尾 + char str[20] = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\0\u0026#39;}; + char str[20] = \u0026#34;Hello\u0026#34;; // \u0026#39;\\0\u0026#39; is automatically set to str[5] + char str[] = \u0026#34;Hello\u0026#34;; //str\u0026#39;s size is 6 如果已经声明，就不能进行**初始化** #### 易错练习 是否正确？ ```c //注意字符和字符串的引号 //注意隐式转换 char a[]={\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,0} 字符串相关 \u0026lt;stdio.h\u0026gt; printf() %s\nsprintf() 1 2 3 4 5 6 7 8 int sprintf( char *str, const char *format, ... ); char buffer[50]; int n, a = 5, b = 3; n = sprintf(buffer, \u0026#34;%d plus %d is %d\u0026#34;, a, b, a+b); // n 实际长度13 //buffer=\u0026#34;5 plus 3 is 8\u0026#34; puts() puts stops printing when it meets \u0026lsquo;\\0\u0026rsquo;.\nscanf() %s 读到空格停止 %ns 读到空格/读n个字符停止 gets() 读一整行，字符数组开小了可能越界\nfgets() fgets(your_line, sizeof(your_line), stdin)\n利用sizeof ，防止越界\n字符串相关 \u0026lt;string.h\u0026gt; strlen() length of str, not including \u0026lsquo;\\0\u0026rsquo;;\nstrcpy(destination,source) 字符串赋值要strcpy，别直接等于号赋值\ncopy string from source to destination(包括\u0026rsquo;\\0\u0026rsquo;)\n小心越界\nstrncpy(destination, source, n) 复制前n个字符，最后自动加上\u0026rsquo;\\0\u0026rsquo;\nstrcmp(str1, str2) 逐位比较ascii，直到某一位ascii不一样，str1\u0026gt;str2 返回 1，相等返回0，其余-1\nstrncmp(str1, str2, n) 前n个\nstrcat(destination, source); 连接，加在dest上，小心越界\n字符串相关 \u0026lt;stdlib.h\u0026gt; atoi(str) str-\u0026gt;int\n支持正负号\n取前面可以转换的，到非数字字符停止(无视空格) ex. atoi(\u0026quot;-10aaa\u0026quot;)=-10\natof(str) • Same as atoi\n• Space, +, - are acceptable\n• An E or e (exponent) is acceptable\n• A decimal point is acceptable\n相关算法（仅作了解） BF，BK，KMP，BM 前缀树 后缀树 AC自动机 其它 基础语法 函数 函数的声明 如果函数放于main函数后面/多文件，需要提前声明 声明时参数的名称并不重要，只有参数的类型是必需的，因此以下都是都是有效声明 1 2 int max(int, int); int max(int a, int b); void 无返回值 返回多个值 利用指针 形式参数 详见作用域 传递数组 传一个指针 传不定长数组(ex. int a[],如果二维需要指定第二维度，int a[][3]) 传定长数组(int a[20]) #define函数 1 2 #define MAX(a,b) a\u0026gt;b?a:b #define SQ(x) x*x 作用域 3 types 在函数或块内部的局部变量,在所有函数外部的全局变量,在形式参数的函数参数定义中\nsmall has big 小可以改大的，大不能改小的\n形参同名替代（小带大） 但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用\n递归 懂得都懂 ——佚名 自顶向下,利用系统栈\n经典题 斐波那契 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int Fibonacci(int n){ if (n\u0026lt;=2){ return 1; } return Fibonacci(n-1)+Fibonacci(n-2); } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;%d\u0026#34;,Fibonacci(n)); return 0; } 命令行参数 1 2 3 int main(int argc, char *argv[] ){ return 0; } argc 存放命令行参数的个数 *argv[] 从argv[1]开始存放每一个参数的指针，第一个即argv[0]存放程序名 多文件 构成 宏文件（xxx.h） 文件存放声明\nxxx.c 文件存放函数\n主函数里 #include\u0026quot;xxx.h\u0026quot;\n进阶语法 指针 结构体 结构体定义与初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 //一个完整结构体的example struct tag1{ int a; char b[30]; }variable1={1,\u0026#34;ssss\u0026#34;}; struct tag1 variable2; typedef struct{ float f; }tag2; tag2 variable3; ！！！注意！！！\n无论如何struct结尾必须有分号 typedef格式固定，下面不是变量而是标签 如果变量已经声明，就不能进行初始化 1 2 3 4 5 6 7 8 9 10 11 //无typedef时下面一定是变量（无标签） struct { int a; }VARIABLE; //下面一定是tag //tag 不能放上面 //实质 typedef struct{int a;} TAG; //类同 typedef unsigned char UC; typedef struct{ int a; }TAG; 结构体内部元素赋值 1 2 3 4 5 6 7 8 9 struct day{ char feeling[100]; int time; }today; today.time=222; strcpy(today.feeling,\u0026#34;dddd\u0026#34;); struct day yesterday={\u0026#34;good\u0026#34;,221}; 结构体指针 接着上文定义的结构体\n1 2 3 struct day *check; check=\u0026amp;today printf(\u0026#34;%s\u0026#34;,check-\u0026gt;feeling); 结构体数组 接着上文定义的结构体\n1 2 3 4 5 6 struct day holiday[60]; int i; for(i=0;i\u0026lt;60;i++){ strcpy(holiday[i].feeling,happy); holiday[i].time=i; } 枚举类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 enum week { MON=1, TUE, WED, THU, FRI, SAT, SUN }day; day=MON; printf(\u0026#34;%d\u0026#34;,day); //若不初始化MON，默认第一个是 0 //注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。 //如果我们把第3个枚举成员的值定义为 9，第4个就为 10，以此类推，第2个依然为1。 //可以和整形强制转化 int a=1; days=(enum week)a; //days=MON 动态内存 入门级基础算法 数学 求质数 了解朴素质数判定即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 朴素质数判定 /* 已经声明过 #define true 1 #define false 0 */ int check(int a){ if (a\u0026lt;2){ return false; } int i; for(i=2;i*i\u0026lt;a;i++){ if (a%i==0){ return false; } } return true; } 最大公约数\n了解欧几里得算法即可\n1 2 3 4 int gcd(int a,int b){ if (b==0) return a; return gcd(b, a % b); } 最小公倍数\n$lcm(a,b)gcd(a,b)=ab$\n先求出gcd即可\n高精度（了解加法减法即可）\n排序 稳定排序 不稳定排序 计数排序 桶排序 qsort() 双指针 同向 逆向 滑窗 ","date":"2023-04-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/cstart/","title":"C语言快速入门"},{"content":"位运算 a的b次方对p取模 前置知识\nqpow math:$(a+b)%p=(a%p+b%p)%p$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 求 a的 b次方对 p取模的值。 // 输入格式 // 三个整数 a,b,p，在同一行用空格隔开。 // 输出格式 // 输出一个整数，表示a^b mod p的值。 // 数据范围 // 0≤a,b≤10^9 // 1≤p≤109 // 输入样例： // 3 2 7 // 输出样例： // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; // 防止当b=0，p=1时被卡 res=1%p; while(b){ if(b\u0026amp;1)res=(res*a)%p; a*=a; a%=p; b\u0026gt;\u0026gt;=1; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } a*b对p取模 前置知识\nqpow math:(a+b)%p=(a%p+b%p)%p 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 求 a // 乘 b // 对 p // 取模的值。 // 输入格式 // 第一行输入整数a // ，第二行输入整数b // ，第三行输入整数p // 。 // 输出格式 // 输出一个整数，表示a*b mod p的值。 // 数据范围 // 1≤a,b,p≤1018 // 输入样例： // 3 // 4 // 5 // 输出样例： // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res=0; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; while(b){ if(b\u0026amp;1)res=(res+a)%p; b\u0026gt;\u0026gt;=1; a*=2; a%=p; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } 最短Hamilton路径 前置知识\n旅行商问题:NP完全,没有多项式时间解法 位运算 状压DP bitset:STL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // 给定一张 n个点的带权无向图，点从 0∼n−1标号，求起点 0到终点 n−1的最短 Hamilton 路径。 // Hamilton 路径的定义是从 0到 n−1不重不漏地经过每个点恰好一次。输入格式 // 第一行输入整数 n。 // 接下来 n行每行 n个整数，其中第 i行第 j个整数表示点 i到 j的距离（记为 a[i,j]）。 // 对于任意的 x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x]并且 a[x,y]+a[y,z]≥a[x,z]。 // 输出格式 // 输出一个整数，表示最短 Hamilton 路径的长度。 // 数据范围 // 1≤n≤20 // 0≤a[i,j]≤107 // 输入样例： // 5 // 0 2 4 5 1 // 2 0 6 5 3 // 4 6 0 8 3 // 5 5 8 0 5 // 1 3 3 5 0 // 输出样例： // 18 #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) #define inf 0x3f const int N=20,M=1\u0026lt;\u0026lt;20; int n; //大数组开到全局里，防止爆栈 //f[i][j]: i:经过状态，j:j点最短路 int f[M][N],w[N][N]; int main(){ cin\u0026gt;\u0026gt;n; For(i,0,n){ For(j,0,n){ cin\u0026gt;\u0026gt;w[i][j]; } } memset(f,inf,sizeof(f)); f[1][0]=0; For(i,0,1\u0026lt;\u0026lt;n){ For(j,0,n){ if(i\u0026gt;\u0026gt;j\u0026amp;1){ //int p=i^(1\u0026lt;\u0026lt;j) int p=i-(1\u0026lt;\u0026lt;j); For(k,0,n){ if(p\u0026amp;(1\u0026lt;\u0026lt;k)) // if(p\u0026gt;\u0026gt;k\u0026amp;1) f[i][j]=min(f[i][j],f[p][k]+w[k][j]); } } } } cout\u0026lt;\u0026lt;f[(1\u0026lt;\u0026lt;n)-1][n-1]\u0026lt;\u0026lt;endl; return 0; } 起床困难综合症 前置知识\n位运算性质 :与或非运算在二进制表示下不进位，也就是说每个bit之间独立位运算 贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 // 21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。 // 作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。 // 通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 // 正是由于 drd 的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。 // 为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。 // 历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。 // drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。 // 具体说来，drd 的防御战线由 n扇防御门组成。 // 每扇防御门包括一个运算 op // 和一个参数 t ，其中运算一定是 OR,XOR,AND中的一种，参数则一定为非负整数。 // 如果还未通过防御门时攻击力为 x // 则其通过这扇防御门后攻击力将变为 x op t // 最终 drd 受到的伤害为对方初始攻击力 x // 依次经过所有 n扇防御门后转变得到的攻击力。 // 由于 atm 水平有限，他的初始攻击力只能为 0 // 到 m之间的一个整数（即他的初始攻击力只能在 0,1,…,m中任选， // 但在通过防御门之后的攻击力不受 m的限制）。 // 为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。 // 输入格式 // 第 1行包含 2个整数，依次为 n,m，表示 drd 有 n扇防御门，atm 的初始攻击力为 0到 m之间的整数。 // 接下来 n 行，依次表示每一扇防御门。每行包括一个字符串 op 和一个非负整数 t ，两者由一个空格隔开，且 op 在前，t 在后，op 表示该防御门所对应的操作，t 表示对应的参数。 // 输出格式 // 输出一个整数，表示 atm 的一次攻击最多使 drd 受到多少伤害。 // 数据范围 // QQ截图20190907125839.png // 输入样例： // 3 10 // AND 5 // OR 6 // XOR 7 // 输出样例： // 1 // 样例解释 // atm可以选择的初始攻击力为 0,1,…,10 // 假设初始攻击力为 4，最终攻击力经过了如下计算 // 4 AND 5 = 4 // 4 OR 6 = 6 // 6 XOR 7 = 1 //类似的，我们可以计算出初始攻击力为 1,3,5,7,9 时最终攻击力为 0 ，初始攻击力为 0,2,4,6,8,10 时最终攻击力为 1 ，因此 atm 的一次攻击最多使 drd 受到的伤害值为 1 。 // 运算解释 // 在本题中，选手需要先将数字变换为二进制后再进行计算。如果操作的两个数二进制长度不同，则在前补 0 // 至相同长度。 // OR 为按位或运算，处理两个长度相同的二进制数，两个相应的二进制位中只要有一个为 1，则该位的结果值为 1，否则为 0。 // XOR 为按位异或运算，对等长二进制模式或二进制数的每一位执行逻辑异或操作。如果两个相应的二进制位不同（相异），则该位的结果值为 1，否则该位为 0 // AND 为按位与运算，处理两个长度相同的二进制数，两个相应的二进制位都为 1，该位的结果值才为 1，否则为 0 // 例如，我们将十进制数 5与十进制数 3 // 分别进行 OR、XOR与 AND运算，可以得到如下结果： // 0101 (十进制 5) 0101 (十进制 5) 0101 (十进制 5) // OR 0011 (十进制 3) XOR 0011 (十进制 3) AND 0011 (十进制 3) // = 0111 (十进制 7) = 0110 (十进制 6) = 0001 (十进制 1) #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) const int N=1e6; vector\u0026lt;pair\u0026lt;string,int\u0026gt;\u0026gt; a(N); string op; int t; int n,m; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int change(int p,int q){ For(i,0,n){ int x=a[i].second\u0026gt;\u0026gt;p\u0026amp;1; if(a[i].first==\u0026#34;AND\u0026#34;)q\u0026amp;=x; else if(a[i].first==\u0026#34;OR\u0026#34;)q|=x; else {q^=x;} } return q; } int main(){ ios cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; For(i,0,n){ cin\u0026gt;\u0026gt;a[i].first; cin\u0026gt;\u0026gt;a[i].second; } int pre=0,aft=0; For(i,0,30){ int p=29-i; int pos1=change(p,0); int pos2=change(p,1); if(pre+(1\u0026lt;\u0026lt;p)\u0026lt;=m \u0026amp;\u0026amp; pos2\u0026gt;pos1){ pre+=1\u0026lt;\u0026lt;p; aft+=pos2\u0026lt;\u0026lt;p; } else aft+=pos1\u0026lt;\u0026lt;p; } cout\u0026lt;\u0026lt;aft\u0026lt;\u0026lt;endl; } XOR成对变换 1 2 3 4 if n\u0026amp;1: n^1==n-1 else: n^1==n+1 lowbit n\u0026amp;(-n)\n飞行员兄弟 前置知识\n贪心 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 “飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有 16个把手的冰箱。 已知每个把手可以处于以下两种状态之一：打开或关闭。 只有当所有把手都打开时，冰箱才会打开。 把手可以表示为一个 4×4的矩阵，您可以改变任何一个位置 [i,j]上把手的状态。 但是，这也会使得第 i行和第 j列上的所有把手的状态也随着改变。 请你求出打开冰箱所需的切换把手的次数最小值是多少。 输入格式 输入一共包含四行，每行包含四个把手的初始状态。 符号 + 表示把手处于闭合状态，而符号 - 表示把手处于打开状态。 至少一个手柄的初始状态是关闭的。 输出格式 第一行输出一个整数 N，表示所需的最小切换把手次数。 接下来 N行描述切换顺序，每行输出两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。 注意：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。 数据范围 1≤i,j≤4 输入样例： -+-- ---- ---- -+-- 输出样例： 6 1 1 1 3 1 4 4 1 4 3 4 4 费解的开关 前置知识\n贪心 分而治之 前缀和与差分 二分 排序 倍增 贪心 ","date":"2023-04-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue00/","title":"小蓝书0X00总结"}]