[{"content":" 1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\u0026#34;); return 0; } 基础知识 分号 每个语句必须以分号结束\n符号类型 一定要是英文符号\n注释 单行注释 多行注释(也可单行) 1 2 3 //单行注释 /*多行注释*/ 数据类型 TYPE BYTE MORE char 1 字节 -128 到 127 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 ——— unsigned int 2 或 4 字节 ——— short 2 字节 ——— unsigned short 2 字节 ——— long 4 字节 ——— unsigned long 4 字节 ——— float 4 字节 6 位有效位 double 8 字节 15 位有效位 long double 16 字节 19 位有效位 1 2 3 4 5 6 7 //sizeof可以获取储存字节大小 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;int 存储大小 : %lu \\n\u0026#34;,sizeof(int)); return 0; } 常量 整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。\n浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。\n字符常量 单引号内 char -\u0026gt; 1字节 转义字符 \\n 换行符号 \\b 退格 \\ (特殊符号) 本身 字符串常量 双引号中\n多行时\n定义常量 1 2 //name=value #define name value 变量 变量名可以是字母、数字和下划线的组合\n规则\n开头必须是字母或 下划线（可以下划线） 不可以是C语言关键字 不能有空格 类型转换 显示转换 1 2 3 c=1.2F b=(int)c //要注意在c中强制转换不是一个函数式转换 隐式转换 方向： 精度上升 特殊： scanf/printf 只能int-chr转换(精度上升的转换都不行？) char - int 转换(显/隐) 详见字符ascii 储存类（不考） 运算符 算数运算符 + - * / 小心隐式转换（加减也会） 除法取全舍去（负时偏向绝对值） 1 2 3 //例如 10/3==-3; 10/(-3)==-3 取模 % 在算法中常/与%使用依次去位数\n(高精度模板题)\n++\u0026ndash; 自增自减 注意Attention！\na++ 先赋值后运算\n++a 先运算后赋值\n赋值运算符 形式： (算数运算符)$=$\n如 a += 1\n关系运算符\n== != \u0026gt; \u0026lt; \u0026lt;= \u0026gt;= 注意Attention！\n在c中不能1\u0026lt;a\u0026lt;b这样判断\n逻辑运算符 与 \u0026amp;\u0026amp; 或 || 非 ! 位运算符号\n详见 位运算 输入输出 输入流 stdin 未读取的不会清空，共享\n1 2 3 4 5 6 //手动清空输入流 //通过连续读取来清空输入流 int r=getchar(); while (r!=EOF){ r=getchar() } 输出流 stdout 连续，不会自动换行 -\u0026gt; \\n的重要性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int main(){ char a; //其实getchar()返回的是int，不过由于char-int的隐式转换，也无所谓 //每当按下回车时getchar会读取stdin中第一个，并将其从stdin中弹出 a=getchar(); //putchar 接收的也是int putchar(a); //scanf 记得占位符正确和写寻地址符 //当然数组名本身即使地址，不要寻地址符 //每当按下回车时getchar会读取stdin中前n个（取决于占位符），并将其从stdin中弹出 scanf(\u0026#34;%c\u0026#34;,\u0026amp;a); //一般函数最后输出结尾都会加上\\n printf(\u0026#34;%c\\n\u0026#34;,a); return 0; } 占位符 占位符 类型 %d int %c char %s str(char[]) %f float %.3f 3位 %lf double %p pointer 字符ascii 32 空格 48-57 数字0-9 65-90 大写字母 97-122 小写字母 1 2 3 4 5 6 7 8 9 10 // 标准输入输出库 #include \u0026lt;stdio.h\u0026gt; int main(){ //隐式转换 97 a int c = \u0026#39;a\u0026#39;; printf(\u0026#34;%c %d\u0026#34;,c,c); //在c中取ascii码值可直接类型转换得出 //而由“11”(str)取得11(int)可调库，或者哈希映射（自建数组下表映射或者ascii映射(+48)) return 0; } 更多输入输出 详见字符串\n文件读写 文件打开和关闭 不要忘记关闭文件\n1 2 3 4 // open FILE *fopen( const char *filename, const char *mode ); // close fclose( FILE *fp ); filename 文件路径 mode 访问模式 mode description r read 只读 w write 只写，重写/新建(会覆盖) a add 只写，追加/新建(不会覆盖) r+ 读写 w+ 读写，重写/新建(会覆盖) a+ 读写，追加/新建(不会覆盖) 二进制模式 \u0026ldquo;rb\u0026rdquo;, \u0026ldquo;wb\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;rb+\u0026rdquo;, \u0026ldquo;r+b\u0026rdquo;, \u0026ldquo;wb+\u0026rdquo;, \u0026ldquo;w+b\u0026rdquo;, \u0026ldquo;ab+\u0026rdquo;, \u0026ldquo;a+b\u0026rdquo;\nEOF 1 2 //在c中EOF标识符实际为-1 #define EOF -1 读取文件 注意fscanf()先要传入fp，和其它相反\n1 2 3 4 //char *buf 为缓冲区（自己开一个数组） int fgetc( FILE * fp ); char *fgets( char *buf, int n, FILE *fp ); int fscanf(FILE *fp ,const char *s, char *buf); 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 \u0026lsquo;\\n\u0026rsquo; 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符 int fscanf(FILE *fp, const char *format, \u0026hellip;) 函数文件中读取字符串在遇到第一个空格和换行符时，会停止读取\n写入文件 注意fprintf()先要传入fp，和其它相反\n1 2 3 4 // 失败时返回EOF int fputc( int c, FILE *fp ); int fputs( const char *s, FILE *fp ); int fprintf(FILE * fp,const char*s); 二进制读写 1 2 fread(); fwrite(); 二进制 比特与字节 bit 二进制一个数位 1 byte = 8 bit 进制转换 10进制-\u0026gt;2进制： 除2法取余数 2进制-\u0026gt;10进制： 从右到左依次乘从$2^0$开始到$2^n$的和\n位运算 与 \u0026amp; 或 | 取反 ~ 异或 ^ 左右移 \u0026laquo;\u0026lt; \u0026raquo;\u0026gt; 1 2 3 4 5 6 int a=4; //二进制右移1位即除以2，左一乘以2 //同理，十进制则1位乘除10，注意c中左右移符号是二进制的移动 if (a\u0026gt;\u0026gt;1==a/2){ printf(\u0026#34;True\u0026#34;); } 常见性质(略) 二进制算法 二进制枚举 快速幂 基础结构 分支结构 1 2 3 4 5 6 7 8 9 10 11 12 13 //分支 if (){ } else if (){ } else{ } //三元 a==0?printf(\u0026#34;a=0\u0026#34;):printf(\u0026#34;a!=0\u0026#34;); !!!注意\n如果switch没有break则会继续执行（会触发default或者其它case）\nexpression必须是常量表达式，必须是一个整型或枚举类型\n1 2 3 4 5 6 7 8 9 10 11 12 switch(expression){ case constant-expression : statement(s); break; /* 可选的 */ case constant-expression : statement(s); break; /* 可选的 */ /* 您可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s); } 循环结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int a=10; while(1){ a--; if (a\u0026gt;5){ continue; } printf(\u0026#34;NO\u0026#34;) if (a\u0026lt;4) break; } for(a=10;a\u0026lt;3;a--){ printf(\u0026#34;%d,a\u0026#34;); } do{ printf(\u0026#34;%d\u0026#34;,a); a-=1 }while(a); 省略 如果只跟一个句子，可以省略大括号 单数字作为条件时0假其它真 如下面的句子是合法的\n1 2 3 4 5 6 7 8 9 10 for(int i=0;i\u0026lt;10;i++) for(int j=i;j\u0026lt;10;j++) printf(\u0026#34;%d\u0026#34;,j); if(a==0) printf(\u0026#34;YES!!!\u0026#34;); int a=0; if(!a){ printf(\u0026#34;a is zero\u0026#34;); } 数组与字符串 一维数组 声明格式 type arrayName [ arraySize ]; 1 int a[50]; 初始化(大括号) 1 2 3 4 5 6 7 8 9 //标准初始化 int a[2]={1,2}; //可以只初始化少初始化，但不能多初始化 //即大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目 int a[10]={1,4,3,5}; //如果没有指定数组大小，则其等于初始化个数 int a[]={1,2,4}; 两种访问 下标（索引）从0开始 指针访问（数组名指向数组第一个元素的地址，数组储存连续） 详见指针 高维数组 声明与初始化\n(要记得大小从1开始，但索引从0开始) 1 2 3 4 5 // int a[2][2][2]; // // int a[2][3]={1,2,3,2,4,6} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 - 两种访问 - 下标（索引）从0开始 - 指针访问 - 列指针与行指针 - 单指针（利用连续性） [详见指针](#指针) ### 字符串 \u0026gt;everal ways to initialize a string **一定**以 ***\u0026#39;\\0\u0026#39;*** 结尾 + char str[20] = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\0\u0026#39;}; + char str[20] = \u0026#34;Hello\u0026#34;; // \u0026#39;\\0\u0026#39; is automatically set to str[5] + char str[] = \u0026#34;Hello\u0026#34;; //str\u0026#39;s size is 6 如果已经声明，就不能进行**初始化** #### 易错练习 是否正确？ ```c //注意字符和字符串的引号 //注意隐式转换 char a[]={\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,0} 字符串相关 \u0026lt;stdio.h\u0026gt; printf() %s\nsprintf() 1 2 3 4 5 6 7 8 int sprintf( char *str, const char *format, ... ); char buffer[50]; int n, a = 5, b = 3; n = sprintf(buffer, \u0026#34;%d plus %d is %d\u0026#34;, a, b, a+b); // n 实际长度13 //buffer=\u0026#34;5 plus 3 is 8\u0026#34; puts() puts stops printing when it meets \u0026lsquo;\\0\u0026rsquo;.\nscanf() %s 读到空格停止 %ns 读到空格/读n个字符停止 gets() 读一整行，字符数组开小了可能越界\nfgets() fgets(your_line, sizeof(your_line), stdin)\n利用sizeof ，防止越界\n字符串相关 \u0026lt;string.h\u0026gt; strlen() length of str, not including \u0026lsquo;\\0\u0026rsquo;;\nstrcpy(destination,source) 字符串赋值要strcpy，别直接等于号赋值\ncopy string from source to destination(包括\u0026rsquo;\\0\u0026rsquo;)\n小心越界\nstrncpy(destination, source, n) 复制前n个字符，最后自动加上\u0026rsquo;\\0\u0026rsquo;\nstrcmp(str1, str2) 逐位比较ascii，直到某一位ascii不一样，str1\u0026gt;str2 返回 1，相等返回0，其余-1\nstrncmp(str1, str2, n) 前n个\nstrcat(destination, source); 连接，加在dest上，小心越界\n字符串相关 \u0026lt;stdlib.h\u0026gt; atoi(str) str-\u0026gt;int\n支持正负号\n取前面可以转换的，到非数字字符停止(无视空格) ex. atoi(\u0026quot;-10aaa\u0026quot;)=-10\natof(str) • Same as atoi\n• Space, +, - are acceptable\n• An E or e (exponent) is acceptable\n• A decimal point is acceptable\n相关算法（仅作了解） BF，BK，KMP，BM 前缀树 后缀树 AC自动机 其它 基础语法 函数 函数的声明 如果函数放于main函数后面/多文件，需要提前声明 声明时参数的名称并不重要，只有参数的类型是必需的，因此以下都是都是有效声明 1 2 int max(int, int); int max(int a, int b); void 无返回值 返回多个值 利用指针 形式参数 详见作用域 传递数组 传一个指针 传不定长数组(ex. int a[],如果二维需要指定第二维度，int a[][3]) 传定长数组(int a[20]) #define函数 1 2 #define MAX(a,b) a\u0026gt;b?a:b #define SQ(x) x*x 作用域 3 types 在函数或块内部的局部变量,在所有函数外部的全局变量,在形式参数的函数参数定义中\nsmall has big 小可以改大的，大不能改小的\n形参同名替代（小带大） 但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用\n递归 懂得都懂 ——佚名 自顶向下,利用系统栈\n经典题 斐波那契 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int Fibonacci(int n){ if (n\u0026lt;=2){ return 1; } return Fibonacci(n-1)+Fibonacci(n-2); } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;%d\u0026#34;,Fibonacci(n)); return 0; } 命令行参数 1 2 3 int main(int argc, char *argv[] ){ return 0; } argc 存放命令行参数的个数 *argv[] 从argv[1]开始存放每一个参数的指针，第一个即argv[0]存放程序名 多文件 构成 宏文件（xxx.h） 文件存放声明\nxxx.c 文件存放函数\n主函数里 #include\u0026quot;xxx.h\u0026quot;\n进阶语法 指针 结构体 结构体定义与初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 //一个完整结构体的example struct tag1{ int a; char b[30]; }variable1={1,\u0026#34;ssss\u0026#34;}; struct tag1 variable2; typedef struct{ float f; }tag2; tag2 variable3; ！！！注意！！！\n无论如何struct结尾必须有分号 typedef格式固定，下面不是变量而是标签 如果变量已经声明，就不能进行初始化 1 2 3 4 5 6 7 8 9 10 11 //无typedef时下面一定是变量（无标签） struct { int a; }VARIABLE; //下面一定是tag //tag 不能放上面 //实质 typedef struct{int a;} TAG; //类同 typedef unsigned char UC; typedef struct{ int a; }TAG; 结构体内部元素赋值 1 2 3 4 5 6 7 8 9 struct day{ char feeling[100]; int time; }today; today.time=222; strcpy(today.feeling,\u0026#34;dddd\u0026#34;); struct day yesterday={\u0026#34;good\u0026#34;,221}; 结构体指针 接着上文定义的结构体\n1 2 3 struct day *check; check=\u0026amp;today printf(\u0026#34;%s\u0026#34;,check-\u0026gt;feeling); 结构体数组 接着上文定义的结构体\n1 2 3 4 5 6 struct day holiday[60]; int i; for(i=0;i\u0026lt;60;i++){ strcpy(holiday[i].feeling,happy); holiday[i].time=i; } 枚举类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 enum week { MON=1, TUE, WED, THU, FRI, SAT, SUN }day; day=MON; printf(\u0026#34;%d\u0026#34;,day); //若不初始化MON，默认第一个是 0 //注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。 //如果我们把第3个枚举成员的值定义为 9，第4个就为 10，以此类推，第2个依然为1。 //可以和整形强制转化 int a=1; days=(enum week)a; //days=MON 动态内存 入门级基础算法 数学 求质数 了解朴素质数判定即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 朴素质数判定 /* 已经声明过 #define true 1 #define false 0 */ int check(int a){ if (a\u0026lt;2){ return false; } int i; for(i=2;i*i\u0026lt;a;i++){ if (a%i==0){ return false; } } return true; } 最大公约数\n了解欧几里得算法即可\n1 2 3 4 int gcd(int a,int b){ if (b==0) return a; return gcd(b, a % b); } 最小公倍数\n$lcm(a,b)gcd(a,b)=ab$\n先求出gcd即可\n高精度（了解加法减法即可）\n排序 稳定排序 不稳定排序 计数排序 桶排序 qsort() 双指针 同向 逆向 滑窗 ","date":"2023-04-26T00:00:00Z","image":"https://open17.github.io/CpHugo/p/cstart/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://open17.github.io/CpHugo/p/cstart/","title":"C语言快速入门"},{"content":"c++ 精简模板 1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { ios cout \u0026lt;\u0026lt; \u0026#34;Hello, ACM.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 完全模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #define _USE_MATH_DEFINES // C #include \u0026lt;cassert\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;ctime\u0026gt; //io #include \u0026lt;iostream\u0026gt; //基本输入输出流 #include \u0026lt;iomanip\u0026gt; #include \u0026lt;sstream\u0026gt; //基于字符串的流 //标准异常类 #include \u0026lt;stdexcept\u0026gt; //algorithm #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;functional\u0026gt; //定义运算函数（代替运算符） #include \u0026lt;complex\u0026gt; //复数类 #include \u0026lt;random\u0026gt; //STL #include \u0026lt;string\u0026gt; //字符串类 #include \u0026lt;list\u0026gt; //线性列表容器 #include \u0026lt;vector\u0026gt; //动态数组容器 #include \u0026lt;stack\u0026gt; //堆栈容器 #include \u0026lt;queue\u0026gt; //队列容器 #include \u0026lt;deque\u0026gt; //双端队列容器 #include \u0026lt;bitset\u0026gt; //比特集合 #include \u0026lt;set\u0026gt; //集合容器 #include \u0026lt;map\u0026gt; //映射容器 #include \u0026lt;unordered_set\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; //fast ios #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define ALL(a) (a).begin(),(a).end() #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define RFOR(w, a, n) for(int w=(n)-1;w\u0026gt;=(a);--w) #define REP(w, n) for(int w=0;w\u0026lt;int(n);++w) #define RREP(w, n) for(int w=int(n)-1;w\u0026gt;=0;--w) #define IN(a, x, b) (a\u0026lt;=x \u0026amp;\u0026amp; x\u0026lt;b) #define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) template \u0026lt;typename Arg1\u0026gt; void __f(const char* name, Arg1\u0026amp;\u0026amp; arg1){ cerr \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; endl; } template \u0026lt;typename Arg1, typename... Args\u0026gt; void __f(const char* names, Arg1\u0026amp;\u0026amp; arg1, Args\u0026amp;\u0026amp;... args){ const char* comma = strchr(names + 1, \u0026#39;,\u0026#39;); cerr.write(names, comma - names) \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; \u0026#34; |\u0026#34;; __f(comma + 1, args...); } typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const double PI = acos(-1.0); const double eps = 1e-6; const int INF = 1 \u0026lt;\u0026lt; 29; const int MOD = 1e9 + 7; const int MAXN = 100; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, ACM.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys import heapq import random from math import ceil,floor,fmod,gcd,sqrt,inf from bisect import bisect_left from collections import defaultdict,Counter,deque,OrderedDict from functools import lru_cache,cmp_to_key #sys.setrecursionlimit(1000000) # 输入1 def ii(): return int(sys.stdin.readline().strip()) # 输入2 def iin(): return map(int,sys.stdin.readline().split()) def inn(): return sys.stdin.readline().strip() java go ","date":"2023-04-26T00:00:00Z","image":"https://open17.github.io/CpHugo/p/template/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://open17.github.io/CpHugo/p/template/","title":"算法输入输出模板"},{"content":"位运算 a的b次方对p取模 前置知识\n[qpow] [math]:(a+b)%p=(a%p+b%p)%p 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 求 a的 b次方对 p取模的值。 // 输入格式 // 三个整数 a,b,p，在同一行用空格隔开。 // 输出格式 // 输出一个整数，表示a^b mod p的值。 // 数据范围 // 0≤a,b≤109 // 1≤p≤109 // 输入样例： // 3 2 7 // 输出样例： // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; // 防止当b=0，p=1时被卡 res=1%p; while(b){ if(b\u0026amp;1)res=(res*a)%p; a*=a; a%=p; b\u0026gt;\u0026gt;=1; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } a*b对p取模 前置知识\n[qpow] [math]:(a+b)%p=(a%p+b%p)%p 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 求 a // 乘 b // 对 p // 取模的值。 // 输入格式 // 第一行输入整数a // ，第二行输入整数b // ，第三行输入整数p // 。 // 输出格式 // 输出一个整数，表示a*b mod p的值。 // 数据范围 // 1≤a,b,p≤1018 // 输入样例： // 3 // 4 // 5 // 输出样例： // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res=0; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; while(b){ if(b\u0026amp;1)res=(res+a)%p; b\u0026gt;\u0026gt;=1; a*=2; a%=p; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } 最短Hamilton路径 前置知识\n[位运算] [状压DP] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // 给定一张 n个点的带权无向图，点从 0∼n−1标号，求起点 0到终点 n−1的最短 Hamilton 路径。 // Hamilton 路径的定义是从 0到 n−1不重不漏地经过每个点恰好一次。输入格式 // 第一行输入整数 n。 // 接下来 n行每行 n个整数，其中第 i行第 j个整数表示点 i到 j的距离（记为 a[i,j]）。 // 对于任意的 x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x]并且 a[x,y]+a[y,z]≥a[x,z]。 // 输出格式 // 输出一个整数，表示最短 Hamilton 路径的长度。 // 数据范围 // 1≤n≤20 // 0≤a[i,j]≤107 // 输入样例： // 5 // 0 2 4 5 1 // 2 0 6 5 3 // 4 6 0 8 3 // 5 5 8 0 5 // 1 3 3 5 0 // 输出样例： // 18 #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) #define inf 0x3f const int N=20,M=1\u0026lt;\u0026lt;20; int n; //大数组开到全局里，防止爆栈 //f[i][j]: i:经过状态，j:j点最短路 int f[M][N],w[N][N]; int main(){ cin\u0026gt;\u0026gt;n; For(i,0,n){ For(j,0,n){ cin\u0026gt;\u0026gt;w[i][j]; } } memset(f,inf,sizeof(f)); f[1][0]=0; For(i,0,1\u0026lt;\u0026lt;n){ For(j,0,n){ if(i\u0026gt;\u0026gt;j\u0026amp;1){ //int p=i^(1\u0026lt;\u0026lt;j) int p=i-(1\u0026lt;\u0026lt;j); For(k,0,n){ if(p\u0026amp;(1\u0026lt;\u0026lt;k)) // if(p\u0026gt;\u0026gt;k\u0026amp;1) f[i][j]=min(f[i][j],f[p][k]+w[k][j]); } } } } cout\u0026lt;\u0026lt;f[(1\u0026lt;\u0026lt;n)-1][n-1]\u0026lt;\u0026lt;endl; return 0; } 起床困难综合症 前置知识\n[位运算性质] :与或非运算在二进制表示下不进位，也就是说每个bit之间独立位运算 [贪心] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 // 21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。 // 作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。 // 通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 // 正是由于 drd 的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。 // 为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。 // 历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。 // drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。 // 具体说来，drd 的防御战线由 n扇防御门组成。 // 每扇防御门包括一个运算 op // 和一个参数 t ，其中运算一定是 OR,XOR,AND中的一种，参数则一定为非负整数。 // 如果还未通过防御门时攻击力为 x // 则其通过这扇防御门后攻击力将变为 x op t // 最终 drd 受到的伤害为对方初始攻击力 x // 依次经过所有 n扇防御门后转变得到的攻击力。 // 由于 atm 水平有限，他的初始攻击力只能为 0 // 到 m之间的一个整数（即他的初始攻击力只能在 0,1,…,m中任选， // 但在通过防御门之后的攻击力不受 m的限制）。 // 为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。 // 输入格式 // 第 1行包含 2个整数，依次为 n,m，表示 drd 有 n扇防御门，atm 的初始攻击力为 0到 m之间的整数。 // 接下来 n 行，依次表示每一扇防御门。每行包括一个字符串 op 和一个非负整数 t ，两者由一个空格隔开，且 op 在前，t 在后，op 表示该防御门所对应的操作，t 表示对应的参数。 // 输出格式 // 输出一个整数，表示 atm 的一次攻击最多使 drd 受到多少伤害。 // 数据范围 // QQ截图20190907125839.png // 输入样例： // 3 10 // AND 5 // OR 6 // XOR 7 // 输出样例： // 1 // 样例解释 // atm可以选择的初始攻击力为 0,1,…,10 // 假设初始攻击力为 4，最终攻击力经过了如下计算 // 4 AND 5 = 4 // 4 OR 6 = 6 // 6 XOR 7 = 1 //类似的，我们可以计算出初始攻击力为 1,3,5,7,9 时最终攻击力为 0 ，初始攻击力为 0,2,4,6,8,10 时最终攻击力为 1 ，因此 atm 的一次攻击最多使 drd 受到的伤害值为 1 。 // 运算解释 // 在本题中，选手需要先将数字变换为二进制后再进行计算。如果操作的两个数二进制长度不同，则在前补 0 // 至相同长度。 // OR 为按位或运算，处理两个长度相同的二进制数，两个相应的二进制位中只要有一个为 1，则该位的结果值为 1，否则为 0。 // XOR 为按位异或运算，对等长二进制模式或二进制数的每一位执行逻辑异或操作。如果两个相应的二进制位不同（相异），则该位的结果值为 1，否则该位为 0 // AND 为按位与运算，处理两个长度相同的二进制数，两个相应的二进制位都为 1，该位的结果值才为 1，否则为 0 // 例如，我们将十进制数 5与十进制数 3 // 分别进行 OR、XOR与 AND运算，可以得到如下结果： // 0101 (十进制 5) 0101 (十进制 5) 0101 (十进制 5) // OR 0011 (十进制 3) XOR 0011 (十进制 3) AND 0011 (十进制 3) // = 0111 (十进制 7) = 0110 (十进制 6) = 0001 (十进制 1) #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) const int N=1e6; vector\u0026lt;pair\u0026lt;string,int\u0026gt;\u0026gt; a(N); string op; int t; int n,m; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int change(int p,int q){ For(i,0,n){ int x=a[i].second\u0026gt;\u0026gt;p\u0026amp;1; if(a[i].first==\u0026#34;AND\u0026#34;)q\u0026amp;=x; else if(a[i].first==\u0026#34;OR\u0026#34;)q|=x; else {q^=x;} } return q; } int main(){ ios cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; For(i,0,n){ cin\u0026gt;\u0026gt;a[i].first; cin\u0026gt;\u0026gt;a[i].second; } int pre=0,aft=0; For(i,0,30){ int p=29-i; int pos1=change(p,0); int pos2=change(p,1); if(pre+(1\u0026lt;\u0026lt;p)\u0026lt;=m \u0026amp;\u0026amp; pos2\u0026gt;pos1){ pre+=1\u0026lt;\u0026lt;p; aft+=pos2\u0026lt;\u0026lt;p; } else aft+=pos1\u0026lt;\u0026lt;p; } cout\u0026lt;\u0026lt;aft\u0026lt;\u0026lt;endl; } XOR成对变换 1 2 3 4 if n\u0026amp;1: n^1==n-1 else: n^1==n+1 lowbit n\u0026amp;(-n)\n飞行员兄弟 前置知识\n[贪心] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 “飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有 16个把手的冰箱。 已知每个把手可以处于以下两种状态之一：打开或关闭。 只有当所有把手都打开时，冰箱才会打开。 把手可以表示为一个 4×4的矩阵，您可以改变任何一个位置 [i,j]上把手的状态。 但是，这也会使得第 i行和第 j列上的所有把手的状态也随着改变。 请你求出打开冰箱所需的切换把手的次数最小值是多少。 输入格式 输入一共包含四行，每行包含四个把手的初始状态。 符号 + 表示把手处于闭合状态，而符号 - 表示把手处于打开状态。 至少一个手柄的初始状态是关闭的。 输出格式 第一行输出一个整数 N，表示所需的最小切换把手次数。 接下来 N行描述切换顺序，每行输出两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。 注意：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。 数据范围 1≤i,j≤4 输入样例： -+-- ---- ---- -+-- 输出样例： 6 1 1 1 3 1 4 4 1 4 3 4 4 费解的开关 前置知识\n[贪心] 分而治之 前缀和与差分 二分 排序 倍增 贪心 ","date":"2023-04-26T00:00:00Z","image":"https://open17.github.io/CpHugo/p/blue00/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://open17.github.io/CpHugo/p/blue00/","title":"小蓝书0X00总结"}]