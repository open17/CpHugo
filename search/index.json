[{"content":"c++ å¿«è¯»æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } ç²¾ç®€æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6; int main() { ios cout \u0026lt;\u0026lt; \u0026#34;Hello, ACM.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } å®Œå…¨æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #define _USE_MATH_DEFINES // C #include \u0026lt;cassert\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;ctime\u0026gt; //io #include \u0026lt;iostream\u0026gt; //åŸºæœ¬è¾“å…¥è¾“å‡ºæµ #include \u0026lt;iomanip\u0026gt; #include \u0026lt;sstream\u0026gt; //åŸºäºå­—ç¬¦ä¸²çš„æµ //æ ‡å‡†å¼‚å¸¸ç±» #include \u0026lt;stdexcept\u0026gt; //algorithm #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;functional\u0026gt; //å®šä¹‰è¿ç®—å‡½æ•°ï¼ˆä»£æ›¿è¿ç®—ç¬¦ï¼‰ #include \u0026lt;complex\u0026gt; //å¤æ•°ç±» #include \u0026lt;random\u0026gt; //STL #include \u0026lt;string\u0026gt; //å­—ç¬¦ä¸²ç±» #include \u0026lt;list\u0026gt; //çº¿æ€§åˆ—è¡¨å®¹å™¨ #include \u0026lt;vector\u0026gt; //åŠ¨æ€æ•°ç»„å®¹å™¨ #include \u0026lt;stack\u0026gt; //å †æ ˆå®¹å™¨ #include \u0026lt;queue\u0026gt; //é˜Ÿåˆ—å®¹å™¨ #include \u0026lt;deque\u0026gt; //åŒç«¯é˜Ÿåˆ—å®¹å™¨ #include \u0026lt;bitset\u0026gt; //æ¯”ç‰¹é›†åˆ #include \u0026lt;set\u0026gt; //é›†åˆå®¹å™¨ #include \u0026lt;map\u0026gt; //æ˜ å°„å®¹å™¨ #include \u0026lt;unordered_set\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; //fast ios #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define ALL(a) (a).begin(),(a).end() #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define RFOR(w, a, n) for(int w=(n)-1;w\u0026gt;=(a);--w) #define REP(w, n) for(int w=0;w\u0026lt;int(n);++w) #define RREP(w, n) for(int w=int(n)-1;w\u0026gt;=0;--w) #define IN(a, x, b) (a\u0026lt;=x \u0026amp;\u0026amp; x\u0026lt;b) #define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) template \u0026lt;typename Arg1\u0026gt; void __f(const char* name, Arg1\u0026amp;\u0026amp; arg1){ cerr \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; endl; } template \u0026lt;typename Arg1, typename... Args\u0026gt; void __f(const char* names, Arg1\u0026amp;\u0026amp; arg1, Args\u0026amp;\u0026amp;... args){ const char* comma = strchr(names + 1, \u0026#39;,\u0026#39;); cerr.write(names, comma - names) \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; \u0026#34; |\u0026#34;; __f(comma + 1, args...); } typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const double PI = acos(-1.0); const double eps = 1e-6; const int INF = 1 \u0026lt;\u0026lt; 29; const int MOD = 1e9 + 7; const int MAXN = 100; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, ACM.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys import heapq import random from math import ceil,floor,fmod,gcd,sqrt,inf from bisect import bisect_left from collections import defaultdict,Counter,deque,OrderedDict from functools import lru_cache,cmp_to_key #sys.setrecursionlimit(1000000) # è¾“å…¥1 def ii(): return int(sys.stdin.readline().strip()) # è¾“å…¥2 def iin(): return map(int,sys.stdin.readline().split()) def inn(): return sys.stdin.readline().strip() java go ","date":"2023-05-08T00:03:00Z","image":"https://open17.github.io/CpHugo/p/template/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://open17.github.io/CpHugo/p/template/","title":"ç®—æ³•è¾“å…¥è¾“å‡ºæ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 vector\u0026lt;int\u0026gt; get_prefix_table(string pattern) { int n = pattern.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = pi[j-1]; } if (pattern[i] == pattern[j]) { j++; } pi[i] = j; } return pi; } vector\u0026lt;int\u0026gt; kmp(string text, string pattern) { vector\u0026lt;int\u0026gt; pi = get_prefix_table(pattern); vector\u0026lt;int\u0026gt; matches; for (int i = 0, j = 0; i \u0026lt; text.length(); i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; text[i] != pattern[j]) { j = pi[j-1]; } if (text[i] == pattern[j]) { j++; } if (j == pattern.length()) { matches.push_back(i - j + 1); j = pi[j-1]; } } return matches; } ã€æ¨¡æ¿ã€‘KMPå­—ç¬¦ä¸²åŒ¹é… é¢˜ç›®æè¿° ç»™å‡ºä¸¤ä¸ªå­—ç¬¦ä¸² $s_1$ å’Œ $s_2$ï¼Œè‹¥ $s_1$ çš„åŒºé—´ $[l, r]$ å­ä¸²ä¸ $s_2$ å®Œå…¨ç›¸åŒï¼Œåˆ™ç§° $s_2$ åœ¨ $s_1$ ä¸­å‡ºç°äº†ï¼Œå…¶å‡ºç°ä½ç½®ä¸º $l$ã€‚\nç°åœ¨è¯·ä½ æ±‚å‡º $s_2$ åœ¨ $s_1$ ä¸­æ‰€æœ‰å‡ºç°çš„ä½ç½®ã€‚\nå®šä¹‰ä¸€ä¸ªå­—ç¬¦ä¸² $s$ çš„ border ä¸º $s$ çš„ä¸€ä¸ªé $s$ æœ¬èº«çš„å­ä¸² $t$ï¼Œæ»¡è¶³ $t$ æ—¢æ˜¯ $s$ çš„å‰ç¼€ï¼Œåˆæ˜¯ $s$ çš„åç¼€ã€‚\nå¯¹äº $s_2$ï¼Œä½ è¿˜éœ€è¦æ±‚å‡ºå¯¹äºå…¶æ¯ä¸ªå‰ç¼€ $s\u0026rsquo;$ çš„æœ€é•¿ border $t\u0026rsquo;$ çš„é•¿åº¦ã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œä¸ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå³ä¸º $s_1$ã€‚\nç¬¬äºŒè¡Œä¸ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå³ä¸º $s_2$ã€‚\nè¾“å‡ºæ ¼å¼ é¦–å…ˆè¾“å‡ºè‹¥å¹²è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°ï¼ŒæŒ‰ä»å°åˆ°å¤§çš„é¡ºåºè¾“å‡º $s_2$ åœ¨ $s_1$ ä¸­å‡ºç°çš„ä½ç½®ã€‚\næœ€åä¸€è¡Œè¾“å‡º $|s_2|$ ä¸ªæ•´æ•°ï¼Œç¬¬ $i$ ä¸ªæ•´æ•°è¡¨ç¤º $s_2$ çš„é•¿åº¦ä¸º $i$ çš„å‰ç¼€çš„æœ€é•¿ border é•¿åº¦ã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 ABABABC ABA æ ·ä¾‹è¾“å‡º #1 1 2 3 1 3 0 0 1 æç¤º æ ·ä¾‹ 1 è§£é‡Š ã€‚\nå¯¹äº $s_2$ é•¿åº¦ä¸º $3$ çš„å‰ç¼€ ABAï¼Œå­—ç¬¦ä¸² A æ—¢æ˜¯å…¶åç¼€ä¹Ÿæ˜¯å…¶å‰ç¼€ï¼Œä¸”æ˜¯æœ€é•¿çš„ï¼Œå› æ­¤æœ€é•¿ border é•¿åº¦ä¸º $1$ã€‚\næ•°æ®è§„æ¨¡ä¸çº¦å®š æœ¬é¢˜é‡‡ç”¨å¤šæµ‹è¯•ç‚¹æ†ç»‘æµ‹è¯•ï¼Œå…±æœ‰ 3 ä¸ªå­ä»»åŠ¡ã€‚\nSubtask 1ï¼ˆ30 pointsï¼‰ï¼š$|s_1| \\leq 15$ï¼Œ$|s_2| \\leq 5$ã€‚ Subtask 2ï¼ˆ40 pointsï¼‰ï¼š$|s_1| \\leq 10^4$ï¼Œ$|s_2| \\leq 10^2$ã€‚ Subtask 3ï¼ˆ30 pointsï¼‰ï¼šæ— ç‰¹æ®Šçº¦å®šã€‚ å¯¹äºå…¨éƒ¨çš„æµ‹è¯•ç‚¹ï¼Œä¿è¯ $1 \\leq |s_1|,|s_2| \\leq 10^6$ï¼Œ$s_1, s_2$ ä¸­å‡åªå«å¤§å†™è‹±æ–‡å­—æ¯ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; get_prefix_table(string pattern) { int n = pattern.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = pi[j-1]; } if (pattern[i] == pattern[j]) { j++; } pi[i] = j; } return pi; } vector\u0026lt;int\u0026gt; kmp(string text, string pattern) { vector\u0026lt;int\u0026gt; pi = get_prefix_table(pattern); vector\u0026lt;int\u0026gt; matches; for (int i = 0, j = 0; i \u0026lt; text.length(); i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; text[i] != pattern[j]) { j = pi[j-1]; } if (text[i] == pattern[j]) { j++; } if (j == pattern.length()) { matches.push_back(i - j + 1); j = pi[j-1]; } } return matches; } int main() { string s1, s2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; // ä½¿ç”¨ KMP ç®—æ³•æŸ¥æ‰¾æ‰€æœ‰å‡ºç°ä½ç½® vector\u0026lt;int\u0026gt; matches = kmp(s1, s2); // è¾“å‡ºå‡ºç°ä½ç½® for (int i = 0; i \u0026lt; matches.size(); i++) { cout \u0026lt;\u0026lt; matches[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // è®¡ç®— s2 çš„å‰ç¼€çš„æœ€é•¿ border é•¿åº¦ vector\u0026lt;int\u0026gt; pi = get_prefix_table(s2); for (int i = 0; i \u0026lt; s2.length(); i++) { cout \u0026lt;\u0026lt; pi[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/kmp/","title":"KMPæ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const int MAXN = 1e5 + 5; // æœ€å¤§æ•°ç»„é•¿åº¦ const int MAXK = 25; // log2(MAXN) å‘ä¸Šå–æ•´ int a[MAXN]; // è¾“å…¥æ•°ç»„ int st[MAXN][MAXK + 1]; // STè¡¨ int Log2[MAXN]; void build(int n) { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; // åˆå§‹åŒ–ç¬¬ä¸€åˆ— } for (int j = 1; j \u0026lt;= MAXK; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = min(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); // æ›´æ–°STè¡¨ } } for (int i = 2; i \u0026lt;= n; ++i) Log2[i] = Log2[i / 2] + 1; } int query(int l, int r) { int k = Log2[r - l + 1]; // è®¡ç®—åŒºé—´é•¿åº¦çš„å¯¹æ•°ï¼Œå‘ä¸‹å–æ•´ return min(st[l][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); // è¿”å›åŒºé—´æœ€å°å€¼ } ã€æ¨¡æ¿ã€‘ST è¡¨ é¢˜ç›®èƒŒæ™¯ è¿™æ˜¯ä¸€é“ ST è¡¨ç»å…¸é¢˜â€”â€”é™æ€åŒºé—´æœ€å¤§å€¼\nè¯·æ³¨æ„æœ€å¤§æ•°æ®æ—¶é™åªæœ‰ 0.8sï¼Œæ•°æ®å¼ºåº¦ä¸ä½ï¼Œè¯·åŠ¡å¿…ä¿è¯ä½ çš„æ¯æ¬¡æŸ¥è¯¢å¤æ‚åº¦ä¸º $O(1)$ã€‚è‹¥ä½¿ç”¨æ›´é«˜æ—¶é—´å¤æ‚åº¦ç®—æ³•ä¸ä¿è¯èƒ½é€šè¿‡ã€‚\nå¦‚æœæ‚¨è®¤ä¸ºæ‚¨çš„ä»£ç æ—¶é—´å¤æ‚åº¦æ­£ç¡®ä½†æ˜¯ TLEï¼Œå¯ä»¥å°è¯•ä½¿ç”¨å¿«é€Ÿè¯»å…¥ï¼š\n1 2 3 4 5 6 7 inline int read() { int x=0,f=1;char ch=getchar(); while (ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if (ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while (ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-48;ch=getchar();} return x*f; } å‡½æ•°è¿”å›å€¼ä¸ºè¯»å…¥çš„ç¬¬ä¸€ä¸ªæ•´æ•°ã€‚\nå¿«é€Ÿè¯»å…¥ä½œç”¨ä»…ä¸ºåŠ å¿«è¯»å…¥ï¼Œå¹¶éå¼ºåˆ¶ä½¿ç”¨ã€‚\né¢˜ç›®æè¿° ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º $N$ çš„æ•°åˆ—ï¼Œå’Œ $ M $ æ¬¡è¯¢é—®ï¼Œæ±‚å‡ºæ¯ä¸€æ¬¡è¯¢é—®çš„åŒºé—´å†…æ•°å­—çš„æœ€å¤§å€¼ã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° $N,M$ï¼Œåˆ†åˆ«è¡¨ç¤ºæ•°åˆ—çš„é•¿åº¦å’Œè¯¢é—®çš„ä¸ªæ•°ã€‚\nç¬¬äºŒè¡ŒåŒ…å« $N$ ä¸ªæ•´æ•°ï¼ˆè®°ä¸º $a_i$ï¼‰ï¼Œä¾æ¬¡è¡¨ç¤ºæ•°åˆ—çš„ç¬¬ $i$ é¡¹ã€‚\næ¥ä¸‹æ¥ $M$ è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° $l_i,r_i$ï¼Œè¡¨ç¤ºæŸ¥è¯¢çš„åŒºé—´ä¸º $[l_i,r_i]$ã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡ºåŒ…å« $M$ è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ•´æ•°ï¼Œä¾æ¬¡è¡¨ç¤ºæ¯ä¸€æ¬¡è¯¢é—®çš„ç»“æœã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 7 8 9 10 8 8 9 3 1 7 5 6 0 8 1 6 1 5 2 7 2 6 1 8 4 8 3 7 1 8 æ ·ä¾‹è¾“å‡º #1 1 2 3 4 5 6 7 8 9 9 7 7 9 8 7 9 æç¤º å¯¹äº $30%$ çš„æ•°æ®ï¼Œæ»¡è¶³ $1\\le N,M\\le 10$ã€‚\nå¯¹äº $70%$ çš„æ•°æ®ï¼Œæ»¡è¶³ $1\\le N,M\\le {10}^5$ã€‚\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œæ»¡è¶³ $1\\le N\\le {10}^5$ï¼Œ$1\\le M\\le 2\\times{10}^6$ï¼Œ$a_i\\in[0,{10}^9]$ï¼Œ$1\\le l_i\\le r_i\\le N$ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAXN = 1e5 + 5; // æœ€å¤§æ•°ç»„é•¿åº¦ const int MAXK = 25; // log2(MAXN) å‘ä¸Šå–æ•´ int a[MAXN]; // è¾“å…¥æ•°ç»„ int st[MAXN][MAXK + 1]; // STè¡¨ int Log2[MAXN]; void build(int n) { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; // åˆå§‹åŒ–ç¬¬ä¸€åˆ— } for (int j = 1; j \u0026lt;= MAXK; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = max(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); // æ›´æ–°STè¡¨ } } for (int i = 2; i \u0026lt;= n; ++i) Log2[i] = Log2[i / 2] + 1; } int query(int l, int r) { int k = Log2[r - l + 1]; // è®¡ç®—åŒºé—´é•¿åº¦çš„å¯¹æ•°ï¼Œå‘ä¸‹å–æ•´ return max(st[l][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); // è¿”å›åŒºé—´æœ€å°å€¼ } inline int read() { int x=0,f=1;char ch=getchar(); while (ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if (ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while (ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-48;ch=getchar();} return x*f; } int main() { int n,m; n=read(); m=read(); for(int i=1;i\u0026lt;=n;i++){ a[i]=read(); } build(n); while(m--){ int l=read(),r=read(); printf(\u0026#34;%d\\n\u0026#34;,query(l,r)); } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/st/","title":"STè¡¨æ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œç”¨äºæ±‚æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦å’Œç¥–å…ˆä¿¡æ¯ void dfs(int u, int fa) { depth[u] = depth[fa] + 1; // å½“å‰èŠ‚ç‚¹çš„æ·±åº¦ä¸ºçˆ¶èŠ‚ç‚¹çš„æ·±åº¦åŠ ä¸€ p[u][0] = fa; // å½“å‰èŠ‚ç‚¹çš„ 2^0 çº§ç¥–å…ˆä¸ºçˆ¶èŠ‚ç‚¹ // é€’æ¨æ±‚å‡ºå½“å‰èŠ‚ç‚¹çš„ 2^i çº§ç¥–å…ˆ for (int i = 1; i \u0026lt; M; i ++ ) p[u][i] = p[p[u][i - 1]][i - 1]; // éå†å½“å‰èŠ‚ç‚¹çš„æ¯ä¸€ä¸ªå„¿å­ï¼Œé€’å½’è°ƒç”¨ dfs å‡½æ•° for (auto v : g[u]) if (v != fa) // é¿å…å‘çˆ¶èŠ‚ç‚¹é€’å½’ dfs(v, u); } // æ±‚ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ int lca(int a, int b) { if (depth[a] \u0026lt; depth[b]) swap(a, b); // ä¿è¯ a æ·±åº¦ä¸å°äº b // å…ˆå°† a è·³åˆ°å’Œ b åŒä¸€æ·±åº¦ for (int i = M - 1; i \u0026gt;= 0; i -- ) if (depth[p[a][i]] \u0026gt;= depth[b]) a = p[a][i]; if (a == b) return a; // ç‰¹åˆ¤ a å’Œ b åœ¨åŒä¸€æ¡é“¾ä¸Šçš„æƒ…å†µ // ä¸€èµ·å‘ä¸Šè·³ï¼Œç›´åˆ° a å’Œ b çš„ç¬¬ä¸€ä¸ªä¸åŒçš„ç¥–å…ˆ for (int i = M - 1; i \u0026gt;= 0; i -- ) if (p[a][i] != p[b][i]) { a = p[a][i]; b = p[b][i]; } return p[a][0]; // è¿”å› a çš„çˆ¶èŠ‚ç‚¹ï¼Œå³ä¸º LCA } ã€æ¨¡æ¿ã€‘æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆLCAï¼‰ é¢˜ç›®æè¿° å¦‚é¢˜ï¼Œç»™å®šä¸€æ£µæœ‰æ ¹å¤šå‰æ ‘ï¼Œè¯·æ±‚å‡ºæŒ‡å®šä¸¤ä¸ªç‚¹ç›´æ¥æœ€è¿‘çš„å…¬å…±ç¥–å…ˆã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«ä¸‰ä¸ªæ­£æ•´æ•° $N,M,S$ï¼Œåˆ†åˆ«è¡¨ç¤ºæ ‘çš„ç»“ç‚¹ä¸ªæ•°ã€è¯¢é—®çš„ä¸ªæ•°å’Œæ ‘æ ¹ç»“ç‚¹çš„åºå·ã€‚\næ¥ä¸‹æ¥ $N-1$ è¡Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•° $x, y$ï¼Œè¡¨ç¤º $x$ ç»“ç‚¹å’Œ $y$ ç»“ç‚¹ä¹‹é—´æœ‰ä¸€æ¡ç›´æ¥è¿æ¥çš„è¾¹ï¼ˆæ•°æ®ä¿è¯å¯ä»¥æ„æˆæ ‘ï¼‰ã€‚\næ¥ä¸‹æ¥ $M$ è¡Œæ¯è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•° $a, b$ï¼Œè¡¨ç¤ºè¯¢é—® $a$ ç»“ç‚¹å’Œ $b$ ç»“ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡ºåŒ…å« $M$ è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªæ­£æ•´æ•°ï¼Œä¾æ¬¡ä¸ºæ¯ä¸€ä¸ªè¯¢é—®çš„ç»“æœã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 7 8 9 10 5 5 4 3 1 2 4 5 1 1 4 2 4 3 2 3 5 1 2 4 5 æ ·ä¾‹è¾“å‡º #1 1 2 3 4 5 4 4 1 4 4 æç¤º å¯¹äº $30%$ çš„æ•°æ®ï¼Œ$N\\leq 10$ï¼Œ$M\\leq 10$ã€‚\nå¯¹äº $70%$ çš„æ•°æ®ï¼Œ$N\\leq 10000$ï¼Œ$M\\leq 10000$ã€‚\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œ$1 \\leq N,M\\leq 500000$ï¼Œ$1 \\leq x, y,a ,b \\leq N$ï¼Œä¸ä¿è¯ $a \\neq b$ã€‚\næ ·ä¾‹è¯´æ˜ï¼š\nè¯¥æ ‘ç»“æ„å¦‚ä¸‹ï¼š\nç¬¬ä¸€æ¬¡è¯¢é—®ï¼š$2, 4$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œæ•…ä¸º $4$ã€‚\nç¬¬äºŒæ¬¡è¯¢é—®ï¼š$3, 2$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œæ•…ä¸º $4$ã€‚\nç¬¬ä¸‰æ¬¡è¯¢é—®ï¼š$3, 5$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œæ•…ä¸º $1$ã€‚\nç¬¬å››æ¬¡è¯¢é—®ï¼š$1, 2$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œæ•…ä¸º $4$ã€‚\nç¬¬äº”æ¬¡è¯¢é—®ï¼š$4, 5$ çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œæ•…ä¸º $4$ã€‚\næ•…è¾“å‡ºä¾æ¬¡ä¸º $4, 4, 1, 4, 4$ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N = 500010, M = 20; int n, m, s; // nï¼šèŠ‚ç‚¹æ•°ï¼Œmï¼šæŸ¥è¯¢æ¬¡æ•°ï¼Œsï¼šæ ¹èŠ‚ç‚¹ç¼–å· int depth[N], p[N][M]; // depthï¼šæ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦ï¼Œpï¼šæ¯ä¸ªèŠ‚ç‚¹çš„ 2^i çº§ç¥–å…ˆ vector\u0026lt;int\u0026gt; g[N]; // gï¼šæ ‘çš„é‚»æ¥è¡¨è¡¨ç¤º // æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œç”¨äºæ±‚æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦å’Œç¥–å…ˆä¿¡æ¯ void dfs(int u, int fa) { depth[u] = depth[fa] + 1; // å½“å‰èŠ‚ç‚¹çš„æ·±åº¦ä¸ºçˆ¶èŠ‚ç‚¹çš„æ·±åº¦åŠ ä¸€ p[u][0] = fa; // å½“å‰èŠ‚ç‚¹çš„ 2^0 çº§ç¥–å…ˆä¸ºçˆ¶èŠ‚ç‚¹ // é€’æ¨æ±‚å‡ºå½“å‰èŠ‚ç‚¹çš„ 2^i çº§ç¥–å…ˆ for (int i = 1; i \u0026lt; M; i ++ ) p[u][i] = p[p[u][i - 1]][i - 1]; // éå†å½“å‰èŠ‚ç‚¹çš„æ¯ä¸€ä¸ªå„¿å­ï¼Œé€’å½’è°ƒç”¨ dfs å‡½æ•° for (auto v : g[u]) if (v != fa) // é¿å…å‘çˆ¶èŠ‚ç‚¹é€’å½’ dfs(v, u); } // æ±‚ä¸¤ä¸ªèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ int lca(int a, int b) { if (depth[a] \u0026lt; depth[b]) swap(a, b); // ä¿è¯ a æ·±åº¦ä¸å°äº b // å…ˆå°† a è·³åˆ°å’Œ b åŒä¸€æ·±åº¦ for (int i = M - 1; i \u0026gt;= 0; i -- ) if (depth[p[a][i]] \u0026gt;= depth[b]) a = p[a][i]; if (a == b) return a; // ç‰¹åˆ¤ a å’Œ b åœ¨åŒä¸€æ¡é“¾ä¸Šçš„æƒ…å†µ // ä¸€èµ·å‘ä¸Šè·³ï¼Œç›´åˆ° a å’Œ b çš„ç¬¬ä¸€ä¸ªä¸åŒçš„ç¥–å…ˆ for (int i = M - 1; i \u0026gt;= 0; i -- ) if (p[a][i] != p[b][i]) { a = p[a][i]; b = p[b][i]; } return p[a][0]; // è¿”å› a çš„çˆ¶èŠ‚ç‚¹ï¼Œå³ä¸º LCA } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; // è¯»å…¥èŠ‚ç‚¹æ•°ã€æŸ¥è¯¢æ¬¡æ•°å’Œæ ¹èŠ‚ç‚¹ç¼–å· // é€ä¸ªè¯»å…¥æ¯æ¡è¾¹ï¼Œæ„å»ºæ ‘çš„é‚»æ¥è¡¨è¡¨ç¤º for (int i = 1; i \u0026lt; n; i ++ ) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].push_back(b); g[b].push_back(a); } dfs(s, 0); // æ±‚æ¯ä¸ªèŠ‚ç‚¹çš„æ·±åº¦å’Œç¥–å…ˆä¿¡æ¯ while (m -- ) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // è¯»å…¥æŸ¥è¯¢ cout \u0026lt;\u0026lt; lca(a, b) \u0026lt;\u0026lt; endl; // è¾“å‡º } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/lca/","title":"å€å¢LCAæ¨¡æ¿"},{"content":"æ¨¡æ¿ åªé€‚ç”¨äºæ¨¡æ•°ä¸ºè´¨æ•°çš„æƒ…å†µ(è´¹é©¬å°å®šç†) 1 2 3 4 5 6 7 vector\u0026lt;long long\u0026gt; inv_vec(long long n, long long m) { vector\u0026lt;long long\u0026gt; inv(n + 1, 1); for (long long i = 2; i \u0026lt;= n; i++) { inv[i] = (m - m / i) * inv[m % i] % m; } return inv; } ã€æ¨¡æ¿ã€‘ä¹˜æ³•é€†å…ƒ é¢˜ç›®èƒŒæ™¯ è¿™æ˜¯ä¸€é“æ¨¡æ¿é¢˜\né¢˜ç›®æè¿° ç»™å®š $n,p$ æ±‚ $1\\sim n$ ä¸­æ‰€æœ‰æ•´æ•°åœ¨æ¨¡ $p$ æ„ä¹‰ä¸‹çš„ä¹˜æ³•é€†å…ƒã€‚\nè¿™é‡Œ $a$ æ¨¡ $p$ çš„ä¹˜æ³•é€†å…ƒå®šä¹‰ä¸º $ax\\equiv1\\pmod p$ çš„è§£ã€‚\nè¾“å…¥æ ¼å¼ ä¸€è¡Œä¸¤ä¸ªæ­£æ•´æ•° $n,p$ã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡º $n$ è¡Œï¼Œç¬¬ $i$ è¡Œè¡¨ç¤º $i$ åœ¨æ¨¡ $p$ ä¸‹çš„ä¹˜æ³•é€†å…ƒã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 10 13 æ ·ä¾‹è¾“å‡º #1 1 2 3 4 5 6 7 8 9 10 1 7 9 10 8 11 2 5 3 4 æç¤º $ 1 \\leq n \\leq 3 \\times 10 ^ 6, n \u0026lt; p \u0026lt; 20000528 $\nè¾“å…¥ä¿è¯ $ p $ ä¸ºè´¨æ•°ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;iostream\u0026gt; using namespace std; const int N=3e6+2; long long inv[N]; void inv_vec(long long n, long long m) { inv[0]=1; inv[1]=1; for (long long i = 2; i \u0026lt;= n; i++) { inv[i] = (m - m / i) * inv[m % i] % m; printf(\u0026#34;%lld\\n\u0026#34;,inv[i]); } } int main(){ int n,p; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;p); printf(\u0026#34;1\\n\u0026#34;); inv_vec(n,p); return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/inv2/","title":"ä¹˜æ³•é€†å…ƒé€’æ¨æ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 long long extgcd(long long a, long long b, long long \u0026amp;x, long long \u0026amp;y) { if (b == 0) { x = 1; y = 0; return a; } long long d = extgcd(b, a % b, y, x); y -= a / b * x; return d; } long long inv(long long a, long long m) { long long x, y; if (extgcd(a, m, x, y) != 1) { return -1; // ä¸å­˜åœ¨ä¹˜æ³•é€†å…ƒ } return (x % m + m) % m; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/inv1/","title":"ä¹˜æ³•é€†å…ƒæ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 FOR(p,0,n){ while(!maxs.empty()\u0026amp;\u0026amp;maxs.back()\u0026lt;a[p])maxs.pop_back(); while(!mins.empty()\u0026amp;\u0026amp;mins.back()\u0026gt;a[p])mins.pop_back(); maxs.push_back(a[p]); mins.push_back(a[p]); ans1[p]=maxs.front(); ans2[p]=mins.front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;maxs.front()==a[p-k+1])maxs.pop_front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;mins.front()==a[p-k+1])mins.pop_front(); } æ»‘åŠ¨çª—å£ /ã€æ¨¡æ¿ã€‘å•è°ƒé˜Ÿåˆ— é¢˜ç›®æè¿° æœ‰ä¸€ä¸ªé•¿ä¸º $n$ çš„åºåˆ— $a$ï¼Œä»¥åŠä¸€ä¸ªå¤§å°ä¸º $k$ çš„çª—å£ã€‚ç°åœ¨è¿™ä¸ªä»å·¦è¾¹å¼€å§‹å‘å³æ»‘åŠ¨ï¼Œæ¯æ¬¡æ»‘åŠ¨ä¸€ä¸ªå•ä½ï¼Œæ±‚å‡ºæ¯æ¬¡æ»‘åŠ¨åçª—å£ä¸­çš„æœ€å¤§å€¼å’Œæœ€å°å€¼ã€‚\nä¾‹å¦‚ï¼š\nThe array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$ã€‚\nè¾“å…¥æ ¼å¼ è¾“å…¥ä¸€å…±æœ‰ä¸¤è¡Œï¼Œç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ­£æ•´æ•° $n,k$ã€‚ ç¬¬äºŒè¡Œ $n$ ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºåºåˆ— $a$\nè¾“å‡ºæ ¼å¼ è¾“å‡ºå…±ä¸¤è¡Œï¼Œç¬¬ä¸€è¡Œä¸ºæ¯æ¬¡çª—å£æ»‘åŠ¨çš„æœ€å°å€¼\nç¬¬äºŒè¡Œä¸ºæ¯æ¬¡çª—å£æ»‘åŠ¨çš„æœ€å¤§å€¼\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 8 3 1 3 -1 -3 5 3 6 7 æ ·ä¾‹è¾“å‡º #1 1 2 -1 -3 -3 -3 3 3 3 3 5 5 6 7 æç¤º ã€æ•°æ®èŒƒå›´ã€‘ å¯¹äº $50%$ çš„æ•°æ®ï¼Œ$1 \\le n \\le 10^5$ï¼›\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œ$1\\le k \\le n \\le 10^6$ï¼Œ$a_i \\in [-2^{31},2^{31})$ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int a[N],ans1[N],ans2[N]; deque\u0026lt;int\u0026gt; maxs,mins; int main() { ios int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; FOR(i,0,n){ cin\u0026gt;\u0026gt;a[i]; } FOR(p,0,n){ while(!maxs.empty()\u0026amp;\u0026amp;maxs.back()\u0026lt;a[p])maxs.pop_back(); while(!mins.empty()\u0026amp;\u0026amp;mins.back()\u0026gt;a[p])mins.pop_back(); maxs.push_back(a[p]); mins.push_back(a[p]); ans1[p]=maxs.front(); ans2[p]=mins.front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;maxs.front()==a[p-k+1])maxs.pop_front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;mins.front()==a[p-k+1])mins.pop_front(); } FOR(i,k-1,n){ cout\u0026lt;\u0026lt;ans2[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; FOR(i,k-1,n){ cout\u0026lt;\u0026lt;ans1[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/monotonicqueue/","title":"å•è°ƒé˜Ÿåˆ—æ¨¡æ¿"},{"content":"æ¬§æ‹‰ç­› 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const int N=100; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } ã€æ¨¡æ¿ã€‘çº¿æ€§ç­›ç´ æ•° é¢˜ç›®èƒŒæ™¯ æœ¬é¢˜å·²æ›´æ–°ï¼Œä»åˆ¤æ–­ç´ æ•°æ”¹ä¸ºäº†æŸ¥è¯¢ç¬¬ $k$ å°çš„ç´ æ•°\næç¤ºï¼šå¦‚æœä½ ä½¿ç”¨ cin æ¥è¯»å…¥ï¼Œå»ºè®®ä½¿ç”¨ std::ios::sync_with_stdio(0) æ¥åŠ é€Ÿã€‚\né¢˜ç›®æè¿° å¦‚é¢˜ï¼Œç»™å®šä¸€ä¸ªèŒƒå›´ $n$ï¼Œæœ‰ $q$ ä¸ªè¯¢é—®ï¼Œæ¯æ¬¡è¾“å‡ºç¬¬ $k$ å°çš„ç´ æ•°ã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ­£æ•´æ•° $n,q$ï¼Œåˆ†åˆ«è¡¨ç¤ºæŸ¥è¯¢çš„èŒƒå›´å’ŒæŸ¥è¯¢çš„ä¸ªæ•°ã€‚\næ¥ä¸‹æ¥ $q$ è¡Œæ¯è¡Œä¸€ä¸ªæ­£æ•´æ•° $k$ï¼Œè¡¨ç¤ºæŸ¥è¯¢ç¬¬ $k$ å°çš„ç´ æ•°ã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡º $q$ è¡Œï¼Œæ¯è¡Œä¸€ä¸ªæ­£æ•´æ•°è¡¨ç¤ºç­”æ¡ˆã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 100 5 1 2 3 4 5 æ ·ä¾‹è¾“å‡º #1 1 2 3 4 5 2 3 5 7 11 æç¤º ã€æ•°æ®èŒƒå›´ã€‘\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œ$n = 10^8$ï¼Œ$1 \\le q \\le 10^6$ï¼Œä¿è¯æŸ¥è¯¢çš„ç´ æ•°ä¸å¤§äº $n$ã€‚\nData by NaCly_Fish.\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e8; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int main() { ios int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; get_primes(n); while(q--){ int x; cin\u0026gt;\u0026gt;x; cout\u0026lt;\u0026lt;primes[x-1]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/eulersieve/","title":"æ¬§æ‹‰ç­›æ¨¡æ¿"},{"content":"Sets A set is a collection of objects Sets are used to group objects together Three ways to express the members in a set - List all the members - Use predicates - Use suspension(çœç•¥å·)points(must be inferred) universal set $â„•$ : the set of all natural numbers $â„¤$ : the set of integers $â„¤^+$ : the set of all the positive integers $â„š$: the set of all rational numbers $â„$: the set of all the real numbers $â„‚$: the set of all complex numbers Venn Diagrams two basic shapes A rectangle: indicates the universal set Circles or other shapes: indicate normal sets Elements and Sets $AâˆˆB$ : A is in or is an element of B $Aâˆ‰B$ : A is not in or is not an element of B Subsets Subsets Proper subsets(çœŸå­é›†) Empty sets Cardinality number of distinct elements in a set\nThe cardinality of a set s is denoted as |s|\nPower Sets $P(S) = {A|A âŠ† S}$\nTheorem of Power Sets: $ if |S| = n, then |P(S)| = 2^n$\nOrdered n-tuple The form (1, 2, â€¦ , ) or \u0026lt; 1, 2, â€¦ , \u0026gt; (1,2) not equal to (2,1) Cartesian Product(ç¬›å¡å°”ä¹˜ç§¯) Cartesian product of $S_1, S_2, â‹¯ ,S_n (denoted S_1 Ã— S_2 Ã— â‹¯ Ã—S_n )$ $S_1 Ã— S_2 Ã— â‹¯ Ã—S_n = {(a1, a2, â€¦ ,an )|a_1 âˆˆ S_1 âˆ§ a_2 âˆˆ S_2 âˆ§â‹¯ âˆ§ a_n âˆˆ S_n}$\nDisjoint Sets If A âˆ© B = âˆ… then A and B are disjoint. If A âˆ© B â‰  âˆ… then A and B are overlapped. function conditions A function from to is a subset of Ã— which satisfies the following two conditions\n1.$ âˆ€ x(x âˆˆ A â†’ âˆƒ y(y âˆˆ B âˆ§ (x,y) âˆˆf)) $\n2. $ (((x_1,y_1 ) âˆˆ f âˆ§ (x_1,y_2 ) âˆˆ f) â†’ y_1 = y_2)$\nImage, Pre-image and Range(å€¼åŸŸ) If $y = f(x)$ from set A to set B, then\ny is called the image of x under f x is called a pre-image of y the set of all the images of the elements in the domain under is called the range of f, f(A) = {f(x)|x âˆˆ A} injective functionï¼ˆå•å°„ï¼‰ f is one-to-one\nurjective function (æ»¡å°„) Onto function :$âˆ€y âˆˆ B (âˆƒx(x âˆˆA âˆ§f (x) =y ))$\nbijective function (åŒå°„) [One-to-One and onto function] is also called bijective function\nFloor functions Denoted $\\lfloor x \\rfloor$ The largest integer less than or equivalent to x Ceiling functions Denoted $\\lceil x \\rceil$ The smallest integer greater than or equivalent to x Sequences æ•°åˆ— Sequences are ordered lists of elements â€¢ A sequence is a function from a subset of the set of integers ({0, 1, 2, 3, â€¦ } or {1, 2, 3, â€¦ }) to a set , denoted {$a_n$}. The integers determine the positions of the elements in the list\nSummations æ±‚å’Œ A summation is the value of the sum of the terms of a sequence.\nSpecial Summations Geometric series ç­‰æ¯”æ•°åˆ—å’Œ $\\sum^n_{j=0}ar^j$\nharmonic series $\\sum^n_{j=1} \\frac{1}{j}$\n","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/sfss/","title":"SFSS"},{"content":"æŒ‰åºåˆå¹¶è·¯å¾„å‹ç¼©ä¼˜åŒ–å¹¶æŸ¥é›† å°è£…æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Buf { public: Buf(int sz) : root(sz), rank(sz) { for (int i = 0; i \u0026lt; sz; i++) { root[i] = i; rank[i] = 1; } } int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] \u0026lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(int x, int y) { return find(x) == find(y); } private: vector\u0026lt;int\u0026gt; root; vector\u0026lt;int\u0026gt; rank; }; éå°è£…æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ll root[MAXN],rank[MAXN],n; void initbuf(ll n){ for (ll i = 0; i \u0026lt; n; i++) { root[i] = i; } } ll find(ll x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(ll x, ll y) { ll rootX = find(x); ll rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) root[rootY] = rootX; else if (rank[rootX] \u0026lt; rank[rootY])root[rootX] = rootY; else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(ll x, ll y) { return find(x) == find(y); } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/buf/","title":"å¹¶æŸ¥é›†æ¨¡æ¿"},{"content":"æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 ll qpow(ll a,ll b,ll p){ ll ans=1%p; while(b){ if(b\u0026amp;1)ans=(ans*a)%p; b\u0026gt;\u0026gt;=1; a=(a*a)%p; } return ans; } é¢˜ç›®æè¿° ç»™ä½ ä¸‰ä¸ªæ•´æ•° $a,b,p$ï¼Œæ±‚ $a^b \\bmod p$ã€‚\nè¾“å…¥æ ¼å¼ è¾“å…¥åªæœ‰ä¸€è¡Œä¸‰ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«ä»£è¡¨ $a,b,p$ã€‚\nè¾“å‡ºæ ¼å¼ è¾“å‡ºä¸€è¡Œä¸€ä¸ªå­—ç¬¦ä¸² a^b mod p=sï¼Œå…¶ä¸­ $a,b,p$ åˆ†åˆ«ä¸ºé¢˜ç›®ç»™å®šçš„å€¼ï¼Œ $s$ ä¸ºè¿ç®—ç»“æœã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 10 9 æ ·ä¾‹è¾“å‡º #1 1 2^10 mod 9=7 æç¤º æ ·ä¾‹è§£é‡Š\n$2^{10} = 1024$ï¼Œ$1024 \\bmod 9 = 7$ã€‚\næ•°æ®è§„æ¨¡ä¸çº¦å®š\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œä¿è¯ $0\\le a,b \u0026lt; 2^{31}$ï¼Œ$a+b\u0026gt;0$ï¼Œ$2 \\leq p \\lt 2^{31}$ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; ll qpow(ll a,ll b,ll p){ ll ans=1%p; while(b){ if(b\u0026amp;1)ans=(ans*a)%p; b\u0026gt;\u0026gt;=1; a=(a*a)%p; } return ans; } int main() { ios ll a,b,p; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; ll res=qpow(a,b,p); cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;^\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; mod \u0026#34;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#34;=\u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/qpowp/","title":"å¿«é€Ÿå¹‚å–ä½™æ¨¡æ¿"},{"content":" A relation is a structure that is used to represent the relationships between elements\nCategory of relations Binary relations N-ary relations Binary Relations A binary relation R from the set ğ´ to the set ğµ is a subset of ğ´ Ã— ğµ.\nR is a set of ordered pairs in the form (ğ‘, ğ‘) where ğ‘ is from ğ´ and ğ‘ is from ğµ.\na R b denotes (ğ‘, ğ‘) âˆˆ ğ‘…, called ğ‘ is related to ğ‘ by R\nFunctions and Relations Are all the functions relations? Yes Are all relations functions? No Relation on the Set A relation on the set is a relation from ğ´ to ğ´. Properties of Relations Reflexive A relation ğ‘… on a set ğ´ is called reflexive if (ğ‘, ğ‘) âˆˆ ğ‘… for every element ğ‘ âˆˆ A\nSymmetric A relation ğ‘… on a set ğ´ is called symmetric if (ğ‘, ğ‘) âˆˆ ğ‘… whenever (ğ‘, ğ‘) âˆˆ R\nAnti-symmetric relation ğ‘… on a set ğ´ is called anti-symmetric if whenever (ğ‘, ğ‘) âˆˆ ğ‘… and (ğ‘, ğ‘) âˆˆ ğ‘…, then ğ‘ = ğ‘\nTransitive A relation ğ‘… on a set ğ´ is called transitive if whenever (ğ‘, ğ‘) âˆˆ ğ‘… and (ğ‘, ğ‘) âˆˆ ğ‘…, then (ğ‘, ğ‘) âˆˆ ğ‘…\nCombining Relations The composite of ğ‘… and ğ‘† (ğ‘† â—¦ ğ‘…): consisting of all ordered pairs (ğ‘, ğ‘) where ğ‘ âˆˆ ğ´, and ğ‘ âˆˆ ğ¶ if there exists ğ‘ such that (ğ‘, ğ‘) âˆˆ ğ‘… and (ğ‘, ğ‘) âˆˆ ğ‘†.\nE.g.,\nâ–ª ğ´ = {1}, ğµ = {0, 1}, ğ¶ = {2, 3}\nâ–ª ğ‘… = {(1, 0), (1, 1)} (a relation from ğ´ to ğµ)\nâ–ª ğ‘† = {(0, 2), (1, 3)} (a relation from ğµ to ğ¶)\nâ–ª ğ‘† â—¦ ğ‘… = {(1, 2), (1, 3)}\nPowers of a Relation Let ğ‘… be a relation on the set ğ´. The powers ğ‘…ğ‘› for integer ğ‘› with ğ‘› \u0026gt; 0 are defined recursively by $R^1 = R$\n$R^{n}=R^{n-1}â—¦R$\nTheorem: The relation ğ‘… on a set ğ´ is transitive if and only if ğ‘…^ğ‘› âŠ† ğ‘… for ğ‘› = 1, 2, 3, â‹¯\nğ‘›-ary Relations Let ğ´1, ğ´2, â€¦ , ğ´ğ‘› be sets. An ğ‘›-ary relation on these sets is a subset of ğ´1 Ã— ğ´2 Ã— â‹¯ Ã— ğ´ğ‘› Domain: ğ´1 Ã— ğ´2 Ã— â‹¯ Ã— ğ´ğ‘› Degree: n Relations and Database Currently, the most commonly used databases are relational databases. Each database consists of multiple relations. Each relation is presented as a table. Operations on n-ary Relations Selection operator ğœ: ğ‘›-ary relation ğ‘… condition ğ‘ Selection operator ğœğ‘: maps ğ‘… to an ğ‘›-ary relations ğ‘‡, where all the tuples in ğ‘‡ satisfy the condition ğ‘.\ni.e. ğœ_{ğ‘šğ‘ğ‘—ğ‘œğ‘Ÿ}=\u0026ldquo;ğ¶ğ‘œğ‘šğ‘ğ‘¢ğ‘¡ğ‘’ğ‘Ÿ ğ‘†ğ‘ğ‘–ğ‘’ğ‘›ğ‘ğ‘’\u0026rdquo; ğºğ‘Ÿğ‘ğ‘‘ğ‘’ğ‘…ğ‘’ğ‘ğ‘œğ‘Ÿğ‘¡ = {(ğ½ğ‘œâ„ğ‘›,001,ğ¶ğ‘œğ‘šğ‘ğ‘¢ğ‘¡ğ‘’ğ‘Ÿ ğ‘†ğ‘ğ‘–ğ‘’ğ‘›ğ‘ğ‘’, 3.5)} Projection operator ğœ‹: the input relation is on ğ‘› tuples (ğ‘1, ğ‘2, â‹¯ , ğ‘ğ‘›) , the output relation is on ğ‘š tuples (ğ‘ğ‘–_1,ğ‘ğ‘–_2, â‹¯ , ğ‘ğ‘–_ğ‘š), ğ‘š \u0026lt; ğ‘›. Projection operator ğœ‹ğ‘–1,ğ‘–2,â‹¯,ğ‘–ğ‘š: removes the tuples not in the ğ‘š-tuple (ğ‘ğ‘–1ğ‘ğ‘–2, â‹¯ , ğ‘ğ‘–ğ‘š) list i.e. ğœ‹_{ğ‘›ğ‘ğ‘šğ‘’,ğºğ‘ƒğ´} (ğºğ‘Ÿğ‘ğ‘‘ğ‘’ğ‘…ğ‘’ğ‘ğ‘œğ‘Ÿğ‘¡) = {(ğ½ğ‘œâ„ğ‘›, 3.5 ),( ğ‘‡ğ‘œğ‘›ğ‘¦, 3.2 ),( ğ½ğ‘œğ‘›ğ‘ğ‘ , 3.3)} Equivalence Relations A relation on a set ğ´ is called an equivalence relation if it is reflexive, symmetric, and transitive. Let ğ‘… be an equivalence relation on ğ´. Equivalent class Equivalent class -\u0026gt; Equivalent relations\nPartition All the equivalent classes obtained from ğ´ through an equivalent class are either same or disjoint. These disjoint classes are subsets of ğ´. The union of these subsets is ğ´. These subsets are called a partition of A In general, (ğ´1, ğ´2, â‹¯ , ğ´ğ‘›) is a partition of ğ´ if: ğ´ğ‘– â‰  âˆ… for all 1 â‰¤ ğ‘– â‰¤ ğ‘› ğ´ğ‘– âˆ© ğ´ğ‘— = âˆ… for all 1 â‰¤ ğ‘–,ğ‘— â‰¤ ğ‘› ğ´1 âˆª ğ´2 âˆª â‹¯ âˆª ğ´ğ‘› = A Theorem: Let ğ‘… be an equivalence relation on a nonempty set ğ´. The following statements are equivalent:\na R b [ğ‘] = [ğ‘] ğ‘ âˆ© [ğ‘] â‰  âˆ… ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/distcreterelations/","title":"ç¦»æ•£æ•°å­¦â€”â€”Relations"},{"content":"ã€æ¨¡æ¿ã€‘å¹¶æŸ¥é›† é¢˜ç›®æè¿° å¦‚é¢˜ï¼Œç°åœ¨æœ‰ä¸€ä¸ªå¹¶æŸ¥é›†ï¼Œä½ éœ€è¦å®Œæˆåˆå¹¶å’ŒæŸ¥è¯¢æ“ä½œã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° $N,M$ ,è¡¨ç¤ºå…±æœ‰ $N$ ä¸ªå…ƒç´ å’Œ $M$ ä¸ªæ“ä½œã€‚\næ¥ä¸‹æ¥ $M$ è¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸‰ä¸ªæ•´æ•° $Z_i,X_i,Y_i$ ã€‚\nå½“ $Z_i=1$ æ—¶ï¼Œå°† $X_i$ ä¸ $Y_i$ æ‰€åœ¨çš„é›†åˆåˆå¹¶ã€‚\nå½“ $Z_i=2$ æ—¶ï¼Œè¾“å‡º $X_i$ ä¸ $Y_i$ æ˜¯å¦åœ¨åŒä¸€é›†åˆå†…ï¼Œæ˜¯çš„è¾“å‡º Y ï¼›å¦åˆ™è¾“å‡º N ã€‚\nè¾“å‡ºæ ¼å¼ å¯¹äºæ¯ä¸€ä¸ª $Z_i=2$ çš„æ“ä½œï¼Œéƒ½æœ‰ä¸€è¡Œè¾“å‡ºï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªå¤§å†™å­—æ¯ï¼Œä¸º Y æˆ–è€… N ã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 7 8 4 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 æ ·ä¾‹è¾“å‡º #1 1 2 3 4 N Y N Y æç¤º å¯¹äº $30%$ çš„æ•°æ®ï¼Œ$N \\le 10$ï¼Œ$M \\le 20$ã€‚\nå¯¹äº $70%$ çš„æ•°æ®ï¼Œ$N \\le 100$ï¼Œ$M \\le 10^3$ã€‚\nå¯¹äº $100%$ çš„æ•°æ®ï¼Œ$1\\le N \\le 10^4$ï¼Œ$1\\le M \\le 2\\times 10^5$ï¼Œ$1 \\le X_i, Y_i \\le N$ï¼Œ$Z_i \\in { 1, 2 }$ã€‚\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; class Buf { public: Buf(int sz) : root(sz), rank(sz) { for (int i = 0; i \u0026lt; sz; i++) { root[i] = i; rank[i] = 1; } } int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] \u0026lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(int x, int y) { return find(x) == find(y); } private: vector\u0026lt;int\u0026gt; root; vector\u0026lt;int\u0026gt; rank; }; int main() { ios int n,m,y,x,z; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; Buf a=Buf(n+1); while(m--){ cin\u0026gt;\u0026gt;z\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(z==1){ a.unionSet(x,y); } else{ if(a.connected(x,y))cout\u0026lt;\u0026lt;\u0026#34;Y\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; cout\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0003/","title":"æ´›è°·0003â€”â€”å¹¶æŸ¥é›†"},{"content":"[TJOI2009] å¼€å…³ é¢˜ç›®æè¿° ç°æœ‰ $n$ ç›ç¯æ’æˆä¸€æ’ï¼Œä»å·¦åˆ°å³ä¾æ¬¡ç¼–å·ä¸ºï¼š$1$ï¼Œ$2$ï¼Œâ€¦â€¦ï¼Œ$n$ã€‚ç„¶åä¾æ¬¡æ‰§è¡Œ $m$ é¡¹æ“ä½œã€‚\næ“ä½œåˆ†ä¸ºä¸¤ç§ï¼š\næŒ‡å®šä¸€ä¸ªåŒºé—´ $[a,b]$ï¼Œç„¶åæ”¹å˜ç¼–å·åœ¨è¿™ä¸ªåŒºé—´å†…çš„ç¯çš„çŠ¶æ€ï¼ˆæŠŠå¼€ç€çš„ç¯å…³ä¸Šï¼Œå…³ç€çš„ç¯æ‰“å¼€ï¼‰ï¼› æŒ‡å®šä¸€ä¸ªåŒºé—´ $[a,b]$ï¼Œè¦æ±‚ä½ è¾“å‡ºè¿™ä¸ªåŒºé—´å†…æœ‰å¤šå°‘ç›ç¯æ˜¯æ‰“å¼€çš„ã€‚ ç¯åœ¨åˆå§‹æ—¶éƒ½æ˜¯å…³ç€çš„ã€‚\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œæœ‰ä¸¤ä¸ªæ•´æ•° $n$ å’Œ $m$ï¼Œåˆ†åˆ«è¡¨ç¤ºç¯çš„æ•°ç›®å’Œæ“ä½œçš„æ•°ç›®ã€‚\næ¥ä¸‹æ¥æœ‰ $m$ è¡Œï¼Œæ¯è¡Œæœ‰ä¸‰ä¸ªæ•´æ•°ï¼Œä¾æ¬¡ä¸ºï¼š$c$ã€$a$ã€$b$ã€‚å…¶ä¸­ $c$ è¡¨ç¤ºæ“ä½œçš„ç§ç±»ã€‚\nå½“ $c$ çš„å€¼ä¸º $0$ æ—¶ï¼Œè¡¨ç¤ºæ˜¯ç¬¬ä¸€ç§æ“ä½œã€‚ å½“ $c$ çš„å€¼ä¸º $1$ æ—¶ï¼Œè¡¨ç¤ºæ˜¯ç¬¬äºŒç§æ“ä½œã€‚ $a$ å’Œ $b$ åˆ™åˆ†åˆ«è¡¨ç¤ºäº†æ“ä½œåŒºé—´çš„å·¦å³è¾¹ç•Œã€‚\nè¾“å‡ºæ ¼å¼ æ¯å½“é‡åˆ°ç¬¬äºŒç§æ“ä½œæ—¶ï¼Œè¾“å‡ºä¸€è¡Œï¼ŒåŒ…å«ä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæ­¤æ—¶åœ¨æŸ¥è¯¢çš„åŒºé—´ä¸­æ‰“å¼€çš„ç¯çš„æ•°ç›®ã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 4 5 0 1 2 0 2 4 1 2 3 0 2 4 1 1 4 æ ·ä¾‹è¾“å‡º #1 1 2 1 2 æç¤º æ•°æ®è§„æ¨¡ä¸çº¦å®š å¯¹äºå…¨éƒ¨çš„æµ‹è¯•ç‚¹ï¼Œä¿è¯ $2\\le n\\le 10^5$ï¼Œ$1\\le m\\le 10^5$ï¼Œ$1\\le a,b\\le n$ï¼Œ$c\\in{0,1}$ã€‚\\\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e5+9; //å¼€4å€ //n ä¸ºç»´æŠ¤çš„æ•°ç»„é•¿åº¦ï¼ŒAä¸ºç»´æŠ¤çš„æ•°ç»„ ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //å¶å­èŠ‚ç‚¹å¯ä»¥ä¸æ›´æ–° if (len \u0026lt;= 1) return; //å‘ä¸‹ä¼ é€’lazyæ ‡è®° if(mark[p]%2)tree[p \u0026lt;\u0026lt; 1] = (len - len / 2)-tree[p\u0026lt;\u0026lt;1]; mark[p \u0026lt;\u0026lt; 1] += mark[p]%2; if(mark[p]%2)tree[p \u0026lt;\u0026lt; 1 | 1] = (len / 2)-tree[p\u0026lt;\u0026lt;1|1]; mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]%2; //å‘ä¸‹ä¼ é€’äº†ï¼Œè‡ªç„¶æ¸…é™¤è‡ªèº«çš„tag mark[p] = 0; } void push_up(int p){ //è¿™é‡Œç»´æŠ¤çš„æ˜¯åŒºé—´å’Œ tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //å¦‚æœå¶å­èŠ‚ç‚¹ if (cl == cr) return void(tree[p] = A[cl]); //å·¦å³é€’å½’å»ºæ ‘ int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] = d * (cr - cl + 1)-tree[p]; mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } int main() { ios int m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; build(); int op,x,y; while(m--){ cin\u0026gt;\u0026gt;op; if(op==0){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; update(x,y,1); } else{ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll res=query(x,y); cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0004/","title":"æ´›è°·0004â€”â€”[TJOI2009] å¼€å…³"},{"content":"ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1 é¢˜ç›®æè¿° å¦‚é¢˜ï¼Œå·²çŸ¥ä¸€ä¸ªæ•°åˆ—ï¼Œä½ éœ€è¦è¿›è¡Œä¸‹é¢ä¸¤ç§æ“ä½œï¼š\nå°†æŸåŒºé—´æ¯ä¸€ä¸ªæ•°åŠ ä¸Š $k$ã€‚ æ±‚å‡ºæŸåŒºé—´æ¯ä¸€ä¸ªæ•°çš„å’Œã€‚ è¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•° $n, m$ï¼Œåˆ†åˆ«è¡¨ç¤ºè¯¥æ•°åˆ—æ•°å­—çš„ä¸ªæ•°å’Œæ“ä½œçš„æ€»ä¸ªæ•°ã€‚\nç¬¬äºŒè¡ŒåŒ…å« $n$ ä¸ªç”¨ç©ºæ ¼åˆ†éš”çš„æ•´æ•°ï¼Œå…¶ä¸­ç¬¬ $i$ ä¸ªæ•°å­—è¡¨ç¤ºæ•°åˆ—ç¬¬ $i$ é¡¹çš„åˆå§‹å€¼ã€‚\næ¥ä¸‹æ¥ $m$ è¡Œæ¯è¡ŒåŒ…å« $3$ æˆ– $4$ ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºä¸€ä¸ªæ“ä½œï¼Œå…·ä½“å¦‚ä¸‹ï¼š\n1 x y kï¼šå°†åŒºé—´ $[x, y]$ å†…æ¯ä¸ªæ•°åŠ ä¸Š $k$ã€‚ 2 x yï¼šè¾“å‡ºåŒºé—´ $[x, y]$ å†…æ¯ä¸ªæ•°çš„å’Œã€‚ è¾“å‡ºæ ¼å¼ è¾“å‡ºåŒ…å«è‹¥å¹²è¡Œæ•´æ•°ï¼Œå³ä¸ºæ‰€æœ‰æ“ä½œ 2 çš„ç»“æœã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 6 7 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 æ ·ä¾‹è¾“å‡º #1 1 2 3 11 8 20 æç¤º å¯¹äº $30%$ çš„æ•°æ®ï¼š$n \\le 8$ï¼Œ$m \\le 10$ã€‚\nå¯¹äº $70%$ çš„æ•°æ®ï¼š$n \\le {10}^3$ï¼Œ$m \\le {10}^4$ã€‚\nå¯¹äº $100%$ çš„æ•°æ®ï¼š$1 \\le n, m \\le {10}^5$ã€‚\nä¿è¯ä»»æ„æ—¶åˆ»æ•°åˆ—ä¸­æ‰€æœ‰å…ƒç´ çš„ç»å¯¹å€¼ä¹‹å’Œ $\\le {10}^{18}$ã€‚\nã€æ ·ä¾‹è§£é‡Šã€‘\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e5+9; //å¼€4å€ //n ä¸ºç»´æŠ¤çš„æ•°ç»„é•¿åº¦ï¼ŒAä¸ºç»´æŠ¤çš„æ•°ç»„ ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //å¶å­èŠ‚ç‚¹å¯ä»¥ä¸æ›´æ–° if (len \u0026lt;= 1) return; //å‘ä¸‹ä¼ é€’lazyæ ‡è®° tree[p \u0026lt;\u0026lt; 1] += mark[p] * (len - len / 2); mark[p \u0026lt;\u0026lt; 1] += mark[p]; tree[p \u0026lt;\u0026lt; 1 | 1] += mark[p] * (len / 2); mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]; //å‘ä¸‹ä¼ é€’äº†ï¼Œè‡ªç„¶æ¸…é™¤è‡ªèº«çš„tag mark[p] = 0; } void push_up(int p){ //è¿™é‡Œç»´æŠ¤çš„æ˜¯åŒºé—´å’Œ tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //å¦‚æœå¶å­èŠ‚ç‚¹ if (cl == cr) return void(tree[p] = A[cl]); //å·¦å³é€’å½’å»ºæ ‘ int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] += d * (cr - cl + 1); mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } int main() { ios int m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; FOR(i,1,n+1){ cin\u0026gt;\u0026gt;A[i]; } build(); int op,x,y,k; while(m--){ cin\u0026gt;\u0026gt;op; if(op==1){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;k; update(x,y,k); } else{ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll res=query(x,y); cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0005/","title":"æ´›è°·0005â€”â€”ã€æ¨¡æ¿ã€‘çº¿æ®µæ ‘ 1"},{"content":"å°è£…æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class FenwickTree{ public: int n; vector\u0026lt;int\u0026gt; tree; FenwickTree(int i): n(i),tree(i+1){ for(int a=0;a\u0026lt;=i;a++){ tree[a]=0; } } void update(int i,int val){ while(i\u0026lt;=n){ tree[i]+=val; i+=i\u0026amp;(-i); } } int query(int i){ int res=0; while(i\u0026gt;0){ res+=tree[i]; i-=i\u0026amp;(-i); } return res; } } éå°è£…æ¨¡æ¿ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //nä¸ºå®é™…é•¿åº¦ ll tree[MAXN],n; void update(int i,int val){ while(i\u0026lt;=n){ tree[i]+=val; i+=i\u0026amp;(-i); } } int query(int i){ int res=0; while(i\u0026gt;0){ res+=tree[i]; i-=i\u0026amp;(-i); } return res; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/fenwicktree/","title":"æ ‘çŠ¶æ•°ç»„æ¨¡æ¿"},{"content":"lazyçº¿æ®µæ ‘æ¨¡æ¿ åŒºé—´ä¿®æ”¹logn åŒºé—´æŸ¥è¯¢logn ï¼ˆç»´æŠ¤å­˜åœ¨äº¤æ¢å¾‹çš„ä¿¡æ¯ï¼‰ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 const int MAXN=1e5+9; //å¼€4å€ //n ä¸ºç»´æŠ¤çš„æ•°ç»„é•¿åº¦ï¼ŒAä¸ºç»´æŠ¤çš„æ•°ç»„ ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //å¶å­èŠ‚ç‚¹å¯ä»¥ä¸æ›´æ–° if (len \u0026lt;= 1) return; //å‘ä¸‹ä¼ é€’lazyæ ‡è®° tree[p \u0026lt;\u0026lt; 1] += mark[p] * (len - len / 2); mark[p \u0026lt;\u0026lt; 1] += mark[p]; tree[p \u0026lt;\u0026lt; 1 | 1] += mark[p] * (len / 2); mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]; //å‘ä¸‹ä¼ é€’äº†ï¼Œè‡ªç„¶æ¸…é™¤è‡ªèº«çš„tag mark[p] = 0; } void push_up(int p){ //è¿™é‡Œç»´æŠ¤çš„æ˜¯åŒºé—´å’Œ tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //å¦‚æœå¶å­èŠ‚ç‚¹ if (cl == cr) return void(tree[p] = A[cl]); //å·¦å³é€’å½’å»ºæ ‘ int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //å½“å‰è¢«åŒ…å« if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] += d * (cr - cl + 1); mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/segmenttree/","title":"çº¿æ®µæ ‘æ¨¡æ¿"},{"content":"ã€æ·±è¿›1.ä¾‹1ã€‘æ±‚åŒºé—´å’Œ é¢˜ç›®æè¿° ç»™å®š $n$ ä¸ªæ­£æ•´æ•°ç»„æˆçš„æ•°åˆ— $a_1, a_2, \\cdots, a_n$ å’Œ $m$ ä¸ªåŒºé—´ $[l_i,r_i]$ï¼Œåˆ†åˆ«æ±‚è¿™ $m$ ä¸ªåŒºé—´çš„åŒºé—´å’Œã€‚å¯¹äºæ‰€æœ‰æµ‹è¯•æ•°æ®ï¼Œ$n,m\\le10^5,a_i\\le 10^4$\nè¾“å…¥æ ¼å¼ å…± $n+m+2$ è¡Œã€‚\nç¬¬ä¸€è¡Œï¼Œä¸ºä¸€ä¸ªæ­£æ•´æ•° $n$ ã€‚\nç¬¬äºŒè¡Œï¼Œä¸º $n$ ä¸ªæ­£æ•´æ•° $a_1,a_2, \\cdots ,a_n$\nç¬¬ä¸‰è¡Œï¼Œä¸ºä¸€ä¸ªæ­£æ•´æ•° $m$ ã€‚\nç¬¬ $4$ åˆ°ç¬¬ $n+m+2$ è¡Œï¼Œæ¯è¡Œä¸ºä¸¤ä¸ªæ­£æ•´æ•° $l_i,r_i$ ï¼Œæ»¡è¶³$1\\le l_i\\le r_i\\le n$\nè¾“å‡ºæ ¼å¼ å…± $m$ è¡Œã€‚\nç¬¬ $i$ è¡Œä¸ºç¬¬ $i$ ç»„ç­”æ¡ˆçš„è¯¢é—®ã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 4 4 3 2 1 2 1 4 2 3 æ ·ä¾‹è¾“å‡º #1 1 2 10 5 æç¤º æ ·ä¾‹è§£é‡Šï¼šç¬¬ 1 åˆ°ç¬¬ 4 ä¸ªæ•°åŠ èµ·æ¥å’Œä¸º 10ã€‚ç¬¬ 2 ä¸ªæ•°åˆ°ç¬¬ 3 ä¸ªæ•°åŠ èµ·æ¥å’Œä¸º5ã€‚\nå¯¹äº 50% çš„æ•°æ®ï¼š$n,m\\le 1000$ ï¼›\nå¯¹äº100% çš„æ•°æ®ï¼š$n.m\\le 10^5,a_i\\le 10^4$\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+3; int a[N]; int b[N]; int main() { ios int n,m; cin\u0026gt;\u0026gt;n; FOR(i,0,n){ cin\u0026gt;\u0026gt;a[i]; } FOR(i,1,n+1){ b[i]=b[i-1]+a[i-1]; } cin\u0026gt;\u0026gt;m; int l,r; FOR(i,0,m){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;b[r]-b[l-1]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0001/","title":"æ´›è°·0001â€”â€”æ±‚åŒºé—´å’Œ"},{"content":"æœ€å¤§åŠ æƒçŸ©å½¢ é¢˜ç›®æè¿° ä¸ºäº†æ›´å¥½çš„å¤‡æˆ˜ NOIP2013ï¼Œç”µè„‘ç»„çš„å‡ ä¸ªå¥³å­©å­ LYQ,ZSC,ZHQ è®¤ä¸ºï¼Œæˆ‘ä»¬ä¸å…‰éœ€è¦æœºæˆ¿ï¼Œæˆ‘ä»¬è¿˜éœ€è¦è¿åŠ¨ï¼Œäºæ˜¯å°±å†³å®šæ‰¾æ ¡é•¿ç”³è¯·ä¸€å—ç”µè„‘ç»„çš„è¯¾ä½™è¿åŠ¨åœºåœ°ï¼Œå¬è¯´å¥¹ä»¬éƒ½æ˜¯ç”µè„‘ç»„çš„é«˜æ‰‹ï¼Œæ ¡é•¿æ²¡æœ‰é©¬ä¸Šç­”åº”ä»–ä»¬ï¼Œè€Œæ˜¯å…ˆç»™å¥¹ä»¬å‡ºäº†ä¸€é“æ•°å­¦é¢˜ï¼Œå¹¶ä¸”å‘Šè¯‰å¥¹ä»¬ï¼šä½ ä»¬èƒ½è·å¾—çš„è¿åŠ¨åœºåœ°çš„é¢ç§¯å°±æ˜¯ä½ ä»¬èƒ½æ‰¾åˆ°çš„è¿™ä¸ªæœ€å¤§çš„æ•°å­—ã€‚\næ ¡é•¿å…ˆç»™ä»–ä»¬ä¸€ä¸ª $n\\times n$ çŸ©é˜µã€‚è¦æ±‚çŸ©é˜µä¸­æœ€å¤§åŠ æƒçŸ©å½¢ï¼Œå³çŸ©é˜µçš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½æœ‰ä¸€æƒå€¼ï¼Œæƒå€¼å®šä¹‰åœ¨æ•´æ•°é›†ä¸Šã€‚ä»ä¸­æ‰¾ä¸€çŸ©å½¢ï¼ŒçŸ©å½¢å¤§å°æ— é™åˆ¶ï¼Œæ˜¯å…¶ä¸­åŒ…å«çš„æ‰€æœ‰å…ƒç´ çš„å’Œæœ€å¤§ ã€‚çŸ©é˜µçš„æ¯ä¸ªå…ƒç´ å±äº $[-127,127]$ ,ä¾‹å¦‚\n1 2 3 4 0 â€“2 â€“7 0 9 2 â€“6 2 -4 1 â€“4 1 -1 8 0 â€“2 åœ¨å·¦ä¸‹è§’ï¼š\n1 2 3 9 2 -4 1 -1 8 å’Œä¸º $15$ã€‚\nå‡ ä¸ªå¥³å­©å­æœ‰ç‚¹çŠ¯éš¾äº†ï¼Œäºæ˜¯å°±æ‰¾åˆ°äº†ç”µè„‘ç»„ç²¾æ‰“ç»†ç®—çš„ HZHï¼ŒTZY å°æœ‹å‹å¸®å¿™è®¡ç®—ï¼Œä½†æ˜¯é—æ†¾çš„æ˜¯ä»–ä»¬çš„ç­”æ¡ˆéƒ½ä¸ä¸€æ ·ï¼Œæ¶‰åŠåœŸåœ°çš„äº‹æƒ…æˆ‘ä»¬å¯ä¸èƒ½å«ç³Šï¼Œä½ èƒ½å¸®å¿™è®¡ç®—å‡ºæ ¡é•¿æ‰€ç»™çš„çŸ©å½¢ä¸­åŠ æƒå’Œæœ€å¤§çš„çŸ©å½¢å—ï¼Ÿ\nè¾“å…¥æ ¼å¼ ç¬¬ä¸€è¡Œï¼š$n$ï¼Œæ¥ä¸‹æ¥æ˜¯ $n$ è¡Œ $n$ åˆ—çš„çŸ©é˜µã€‚\nè¾“å‡ºæ ¼å¼ æœ€å¤§çŸ©å½¢ï¼ˆå­çŸ©é˜µï¼‰çš„å’Œã€‚\næ ·ä¾‹ #1 æ ·ä¾‹è¾“å…¥ #1 1 2 3 4 5 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 æ ·ä¾‹è¾“å‡º #1 1 15 æç¤º $1 \\leq n\\le 120$\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=123; int a[N][N]; int b[N][N]; int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,0,n){ FOR(j,0,n){ cin\u0026gt;\u0026gt;a[i][j]; } } FOR(i,1,n+1){ FOR(j,1,n+1){ b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i-1][j-1]; } } int ans=-inf; FOR(x1,1,n+1){ FOR(y1,1,n+1){ FOR(x2,x1,n+1){ FOR(y2,y1,n+1){ ans=max(ans,b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1]); } } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0002/","title":"æ´›è°·0002â€”â€”æœ€å¤§åŠ æƒçŸ©å½¢"},{"content":"ä¸€ç»´å‰ç¼€å’Œ 1 2 3 // S[i] = a[1] + a[2] + ... a[i] // a[l] + ... + a[r] = S[r] - S[l - 1] S[r] - S[l - 1] äºŒç»´å‰ç¼€å’Œ 1 2 3 4 // S[i, j] = ç¬¬iè¡Œjåˆ—æ ¼å­å·¦ä¸Šéƒ¨åˆ†æ‰€æœ‰å…ƒç´ çš„å’Œ b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j] // ä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µçš„å’Œä¸ºï¼š b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1] ä¸€ç»´å·®åˆ† 1 2 // ç»™åŒºé—´[l, r]ä¸­çš„æ¯ä¸ªæ•°åŠ ä¸Šcï¼š B[l] += c, B[r + 1] -= c äºŒç»´å·®åˆ† 1 2 // ç»™ä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ åŠ ä¸Šcï¼š S[x1][y1] += c, S[x2 + 1][y1] -= c, S[x1][y2 + 1] -= c, S[x2 + 1][y2 + 1] += c tips ä»1å¼€å§‹ï¼Œ0å¼€å¤§ï¼Œé˜²ç‰¹åˆ¤ ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/presum/","title":"å‰ç¼€å’Œä¸å·®åˆ†æ¨¡æ¿"},{"content":" 1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\u0026#34;); return 0; } åŸºç¡€çŸ¥è¯† åˆ†å· æ¯ä¸ªè¯­å¥å¿…é¡»ä»¥åˆ†å·ç»“æŸ\nç¬¦å·ç±»å‹ ä¸€å®šè¦æ˜¯è‹±æ–‡ç¬¦å·\næ³¨é‡Š å•è¡Œæ³¨é‡Š å¤šè¡Œæ³¨é‡Š(ä¹Ÿå¯å•è¡Œ) 1 2 3 //å•è¡Œæ³¨é‡Š /*å¤šè¡Œæ³¨é‡Š*/ æ•°æ®ç±»å‹ TYPE BYTE MORE char 1 å­—èŠ‚ -128 åˆ° 127 unsigned char 1 å­—èŠ‚ 0 åˆ° 255 signed char 1 å­—èŠ‚ -128 åˆ° 127 int 2 æˆ– 4 å­—èŠ‚ â€”â€”â€” unsigned int 2 æˆ– 4 å­—èŠ‚ â€”â€”â€” short 2 å­—èŠ‚ â€”â€”â€” unsigned short 2 å­—èŠ‚ â€”â€”â€” long 4 å­—èŠ‚ â€”â€”â€” unsigned long 4 å­—èŠ‚ â€”â€”â€” float 4 å­—èŠ‚ 6 ä½æœ‰æ•ˆä½ double 8 å­—èŠ‚ 15 ä½æœ‰æ•ˆä½ long double 16 å­—èŠ‚ 19 ä½æœ‰æ•ˆä½ 1 2 3 4 5 6 7 //sizeofå¯ä»¥è·å–å‚¨å­˜å­—èŠ‚å¤§å° #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;int å­˜å‚¨å¤§å° : %lu \\n\u0026#34;,sizeof(int)); return 0; } å¸¸é‡ æ•´æ•°å¸¸é‡ æ•´æ•°å¸¸é‡å¯ä»¥æ˜¯åè¿›åˆ¶ã€å…«è¿›åˆ¶æˆ–åå…­è¿›åˆ¶çš„å¸¸é‡ã€‚å‰ç¼€æŒ‡å®šåŸºæ•°ï¼š0x æˆ– 0X è¡¨ç¤ºåå…­è¿›åˆ¶ï¼Œ0 è¡¨ç¤ºå…«è¿›åˆ¶ï¼Œä¸å¸¦å‰ç¼€åˆ™é»˜è®¤è¡¨ç¤ºåè¿›åˆ¶ã€‚\næ•´æ•°å¸¸é‡ä¹Ÿå¯ä»¥å¸¦ä¸€ä¸ªåç¼€ï¼Œåç¼€æ˜¯ U å’Œ L çš„ç»„åˆï¼ŒU è¡¨ç¤ºæ— ç¬¦å·æ•´æ•°ï¼ˆunsignedï¼‰ï¼ŒL è¡¨ç¤ºé•¿æ•´æ•°ï¼ˆlongï¼‰ã€‚åç¼€å¯ä»¥æ˜¯å¤§å†™ï¼Œä¹Ÿå¯ä»¥æ˜¯å°å†™ï¼ŒU å’Œ L çš„é¡ºåºä»»æ„ã€‚\næµ®ç‚¹å¸¸é‡ æµ®ç‚¹å¸¸é‡ç”±æ•´æ•°éƒ¨åˆ†ã€å°æ•°ç‚¹ã€å°æ•°éƒ¨åˆ†å’ŒæŒ‡æ•°éƒ¨åˆ†ç»„æˆã€‚æ‚¨å¯ä»¥ä½¿ç”¨å°æ•°å½¢å¼æˆ–è€…æŒ‡æ•°å½¢å¼æ¥è¡¨ç¤ºæµ®ç‚¹å¸¸é‡ã€‚\nå½“ä½¿ç”¨å°æ•°å½¢å¼è¡¨ç¤ºæ—¶ï¼Œå¿…é¡»åŒ…å«æ•´æ•°éƒ¨åˆ†ã€å°æ•°éƒ¨åˆ†ï¼Œæˆ–åŒæ—¶åŒ…å«ä¸¤è€…ã€‚å½“ä½¿ç”¨æŒ‡æ•°å½¢å¼è¡¨ç¤ºæ—¶ï¼Œ å¿…é¡»åŒ…å«å°æ•°ç‚¹ã€æŒ‡æ•°ï¼Œæˆ–åŒæ—¶åŒ…å«ä¸¤è€…ã€‚å¸¦ç¬¦å·çš„æŒ‡æ•°æ˜¯ç”¨ e æˆ– E å¼•å…¥çš„ã€‚\nå­—ç¬¦å¸¸é‡ å•å¼•å·å†… char -\u0026gt; 1å­—èŠ‚ è½¬ä¹‰å­—ç¬¦ \\n æ¢è¡Œç¬¦å· \\b é€€æ ¼ \\ (ç‰¹æ®Šç¬¦å·) æœ¬èº« å­—ç¬¦ä¸²å¸¸é‡ åŒå¼•å·ä¸­\nå¤šè¡Œæ—¶\nå®šä¹‰å¸¸é‡ 1 2 //name=value #define name value å˜é‡ å˜é‡åå¯ä»¥æ˜¯å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿çš„ç»„åˆ\nè§„åˆ™\nå¼€å¤´å¿…é¡»æ˜¯å­—æ¯æˆ– ä¸‹åˆ’çº¿ï¼ˆå¯ä»¥ä¸‹åˆ’çº¿ï¼‰ ä¸å¯ä»¥æ˜¯Cè¯­è¨€å…³é”®å­— ä¸èƒ½æœ‰ç©ºæ ¼ ç±»å‹è½¬æ¢ æ˜¾ç¤ºè½¬æ¢ 1 2 3 c=1.2F b=(int)c //è¦æ³¨æ„åœ¨cä¸­å¼ºåˆ¶è½¬æ¢ä¸æ˜¯ä¸€ä¸ªå‡½æ•°å¼è½¬æ¢ éšå¼è½¬æ¢ æ–¹å‘ï¼š ç²¾åº¦ä¸Šå‡ ç‰¹æ®Šï¼š scanf/printf åªèƒ½int-chrè½¬æ¢(ç²¾åº¦ä¸Šå‡çš„è½¬æ¢éƒ½ä¸è¡Œï¼Ÿ) char - int è½¬æ¢(æ˜¾/éš) è¯¦è§å­—ç¬¦ascii å‚¨å­˜ç±»ï¼ˆä¸è€ƒï¼‰ è¿ç®—ç¬¦ ç®—æ•°è¿ç®—ç¬¦ + - * / å°å¿ƒéšå¼è½¬æ¢ï¼ˆåŠ å‡ä¹Ÿä¼šï¼‰ é™¤æ³•å–å…¨èˆå»ï¼ˆè´Ÿæ—¶åå‘ç»å¯¹å€¼ï¼‰ 1 2 3 //ä¾‹å¦‚ 10/3==-3; 10/(-3)==-3 å–æ¨¡ % åœ¨ç®—æ³•ä¸­å¸¸/ä¸%ä½¿ç”¨ä¾æ¬¡å»ä½æ•°\n(é«˜ç²¾åº¦æ¨¡æ¿é¢˜)\n++\u0026ndash; è‡ªå¢è‡ªå‡ æ³¨æ„Attentionï¼\na++ å…ˆèµ‹å€¼åè¿ç®—\n++a å…ˆè¿ç®—åèµ‹å€¼\nèµ‹å€¼è¿ç®—ç¬¦ å½¢å¼ï¼š (ç®—æ•°è¿ç®—ç¬¦)$=$\nå¦‚ a += 1\nå…³ç³»è¿ç®—ç¬¦\n== != \u0026gt; \u0026lt; \u0026lt;= \u0026gt;= æ³¨æ„Attentionï¼\nåœ¨cä¸­ä¸èƒ½1\u0026lt;a\u0026lt;bè¿™æ ·åˆ¤æ–­\né€»è¾‘è¿ç®—ç¬¦ ä¸ \u0026amp;\u0026amp; æˆ– || é ! ä½è¿ç®—ç¬¦å·\nè¯¦è§ ä½è¿ç®— è¾“å…¥è¾“å‡º è¾“å…¥æµ stdin æœªè¯»å–çš„ä¸ä¼šæ¸…ç©ºï¼Œå…±äº«\n1 2 3 4 5 6 //æ‰‹åŠ¨æ¸…ç©ºè¾“å…¥æµ //é€šè¿‡è¿ç»­è¯»å–æ¥æ¸…ç©ºè¾“å…¥æµ int r=getchar(); while (r!=EOF){ r=getchar() } è¾“å‡ºæµ stdout è¿ç»­ï¼Œä¸ä¼šè‡ªåŠ¨æ¢è¡Œ -\u0026gt; \\nçš„é‡è¦æ€§\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int main(){ char a; //å…¶å®getchar()è¿”å›çš„æ˜¯intï¼Œä¸è¿‡ç”±äºchar-intçš„éšå¼è½¬æ¢ï¼Œä¹Ÿæ— æ‰€è°“ //æ¯å½“æŒ‰ä¸‹å›è½¦æ—¶getcharä¼šè¯»å–stdinä¸­ç¬¬ä¸€ä¸ªï¼Œå¹¶å°†å…¶ä»stdinä¸­å¼¹å‡º a=getchar(); //putchar æ¥æ”¶çš„ä¹Ÿæ˜¯int putchar(a); //scanf è®°å¾—å ä½ç¬¦æ­£ç¡®å’Œå†™å¯»åœ°å€ç¬¦ //å½“ç„¶æ•°ç»„åæœ¬èº«å³ä½¿åœ°å€ï¼Œä¸è¦å¯»åœ°å€ç¬¦ //æ¯å½“æŒ‰ä¸‹å›è½¦æ—¶getcharä¼šè¯»å–stdinä¸­å‰nä¸ªï¼ˆå–å†³äºå ä½ç¬¦ï¼‰ï¼Œå¹¶å°†å…¶ä»stdinä¸­å¼¹å‡º scanf(\u0026#34;%c\u0026#34;,\u0026amp;a); //ä¸€èˆ¬å‡½æ•°æœ€åè¾“å‡ºç»“å°¾éƒ½ä¼šåŠ ä¸Š\\n printf(\u0026#34;%c\\n\u0026#34;,a); return 0; } å ä½ç¬¦ å ä½ç¬¦ ç±»å‹ %d int %c char %s str(char[]) %f float %.3f 3ä½ %lf double %p pointer å­—ç¬¦ascii 32 ç©ºæ ¼ 48-57 æ•°å­—0-9 65-90 å¤§å†™å­—æ¯ 97-122 å°å†™å­—æ¯ 1 2 3 4 5 6 7 8 9 10 // æ ‡å‡†è¾“å…¥è¾“å‡ºåº“ #include \u0026lt;stdio.h\u0026gt; int main(){ //éšå¼è½¬æ¢ 97 a int c = \u0026#39;a\u0026#39;; printf(\u0026#34;%c %d\u0026#34;,c,c); //åœ¨cä¸­å–asciiç å€¼å¯ç›´æ¥ç±»å‹è½¬æ¢å¾—å‡º //è€Œç”±â€œ11â€(str)å–å¾—11(int)å¯è°ƒåº“ï¼Œæˆ–è€…å“ˆå¸Œæ˜ å°„ï¼ˆè‡ªå»ºæ•°ç»„ä¸‹è¡¨æ˜ å°„æˆ–è€…asciiæ˜ å°„(+48)) return 0; } æ›´å¤šè¾“å…¥è¾“å‡º è¯¦è§å­—ç¬¦ä¸²\næ–‡ä»¶è¯»å†™ æ–‡ä»¶æ‰“å¼€å’Œå…³é—­ ä¸è¦å¿˜è®°å…³é—­æ–‡ä»¶\n1 2 3 4 // open FILE *fopen( const char *filename, const char *mode ); // close fclose( FILE *fp ); filename æ–‡ä»¶è·¯å¾„ mode è®¿é—®æ¨¡å¼ mode description r read åªè¯» w write åªå†™ï¼Œé‡å†™/æ–°å»º(ä¼šè¦†ç›–) a add åªå†™ï¼Œè¿½åŠ /æ–°å»º(ä¸ä¼šè¦†ç›–) r+ è¯»å†™ w+ è¯»å†™ï¼Œé‡å†™/æ–°å»º(ä¼šè¦†ç›–) a+ è¯»å†™ï¼Œè¿½åŠ /æ–°å»º(ä¸ä¼šè¦†ç›–) äºŒè¿›åˆ¶æ¨¡å¼ \u0026ldquo;rb\u0026rdquo;, \u0026ldquo;wb\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;rb+\u0026rdquo;, \u0026ldquo;r+b\u0026rdquo;, \u0026ldquo;wb+\u0026rdquo;, \u0026ldquo;w+b\u0026rdquo;, \u0026ldquo;ab+\u0026rdquo;, \u0026ldquo;a+b\u0026rdquo;\nEOF 1 2 //åœ¨cä¸­EOFæ ‡è¯†ç¬¦å®é™…ä¸º-1 #define EOF -1 è¯»å–æ–‡ä»¶ æ³¨æ„fscanf()å…ˆè¦ä¼ å…¥fpï¼Œå’Œå…¶å®ƒç›¸å\n1 2 3 4 //char *buf ä¸ºç¼“å†²åŒºï¼ˆè‡ªå·±å¼€ä¸€ä¸ªæ•°ç»„ï¼‰ int fgetc( FILE * fp ); char *fgets( char *buf, int n, FILE *fp ); int fscanf(FILE *fp ,const char *s, char *buf); å‡½æ•° fgets() ä» fp æ‰€æŒ‡å‘çš„è¾“å…¥æµä¸­è¯»å– n - 1 ä¸ªå­—ç¬¦ã€‚å®ƒä¼šæŠŠè¯»å–çš„å­—ç¬¦ä¸²å¤åˆ¶åˆ°ç¼“å†²åŒº bufï¼Œå¹¶åœ¨æœ€åè¿½åŠ ä¸€ä¸ª null å­—ç¬¦æ¥ç»ˆæ­¢å­—ç¬¦ä¸²ã€‚å¦‚æœè¿™ä¸ªå‡½æ•°åœ¨è¯»å–æœ€åä¸€ä¸ªå­—ç¬¦ä¹‹å‰å°±é‡åˆ°ä¸€ä¸ªæ¢è¡Œç¬¦ \u0026lsquo;\\n\u0026rsquo; æˆ–æ–‡ä»¶çš„æœ«å°¾ EOFï¼Œåˆ™åªä¼šè¿”å›è¯»å–åˆ°çš„å­—ç¬¦ï¼ŒåŒ…æ‹¬æ¢è¡Œç¬¦ int fscanf(FILE *fp, const char *format, \u0026hellip;) å‡½æ•°æ–‡ä»¶ä¸­è¯»å–å­—ç¬¦ä¸²åœ¨é‡åˆ°ç¬¬ä¸€ä¸ªç©ºæ ¼å’Œæ¢è¡Œç¬¦æ—¶ï¼Œä¼šåœæ­¢è¯»å–\nå†™å…¥æ–‡ä»¶ æ³¨æ„fprintf()å…ˆè¦ä¼ å…¥fpï¼Œå’Œå…¶å®ƒç›¸å\n1 2 3 4 // å¤±è´¥æ—¶è¿”å›EOF int fputc( int c, FILE *fp ); int fputs( const char *s, FILE *fp ); int fprintf(FILE * fp,const char*s); äºŒè¿›åˆ¶è¯»å†™ 1 2 fread(); fwrite(); äºŒè¿›åˆ¶ æ¯”ç‰¹ä¸å­—èŠ‚ bit äºŒè¿›åˆ¶ä¸€ä¸ªæ•°ä½ 1 byte = 8 bit è¿›åˆ¶è½¬æ¢ 10è¿›åˆ¶-\u0026gt;2è¿›åˆ¶ï¼š é™¤2æ³•å–ä½™æ•° 2è¿›åˆ¶-\u0026gt;10è¿›åˆ¶ï¼š ä»å³åˆ°å·¦ä¾æ¬¡ä¹˜ä»$2^0$å¼€å§‹åˆ°$2^n$çš„å’Œ\nä½è¿ç®— ä¸ \u0026amp; æˆ– | å–å ~ å¼‚æˆ– ^ å·¦å³ç§» \u0026laquo;\u0026lt; \u0026raquo;\u0026gt; 1 2 3 4 5 6 int a=4; //äºŒè¿›åˆ¶å³ç§»1ä½å³é™¤ä»¥2ï¼Œå·¦ä¸€ä¹˜ä»¥2 //åŒç†ï¼Œåè¿›åˆ¶åˆ™1ä½ä¹˜é™¤10ï¼Œæ³¨æ„cä¸­å·¦å³ç§»ç¬¦å·æ˜¯äºŒè¿›åˆ¶çš„ç§»åŠ¨ if (a\u0026gt;\u0026gt;1==a/2){ printf(\u0026#34;True\u0026#34;); } å¸¸è§æ€§è´¨(ç•¥) äºŒè¿›åˆ¶ç®—æ³• äºŒè¿›åˆ¶æšä¸¾ å¿«é€Ÿå¹‚ åŸºç¡€ç»“æ„ åˆ†æ”¯ç»“æ„ 1 2 3 4 5 6 7 8 9 10 11 12 13 //åˆ†æ”¯ if (){ } else if (){ } else{ } //ä¸‰å…ƒ a==0?printf(\u0026#34;a=0\u0026#34;):printf(\u0026#34;a!=0\u0026#34;); !!!æ³¨æ„\nå¦‚æœswitchæ²¡æœ‰breakåˆ™ä¼šç»§ç»­æ‰§è¡Œï¼ˆä¼šè§¦å‘defaultæˆ–è€…å…¶å®ƒcaseï¼‰\nexpressionå¿…é¡»æ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Œå¿…é¡»æ˜¯ä¸€ä¸ªæ•´å‹æˆ–æšä¸¾ç±»å‹\n1 2 3 4 5 6 7 8 9 10 11 12 switch(expression){ case constant-expression : statement(s); break; /* å¯é€‰çš„ */ case constant-expression : statement(s); break; /* å¯é€‰çš„ */ /* æ‚¨å¯ä»¥æœ‰ä»»æ„æ•°é‡çš„ case è¯­å¥ */ default : /* å¯é€‰çš„ */ statement(s); } å¾ªç¯ç»“æ„ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int a=10; while(1){ a--; if (a\u0026gt;5){ continue; } printf(\u0026#34;NO\u0026#34;) if (a\u0026lt;4) break; } for(a=10;a\u0026lt;3;a--){ printf(\u0026#34;%d,a\u0026#34;); } do{ printf(\u0026#34;%d\u0026#34;,a); a-=1 }while(a); çœç•¥ å¦‚æœåªè·Ÿä¸€ä¸ªå¥å­ï¼Œå¯ä»¥çœç•¥å¤§æ‹¬å· å•æ•°å­—ä½œä¸ºæ¡ä»¶æ—¶0å‡å…¶å®ƒçœŸ å¦‚ä¸‹é¢çš„å¥å­æ˜¯åˆæ³•çš„\n1 2 3 4 5 6 7 8 9 10 for(int i=0;i\u0026lt;10;i++) for(int j=i;j\u0026lt;10;j++) printf(\u0026#34;%d\u0026#34;,j); if(a==0) printf(\u0026#34;YES!!!\u0026#34;); int a=0; if(!a){ printf(\u0026#34;a is zero\u0026#34;); } æ•°ç»„ä¸å­—ç¬¦ä¸² ä¸€ç»´æ•°ç»„ å£°æ˜æ ¼å¼ type arrayName [ arraySize ]; 1 int a[50]; åˆå§‹åŒ–(å¤§æ‹¬å·) 1 2 3 4 5 6 7 8 9 //æ ‡å‡†åˆå§‹åŒ– int a[2]={1,2}; //å¯ä»¥åªåˆå§‹åŒ–å°‘åˆå§‹åŒ–ï¼Œä½†ä¸èƒ½å¤šåˆå§‹åŒ– //å³å¤§æ‹¬å· { } ä¹‹é—´çš„å€¼çš„æ•°ç›®ä¸èƒ½å¤§äºæˆ‘ä»¬åœ¨æ•°ç»„å£°æ˜æ—¶åœ¨æ–¹æ‹¬å· [ ] ä¸­æŒ‡å®šçš„å…ƒç´ æ•°ç›® int a[10]={1,4,3,5}; //å¦‚æœæ²¡æœ‰æŒ‡å®šæ•°ç»„å¤§å°ï¼Œåˆ™å…¶ç­‰äºåˆå§‹åŒ–ä¸ªæ•° int a[]={1,2,4}; ä¸¤ç§è®¿é—® ä¸‹æ ‡ï¼ˆç´¢å¼•ï¼‰ä»0å¼€å§‹ æŒ‡é’ˆè®¿é—®ï¼ˆæ•°ç»„åæŒ‡å‘æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ çš„åœ°å€ï¼Œæ•°ç»„å‚¨å­˜è¿ç»­ï¼‰ è¯¦è§æŒ‡é’ˆ é«˜ç»´æ•°ç»„ å£°æ˜ä¸åˆå§‹åŒ–\n(è¦è®°å¾—å¤§å°ä»1å¼€å§‹ï¼Œä½†ç´¢å¼•ä»0å¼€å§‹) 1 2 3 4 5 // int a[2][2][2]; // // int a[2][3]={1,2,3,2,4,6} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 - ä¸¤ç§è®¿é—® - ä¸‹æ ‡ï¼ˆç´¢å¼•ï¼‰ä»0å¼€å§‹ - æŒ‡é’ˆè®¿é—® - åˆ—æŒ‡é’ˆä¸è¡ŒæŒ‡é’ˆ - å•æŒ‡é’ˆï¼ˆåˆ©ç”¨è¿ç»­æ€§ï¼‰ [è¯¦è§æŒ‡é’ˆ](#æŒ‡é’ˆ) ### å­—ç¬¦ä¸² \u0026gt;everal ways to initialize a string **ä¸€å®š**ä»¥ ***\u0026#39;\\0\u0026#39;*** ç»“å°¾ + char str[20] = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\0\u0026#39;}; + char str[20] = \u0026#34;Hello\u0026#34;; // \u0026#39;\\0\u0026#39; is automatically set to str[5] + char str[] = \u0026#34;Hello\u0026#34;; //str\u0026#39;s size is 6 å¦‚æœå·²ç»å£°æ˜ï¼Œå°±ä¸èƒ½è¿›è¡Œ**åˆå§‹åŒ–** #### æ˜“é”™ç»ƒä¹  æ˜¯å¦æ­£ç¡®ï¼Ÿ ```c //æ³¨æ„å­—ç¬¦å’Œå­—ç¬¦ä¸²çš„å¼•å· //æ³¨æ„éšå¼è½¬æ¢ char a[]={\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,0} å­—ç¬¦ä¸²ç›¸å…³ \u0026lt;stdio.h\u0026gt; printf() %s\nsprintf() 1 2 3 4 5 6 7 8 int sprintf( char *str, const char *format, ... ); char buffer[50]; int n, a = 5, b = 3; n = sprintf(buffer, \u0026#34;%d plus %d is %d\u0026#34;, a, b, a+b); // n å®é™…é•¿åº¦13 //buffer=\u0026#34;5 plus 3 is 8\u0026#34; puts() puts stops printing when it meets \u0026lsquo;\\0\u0026rsquo;.\nscanf() %s è¯»åˆ°ç©ºæ ¼åœæ­¢ %ns è¯»åˆ°ç©ºæ ¼/è¯»nä¸ªå­—ç¬¦åœæ­¢ gets() è¯»ä¸€æ•´è¡Œï¼Œå­—ç¬¦æ•°ç»„å¼€å°äº†å¯èƒ½è¶Šç•Œ\nfgets() fgets(your_line, sizeof(your_line), stdin)\nåˆ©ç”¨sizeof ï¼Œé˜²æ­¢è¶Šç•Œ\nå­—ç¬¦ä¸²ç›¸å…³ \u0026lt;string.h\u0026gt; strlen() length of str, not including \u0026lsquo;\\0\u0026rsquo;;\nstrcpy(destination,source) å­—ç¬¦ä¸²èµ‹å€¼è¦strcpyï¼Œåˆ«ç›´æ¥ç­‰äºå·èµ‹å€¼\ncopy string from source to destination(åŒ…æ‹¬\u0026rsquo;\\0\u0026rsquo;)\nå°å¿ƒè¶Šç•Œ\nstrncpy(destination, source, n) å¤åˆ¶å‰nä¸ªå­—ç¬¦ï¼Œæœ€åè‡ªåŠ¨åŠ ä¸Š\u0026rsquo;\\0\u0026rsquo;\nstrcmp(str1, str2) é€ä½æ¯”è¾ƒasciiï¼Œç›´åˆ°æŸä¸€ä½asciiä¸ä¸€æ ·ï¼Œstr1\u0026gt;str2 è¿”å› 1ï¼Œç›¸ç­‰è¿”å›0ï¼Œå…¶ä½™-1\nstrncmp(str1, str2, n) å‰nä¸ª\nstrcat(destination, source); è¿æ¥ï¼ŒåŠ åœ¨destä¸Šï¼Œå°å¿ƒè¶Šç•Œ\nå­—ç¬¦ä¸²ç›¸å…³ \u0026lt;stdlib.h\u0026gt; atoi(str) str-\u0026gt;int\næ”¯æŒæ­£è´Ÿå·\nå–å‰é¢å¯ä»¥è½¬æ¢çš„ï¼Œåˆ°éæ•°å­—å­—ç¬¦åœæ­¢(æ— è§†ç©ºæ ¼) ex. atoi(\u0026quot;-10aaa\u0026quot;)=-10\natof(str) â€¢ Same as atoi\nâ€¢ Space, +, - are acceptable\nâ€¢ An E or e (exponent) is acceptable\nâ€¢ A decimal point is acceptable\nç›¸å…³ç®—æ³•ï¼ˆä»…ä½œäº†è§£ï¼‰ BFï¼ŒBKï¼ŒKMPï¼ŒBM å‰ç¼€æ ‘ åç¼€æ ‘ ACè‡ªåŠ¨æœº å…¶å®ƒ åŸºç¡€è¯­æ³• å‡½æ•° å‡½æ•°çš„å£°æ˜ å¦‚æœå‡½æ•°æ”¾äºmainå‡½æ•°åé¢/å¤šæ–‡ä»¶ï¼Œéœ€è¦æå‰å£°æ˜ å£°æ˜æ—¶å‚æ•°çš„åç§°å¹¶ä¸é‡è¦ï¼Œåªæœ‰å‚æ•°çš„ç±»å‹æ˜¯å¿…éœ€çš„ï¼Œå› æ­¤ä»¥ä¸‹éƒ½æ˜¯éƒ½æ˜¯æœ‰æ•ˆå£°æ˜ 1 2 int max(int, int); int max(int a, int b); void æ— è¿”å›å€¼ è¿”å›å¤šä¸ªå€¼ åˆ©ç”¨æŒ‡é’ˆ å½¢å¼å‚æ•° è¯¦è§ä½œç”¨åŸŸ ä¼ é€’æ•°ç»„ ä¼ ä¸€ä¸ªæŒ‡é’ˆ ä¼ ä¸å®šé•¿æ•°ç»„(ex. int a[],å¦‚æœäºŒç»´éœ€è¦æŒ‡å®šç¬¬äºŒç»´åº¦ï¼Œint a[][3]) ä¼ å®šé•¿æ•°ç»„(int a[20]) #defineå‡½æ•° 1 2 #define MAX(a,b) a\u0026gt;b?a:b #define SQ(x) x*x ä½œç”¨åŸŸ 3 types åœ¨å‡½æ•°æˆ–å—å†…éƒ¨çš„å±€éƒ¨å˜é‡,åœ¨æ‰€æœ‰å‡½æ•°å¤–éƒ¨çš„å…¨å±€å˜é‡,åœ¨å½¢å¼å‚æ•°çš„å‡½æ•°å‚æ•°å®šä¹‰ä¸­\nsmall has big å°å¯ä»¥æ”¹å¤§çš„ï¼Œå¤§ä¸èƒ½æ”¹å°çš„\nå½¢å‚åŒåæ›¿ä»£ï¼ˆå°å¸¦å¤§ï¼‰ ä½†æ˜¯åœ¨å‡½æ•°å†…ï¼Œå¦‚æœä¸¤ä¸ªåå­—ç›¸åŒï¼Œä¼šä½¿ç”¨å±€éƒ¨å˜é‡å€¼ï¼Œå…¨å±€å˜é‡ä¸ä¼šè¢«ä½¿ç”¨\né€’å½’ æ‡‚å¾—éƒ½æ‡‚ â€”â€”ä½šå è‡ªé¡¶å‘ä¸‹,åˆ©ç”¨ç³»ç»Ÿæ ˆ\nç»å…¸é¢˜ æ–æ³¢é‚£å¥‘ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int Fibonacci(int n){ if (n\u0026lt;=2){ return 1; } return Fibonacci(n-1)+Fibonacci(n-2); } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;%d\u0026#34;,Fibonacci(n)); return 0; } å‘½ä»¤è¡Œå‚æ•° 1 2 3 int main(int argc, char *argv[] ){ return 0; } argc å­˜æ”¾å‘½ä»¤è¡Œå‚æ•°çš„ä¸ªæ•° *argv[] ä»argv[1]å¼€å§‹å­˜æ”¾æ¯ä¸€ä¸ªå‚æ•°çš„æŒ‡é’ˆï¼Œç¬¬ä¸€ä¸ªå³argv[0]å­˜æ”¾ç¨‹åºå å¤šæ–‡ä»¶ æ„æˆ å®æ–‡ä»¶ï¼ˆxxx.hï¼‰ æ–‡ä»¶å­˜æ”¾å£°æ˜\nxxx.c æ–‡ä»¶å­˜æ”¾å‡½æ•°\nä¸»å‡½æ•°é‡Œ #include\u0026quot;xxx.h\u0026quot;\nè¿›é˜¶è¯­æ³• æŒ‡é’ˆ ç»“æ„ä½“ ç»“æ„ä½“å®šä¹‰ä¸åˆå§‹åŒ– 1 2 3 4 5 6 7 8 9 10 11 12 13 //ä¸€ä¸ªå®Œæ•´ç»“æ„ä½“çš„example struct tag1{ int a; char b[30]; }variable1={1,\u0026#34;ssss\u0026#34;}; struct tag1 variable2; typedef struct{ float f; }tag2; tag2 variable3; ï¼ï¼ï¼æ³¨æ„ï¼ï¼ï¼\næ— è®ºå¦‚ä½•structç»“å°¾å¿…é¡»æœ‰åˆ†å· typedefæ ¼å¼å›ºå®šï¼Œä¸‹é¢ä¸æ˜¯å˜é‡è€Œæ˜¯æ ‡ç­¾ å¦‚æœå˜é‡å·²ç»å£°æ˜ï¼Œå°±ä¸èƒ½è¿›è¡Œåˆå§‹åŒ– 1 2 3 4 5 6 7 8 9 10 11 //æ— typedefæ—¶ä¸‹é¢ä¸€å®šæ˜¯å˜é‡ï¼ˆæ— æ ‡ç­¾ï¼‰ struct { int a; }VARIABLE; //ä¸‹é¢ä¸€å®šæ˜¯tag //tag ä¸èƒ½æ”¾ä¸Šé¢ //å®è´¨ typedef struct{int a;} TAG; //ç±»åŒ typedef unsigned char UC; typedef struct{ int a; }TAG; ç»“æ„ä½“å†…éƒ¨å…ƒç´ èµ‹å€¼ 1 2 3 4 5 6 7 8 9 struct day{ char feeling[100]; int time; }today; today.time=222; strcpy(today.feeling,\u0026#34;dddd\u0026#34;); struct day yesterday={\u0026#34;good\u0026#34;,221}; ç»“æ„ä½“æŒ‡é’ˆ æ¥ç€ä¸Šæ–‡å®šä¹‰çš„ç»“æ„ä½“\n1 2 3 struct day *check; check=\u0026amp;today printf(\u0026#34;%s\u0026#34;,check-\u0026gt;feeling); ç»“æ„ä½“æ•°ç»„ æ¥ç€ä¸Šæ–‡å®šä¹‰çš„ç»“æ„ä½“\n1 2 3 4 5 6 struct day holiday[60]; int i; for(i=0;i\u0026lt;60;i++){ strcpy(holiday[i].feeling,happy); holiday[i].time=i; } æšä¸¾ç±»å‹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 enum week { MON=1, TUE, WED, THU, FRI, SAT, SUN }day; day=MON; printf(\u0026#34;%d\u0026#34;,day); //è‹¥ä¸åˆå§‹åŒ–MONï¼Œé»˜è®¤ç¬¬ä¸€ä¸ªæ˜¯ 0 //æ³¨æ„ï¼šç¬¬ä¸€ä¸ªæšä¸¾æˆå‘˜çš„é»˜è®¤å€¼ä¸ºæ•´å‹çš„ 0ï¼Œåç»­æšä¸¾æˆå‘˜çš„å€¼åœ¨å‰ä¸€ä¸ªæˆå‘˜ä¸ŠåŠ  1ã€‚ //å¦‚æœæˆ‘ä»¬æŠŠç¬¬3ä¸ªæšä¸¾æˆå‘˜çš„å€¼å®šä¹‰ä¸º 9ï¼Œç¬¬4ä¸ªå°±ä¸º 10ï¼Œä»¥æ­¤ç±»æ¨ï¼Œç¬¬2ä¸ªä¾ç„¶ä¸º1ã€‚ //å¯ä»¥å’Œæ•´å½¢å¼ºåˆ¶è½¬åŒ– int a=1; days=(enum week)a; //days=MON åŠ¨æ€å†…å­˜ å…¥é—¨çº§åŸºç¡€ç®—æ³• æ•°å­¦ æ±‚è´¨æ•° äº†è§£æœ´ç´ è´¨æ•°åˆ¤å®šå³å¯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // æœ´ç´ è´¨æ•°åˆ¤å®š /* å·²ç»å£°æ˜è¿‡ #define true 1 #define false 0 */ int check(int a){ if (a\u0026lt;2){ return false; } int i; for(i=2;i*i\u0026lt;a;i++){ if (a%i==0){ return false; } } return true; } æœ€å¤§å…¬çº¦æ•°\näº†è§£æ¬§å‡ é‡Œå¾—ç®—æ³•å³å¯\n1 2 3 4 int gcd(int a,int b){ if (b==0) return a; return gcd(b, a % b); } æœ€å°å…¬å€æ•°\n$lcm(a,b)gcd(a,b)=ab$\nå…ˆæ±‚å‡ºgcdå³å¯\né«˜ç²¾åº¦ï¼ˆäº†è§£åŠ æ³•å‡æ³•å³å¯ï¼‰\næ’åº ç¨³å®šæ’åº ä¸ç¨³å®šæ’åº è®¡æ•°æ’åº æ¡¶æ’åº qsort() åŒæŒ‡é’ˆ åŒå‘ é€†å‘ æ»‘çª— ","date":"2023-04-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/cstart/","title":"Cè¯­è¨€å¿«é€Ÿå…¥é—¨"},{"content":"ä½è¿ç®— açš„bæ¬¡æ–¹å¯¹på–æ¨¡ å‰ç½®çŸ¥è¯†\nqpow math:$(a+b)%p=(a%p+b%p)%p$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // æ±‚ açš„ bæ¬¡æ–¹å¯¹ på–æ¨¡çš„å€¼ã€‚ // è¾“å…¥æ ¼å¼ // ä¸‰ä¸ªæ•´æ•° a,b,pï¼Œåœ¨åŒä¸€è¡Œç”¨ç©ºæ ¼éš”å¼€ã€‚ // è¾“å‡ºæ ¼å¼ // è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºa^b mod pçš„å€¼ã€‚ // æ•°æ®èŒƒå›´ // 0â‰¤a,bâ‰¤10^9 // 1â‰¤pâ‰¤109 // è¾“å…¥æ ·ä¾‹ï¼š // 3 2 7 // è¾“å‡ºæ ·ä¾‹ï¼š // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; // é˜²æ­¢å½“b=0ï¼Œp=1æ—¶è¢«å¡ res=1%p; while(b){ if(b\u0026amp;1)res=(res*a)%p; a*=a; a%=p; b\u0026gt;\u0026gt;=1; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } a*bå¯¹på–æ¨¡ å‰ç½®çŸ¥è¯†\nqpow math:(a+b)%p=(a%p+b%p)%p 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // æ±‚ a // ä¹˜ b // å¯¹ p // å–æ¨¡çš„å€¼ã€‚ // è¾“å…¥æ ¼å¼ // ç¬¬ä¸€è¡Œè¾“å…¥æ•´æ•°a // ï¼Œç¬¬äºŒè¡Œè¾“å…¥æ•´æ•°b // ï¼Œç¬¬ä¸‰è¡Œè¾“å…¥æ•´æ•°p // ã€‚ // è¾“å‡ºæ ¼å¼ // è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºa*b mod pçš„å€¼ã€‚ // æ•°æ®èŒƒå›´ // 1â‰¤a,b,pâ‰¤1018 // è¾“å…¥æ ·ä¾‹ï¼š // 3 // 4 // 5 // è¾“å‡ºæ ·ä¾‹ï¼š // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res=0; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; while(b){ if(b\u0026amp;1)res=(res+a)%p; b\u0026gt;\u0026gt;=1; a*=2; a%=p; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } æœ€çŸ­Hamiltonè·¯å¾„ å‰ç½®çŸ¥è¯†\næ—…è¡Œå•†é—®é¢˜:NPå®Œå…¨,æ²¡æœ‰å¤šé¡¹å¼æ—¶é—´è§£æ³• ä½è¿ç®— çŠ¶å‹DP bitset:STL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // ç»™å®šä¸€å¼  nä¸ªç‚¹çš„å¸¦æƒæ— å‘å›¾ï¼Œç‚¹ä» 0âˆ¼nâˆ’1æ ‡å·ï¼Œæ±‚èµ·ç‚¹ 0åˆ°ç»ˆç‚¹ nâˆ’1çš„æœ€çŸ­ Hamilton è·¯å¾„ã€‚ // Hamilton è·¯å¾„çš„å®šä¹‰æ˜¯ä» 0åˆ° nâˆ’1ä¸é‡ä¸æ¼åœ°ç»è¿‡æ¯ä¸ªç‚¹æ°å¥½ä¸€æ¬¡ã€‚è¾“å…¥æ ¼å¼ // ç¬¬ä¸€è¡Œè¾“å…¥æ•´æ•° nã€‚ // æ¥ä¸‹æ¥ nè¡Œæ¯è¡Œ nä¸ªæ•´æ•°ï¼Œå…¶ä¸­ç¬¬ iè¡Œç¬¬ jä¸ªæ•´æ•°è¡¨ç¤ºç‚¹ iåˆ° jçš„è·ç¦»ï¼ˆè®°ä¸º a[i,j]ï¼‰ã€‚ // å¯¹äºä»»æ„çš„ x,y,zï¼Œæ•°æ®ä¿è¯ a[x,x]=0ï¼Œa[x,y]=a[y,x]å¹¶ä¸” a[x,y]+a[y,z]â‰¥a[x,z]ã€‚ // è¾“å‡ºæ ¼å¼ // è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºæœ€çŸ­ Hamilton è·¯å¾„çš„é•¿åº¦ã€‚ // æ•°æ®èŒƒå›´ // 1â‰¤nâ‰¤20 // 0â‰¤a[i,j]â‰¤107 // è¾“å…¥æ ·ä¾‹ï¼š // 5 // 0 2 4 5 1 // 2 0 6 5 3 // 4 6 0 8 3 // 5 5 8 0 5 // 1 3 3 5 0 // è¾“å‡ºæ ·ä¾‹ï¼š // 18 #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) #define inf 0x3f const int N=20,M=1\u0026lt;\u0026lt;20; int n; //å¤§æ•°ç»„å¼€åˆ°å…¨å±€é‡Œï¼Œé˜²æ­¢çˆ†æ ˆ //f[i][j]: i:ç»è¿‡çŠ¶æ€ï¼Œj:jç‚¹æœ€çŸ­è·¯ int f[M][N],w[N][N]; int main(){ cin\u0026gt;\u0026gt;n; For(i,0,n){ For(j,0,n){ cin\u0026gt;\u0026gt;w[i][j]; } } memset(f,inf,sizeof(f)); f[1][0]=0; For(i,0,1\u0026lt;\u0026lt;n){ For(j,0,n){ if(i\u0026gt;\u0026gt;j\u0026amp;1){ //int p=i^(1\u0026lt;\u0026lt;j) int p=i-(1\u0026lt;\u0026lt;j); For(k,0,n){ if(p\u0026amp;(1\u0026lt;\u0026lt;k)) // if(p\u0026gt;\u0026gt;k\u0026amp;1) f[i][j]=min(f[i][j],f[p][k]+w[k][j]); } } } } cout\u0026lt;\u0026lt;f[(1\u0026lt;\u0026lt;n)-1][n-1]\u0026lt;\u0026lt;endl; return 0; } èµ·åºŠå›°éš¾ç»¼åˆç—‡ å‰ç½®çŸ¥è¯†\nä½è¿ç®—æ€§è´¨ :ä¸æˆ–éè¿ç®—åœ¨äºŒè¿›åˆ¶è¡¨ç¤ºä¸‹ä¸è¿›ä½ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªbitä¹‹é—´ç‹¬ç«‹ä½è¿ç®— è´ªå¿ƒ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 // 21ä¸–çºªï¼Œè®¸å¤šäººå¾—äº†ä¸€ç§å¥‡æ€ªçš„ç—…ï¼šèµ·åºŠå›°éš¾ç»¼åˆç—‡ï¼Œå…¶ä¸´åºŠè¡¨ç°ä¸ºï¼šèµ·åºŠéš¾ï¼Œèµ·åºŠåç²¾ç¥ä¸ä½³ã€‚ // ä½œä¸ºä¸€åé’æ˜¥é˜³å…‰å¥½å°‘å¹´ï¼Œatm ä¸€ç›´åšæŒä¸èµ·åºŠå›°éš¾ç»¼åˆç—‡ä½œæ–—äº‰ã€‚ // é€šè¿‡ç ”ç©¶ç›¸å…³æ–‡çŒ®ï¼Œä»–æ‰¾åˆ°äº†è¯¥ç—…çš„å‘ç—…åŸå› ï¼š åœ¨æ·±é‚ƒçš„å¤ªå¹³æ´‹æµ·åº•ä¸­ï¼Œå‡ºç°äº†ä¸€æ¡åä¸º drd çš„å·¨é¾™ï¼Œå®ƒæŒæ¡ç€ç¡çœ ä¹‹ç²¾é«“ï¼Œèƒ½éšæ„å»¶é•¿å¤§å®¶çš„ç¡çœ æ—¶é—´ã€‚ // æ­£æ˜¯ç”±äº drd çš„æ´»åŠ¨ï¼Œèµ·åºŠå›°éš¾ç»¼åˆç—‡æ„ˆæ¼”æ„ˆçƒˆï¼Œ ä»¥æƒŠäººçš„é€Ÿåº¦åœ¨ä¸–ç•Œä¸Šä¼ æ’­ã€‚ // ä¸ºäº†å½»åº•æ¶ˆç­è¿™ç§ç—…ï¼Œatm å†³å®šå‰å¾€æµ·åº•ï¼Œæ¶ˆç­è¿™æ¡æ¶é¾™ã€‚ // å†ç»åƒè¾›ä¸‡è‹¦ï¼Œatm ç»ˆäºæ¥åˆ°äº† drd æ‰€åœ¨çš„åœ°æ–¹ï¼Œå‡†å¤‡ä¸å…¶å±•å¼€è‰°è‹¦å“ç»çš„æˆ˜æ–—ã€‚ // drd æœ‰ç€ååˆ†ç‰¹æ®Šçš„æŠ€èƒ½ï¼Œä»–çš„é˜²å¾¡æˆ˜çº¿èƒ½å¤Ÿä½¿ç”¨ä¸€å®šçš„è¿ç®—æ¥æ”¹å˜ä»–å—åˆ°çš„ä¼¤å®³ã€‚ // å…·ä½“è¯´æ¥ï¼Œdrd çš„é˜²å¾¡æˆ˜çº¿ç”± næ‰‡é˜²å¾¡é—¨ç»„æˆã€‚ // æ¯æ‰‡é˜²å¾¡é—¨åŒ…æ‹¬ä¸€ä¸ªè¿ç®— op // å’Œä¸€ä¸ªå‚æ•° t ï¼Œå…¶ä¸­è¿ç®—ä¸€å®šæ˜¯ OR,XOR,ANDä¸­çš„ä¸€ç§ï¼Œå‚æ•°åˆ™ä¸€å®šä¸ºéè´Ÿæ•´æ•°ã€‚ // å¦‚æœè¿˜æœªé€šè¿‡é˜²å¾¡é—¨æ—¶æ”»å‡»åŠ›ä¸º x // åˆ™å…¶é€šè¿‡è¿™æ‰‡é˜²å¾¡é—¨åæ”»å‡»åŠ›å°†å˜ä¸º x op t // æœ€ç»ˆ drd å—åˆ°çš„ä¼¤å®³ä¸ºå¯¹æ–¹åˆå§‹æ”»å‡»åŠ› x // ä¾æ¬¡ç»è¿‡æ‰€æœ‰ næ‰‡é˜²å¾¡é—¨åè½¬å˜å¾—åˆ°çš„æ”»å‡»åŠ›ã€‚ // ç”±äº atm æ°´å¹³æœ‰é™ï¼Œä»–çš„åˆå§‹æ”»å‡»åŠ›åªèƒ½ä¸º 0 // åˆ° mä¹‹é—´çš„ä¸€ä¸ªæ•´æ•°ï¼ˆå³ä»–çš„åˆå§‹æ”»å‡»åŠ›åªèƒ½åœ¨ 0,1,â€¦,mä¸­ä»»é€‰ï¼Œ // ä½†åœ¨é€šè¿‡é˜²å¾¡é—¨ä¹‹åçš„æ”»å‡»åŠ›ä¸å— mçš„é™åˆ¶ï¼‰ã€‚ // ä¸ºäº†èŠ‚çœä½“åŠ›ï¼Œä»–å¸Œæœ›é€šè¿‡é€‰æ‹©åˆé€‚çš„åˆå§‹æ”»å‡»åŠ›ä½¿å¾—ä»–çš„æ”»å‡»èƒ½è®© drd å—åˆ°æœ€å¤§çš„ä¼¤å®³ï¼Œè¯·ä½ å¸®ä»–è®¡ç®—ä¸€ä¸‹ï¼Œä»–çš„ä¸€æ¬¡æ”»å‡»æœ€å¤šèƒ½ä½¿ drd å—åˆ°å¤šå°‘ä¼¤å®³ã€‚ // è¾“å…¥æ ¼å¼ // ç¬¬ 1è¡ŒåŒ…å« 2ä¸ªæ•´æ•°ï¼Œä¾æ¬¡ä¸º n,mï¼Œè¡¨ç¤º drd æœ‰ næ‰‡é˜²å¾¡é—¨ï¼Œatm çš„åˆå§‹æ”»å‡»åŠ›ä¸º 0åˆ° mä¹‹é—´çš„æ•´æ•°ã€‚ // æ¥ä¸‹æ¥ n è¡Œï¼Œä¾æ¬¡è¡¨ç¤ºæ¯ä¸€æ‰‡é˜²å¾¡é—¨ã€‚æ¯è¡ŒåŒ…æ‹¬ä¸€ä¸ªå­—ç¬¦ä¸² op å’Œä¸€ä¸ªéè´Ÿæ•´æ•° t ï¼Œä¸¤è€…ç”±ä¸€ä¸ªç©ºæ ¼éš”å¼€ï¼Œä¸” op åœ¨å‰ï¼Œt åœ¨åï¼Œop è¡¨ç¤ºè¯¥é˜²å¾¡é—¨æ‰€å¯¹åº”çš„æ“ä½œï¼Œt è¡¨ç¤ºå¯¹åº”çš„å‚æ•°ã€‚ // è¾“å‡ºæ ¼å¼ // è¾“å‡ºä¸€ä¸ªæ•´æ•°ï¼Œè¡¨ç¤º atm çš„ä¸€æ¬¡æ”»å‡»æœ€å¤šä½¿ drd å—åˆ°å¤šå°‘ä¼¤å®³ã€‚ // æ•°æ®èŒƒå›´ // QQæˆªå›¾20190907125839.png // è¾“å…¥æ ·ä¾‹ï¼š // 3 10 // AND 5 // OR 6 // XOR 7 // è¾“å‡ºæ ·ä¾‹ï¼š // 1 // æ ·ä¾‹è§£é‡Š // atmå¯ä»¥é€‰æ‹©çš„åˆå§‹æ”»å‡»åŠ›ä¸º 0,1,â€¦,10 // å‡è®¾åˆå§‹æ”»å‡»åŠ›ä¸º 4ï¼Œæœ€ç»ˆæ”»å‡»åŠ›ç»è¿‡äº†å¦‚ä¸‹è®¡ç®— // 4 AND 5 = 4 // 4 OR 6 = 6 // 6 XOR 7 = 1 //ç±»ä¼¼çš„ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—å‡ºåˆå§‹æ”»å‡»åŠ›ä¸º 1,3,5,7,9 æ—¶æœ€ç»ˆæ”»å‡»åŠ›ä¸º 0 ï¼Œåˆå§‹æ”»å‡»åŠ›ä¸º 0,2,4,6,8,10 æ—¶æœ€ç»ˆæ”»å‡»åŠ›ä¸º 1 ï¼Œå› æ­¤ atm çš„ä¸€æ¬¡æ”»å‡»æœ€å¤šä½¿ drd å—åˆ°çš„ä¼¤å®³å€¼ä¸º 1 ã€‚ // è¿ç®—è§£é‡Š // åœ¨æœ¬é¢˜ä¸­ï¼Œé€‰æ‰‹éœ€è¦å…ˆå°†æ•°å­—å˜æ¢ä¸ºäºŒè¿›åˆ¶åå†è¿›è¡Œè®¡ç®—ã€‚å¦‚æœæ“ä½œçš„ä¸¤ä¸ªæ•°äºŒè¿›åˆ¶é•¿åº¦ä¸åŒï¼Œåˆ™åœ¨å‰è¡¥ 0 // è‡³ç›¸åŒé•¿åº¦ã€‚ // OR ä¸ºæŒ‰ä½æˆ–è¿ç®—ï¼Œå¤„ç†ä¸¤ä¸ªé•¿åº¦ç›¸åŒçš„äºŒè¿›åˆ¶æ•°ï¼Œä¸¤ä¸ªç›¸åº”çš„äºŒè¿›åˆ¶ä½ä¸­åªè¦æœ‰ä¸€ä¸ªä¸º 1ï¼Œåˆ™è¯¥ä½çš„ç»“æœå€¼ä¸º 1ï¼Œå¦åˆ™ä¸º 0ã€‚ // XOR ä¸ºæŒ‰ä½å¼‚æˆ–è¿ç®—ï¼Œå¯¹ç­‰é•¿äºŒè¿›åˆ¶æ¨¡å¼æˆ–äºŒè¿›åˆ¶æ•°çš„æ¯ä¸€ä½æ‰§è¡Œé€»è¾‘å¼‚æˆ–æ“ä½œã€‚å¦‚æœä¸¤ä¸ªç›¸åº”çš„äºŒè¿›åˆ¶ä½ä¸åŒï¼ˆç›¸å¼‚ï¼‰ï¼Œåˆ™è¯¥ä½çš„ç»“æœå€¼ä¸º 1ï¼Œå¦åˆ™è¯¥ä½ä¸º 0 // AND ä¸ºæŒ‰ä½ä¸è¿ç®—ï¼Œå¤„ç†ä¸¤ä¸ªé•¿åº¦ç›¸åŒçš„äºŒè¿›åˆ¶æ•°ï¼Œä¸¤ä¸ªç›¸åº”çš„äºŒè¿›åˆ¶ä½éƒ½ä¸º 1ï¼Œè¯¥ä½çš„ç»“æœå€¼æ‰ä¸º 1ï¼Œå¦åˆ™ä¸º 0 // ä¾‹å¦‚ï¼Œæˆ‘ä»¬å°†åè¿›åˆ¶æ•° 5ä¸åè¿›åˆ¶æ•° 3 // åˆ†åˆ«è¿›è¡Œ ORã€XORä¸ ANDè¿ç®—ï¼Œå¯ä»¥å¾—åˆ°å¦‚ä¸‹ç»“æœï¼š // 0101 (åè¿›åˆ¶ 5) 0101 (åè¿›åˆ¶ 5) 0101 (åè¿›åˆ¶ 5) // OR 0011 (åè¿›åˆ¶ 3) XOR 0011 (åè¿›åˆ¶ 3) AND 0011 (åè¿›åˆ¶ 3) // = 0111 (åè¿›åˆ¶ 7) = 0110 (åè¿›åˆ¶ 6) = 0001 (åè¿›åˆ¶ 1) #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) const int N=1e6; vector\u0026lt;pair\u0026lt;string,int\u0026gt;\u0026gt; a(N); string op; int t; int n,m; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int change(int p,int q){ For(i,0,n){ int x=a[i].second\u0026gt;\u0026gt;p\u0026amp;1; if(a[i].first==\u0026#34;AND\u0026#34;)q\u0026amp;=x; else if(a[i].first==\u0026#34;OR\u0026#34;)q|=x; else {q^=x;} } return q; } int main(){ ios cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; For(i,0,n){ cin\u0026gt;\u0026gt;a[i].first; cin\u0026gt;\u0026gt;a[i].second; } int pre=0,aft=0; For(i,0,30){ int p=29-i; int pos1=change(p,0); int pos2=change(p,1); if(pre+(1\u0026lt;\u0026lt;p)\u0026lt;=m \u0026amp;\u0026amp; pos2\u0026gt;pos1){ pre+=1\u0026lt;\u0026lt;p; aft+=pos2\u0026lt;\u0026lt;p; } else aft+=pos1\u0026lt;\u0026lt;p; } cout\u0026lt;\u0026lt;aft\u0026lt;\u0026lt;endl; } XORæˆå¯¹å˜æ¢ 1 2 3 4 if n\u0026amp;1: n^1==n-1 else: n^1==n+1 lowbit n\u0026amp;(-n)\né£è¡Œå‘˜å…„å¼Ÿ å‰ç½®çŸ¥è¯†\nè´ªå¿ƒ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 â€œé£è¡Œå‘˜å…„å¼Ÿâ€è¿™ä¸ªæ¸¸æˆï¼Œéœ€è¦ç©å®¶é¡ºåˆ©çš„æ‰“å¼€ä¸€ä¸ªæ‹¥æœ‰ 16ä¸ªæŠŠæ‰‹çš„å†°ç®±ã€‚ å·²çŸ¥æ¯ä¸ªæŠŠæ‰‹å¯ä»¥å¤„äºä»¥ä¸‹ä¸¤ç§çŠ¶æ€ä¹‹ä¸€ï¼šæ‰“å¼€æˆ–å…³é—­ã€‚ åªæœ‰å½“æ‰€æœ‰æŠŠæ‰‹éƒ½æ‰“å¼€æ—¶ï¼Œå†°ç®±æ‰ä¼šæ‰“å¼€ã€‚ æŠŠæ‰‹å¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ª 4Ã—4çš„çŸ©é˜µï¼Œæ‚¨å¯ä»¥æ”¹å˜ä»»ä½•ä¸€ä¸ªä½ç½® [i,j]ä¸ŠæŠŠæ‰‹çš„çŠ¶æ€ã€‚ ä½†æ˜¯ï¼Œè¿™ä¹Ÿä¼šä½¿å¾—ç¬¬ iè¡Œå’Œç¬¬ jåˆ—ä¸Šçš„æ‰€æœ‰æŠŠæ‰‹çš„çŠ¶æ€ä¹Ÿéšç€æ”¹å˜ã€‚ è¯·ä½ æ±‚å‡ºæ‰“å¼€å†°ç®±æ‰€éœ€çš„åˆ‡æ¢æŠŠæ‰‹çš„æ¬¡æ•°æœ€å°å€¼æ˜¯å¤šå°‘ã€‚ è¾“å…¥æ ¼å¼ è¾“å…¥ä¸€å…±åŒ…å«å››è¡Œï¼Œæ¯è¡ŒåŒ…å«å››ä¸ªæŠŠæ‰‹çš„åˆå§‹çŠ¶æ€ã€‚ ç¬¦å· + è¡¨ç¤ºæŠŠæ‰‹å¤„äºé—­åˆçŠ¶æ€ï¼Œè€Œç¬¦å· - è¡¨ç¤ºæŠŠæ‰‹å¤„äºæ‰“å¼€çŠ¶æ€ã€‚ è‡³å°‘ä¸€ä¸ªæ‰‹æŸ„çš„åˆå§‹çŠ¶æ€æ˜¯å…³é—­çš„ã€‚ è¾“å‡ºæ ¼å¼ ç¬¬ä¸€è¡Œè¾“å‡ºä¸€ä¸ªæ•´æ•° Nï¼Œè¡¨ç¤ºæ‰€éœ€çš„æœ€å°åˆ‡æ¢æŠŠæ‰‹æ¬¡æ•°ã€‚ æ¥ä¸‹æ¥ Nè¡Œæè¿°åˆ‡æ¢é¡ºåºï¼Œæ¯è¡Œè¾“å‡ºä¸¤ä¸ªæ•´æ•°ï¼Œä»£è¡¨è¢«åˆ‡æ¢çŠ¶æ€çš„æŠŠæ‰‹çš„è¡Œå·å’Œåˆ—å·ï¼Œæ•°å­—ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ã€‚ æ³¨æ„ï¼šå¦‚æœå­˜åœ¨å¤šç§æ‰“å¼€å†°ç®±çš„æ–¹å¼ï¼Œåˆ™æŒ‰ç…§ä¼˜å…ˆçº§æ•´ä½“ä»ä¸Šåˆ°ä¸‹ï¼ŒåŒè¡Œä»å·¦åˆ°å³æ‰“å¼€ã€‚ æ•°æ®èŒƒå›´ 1â‰¤i,jâ‰¤4 è¾“å…¥æ ·ä¾‹ï¼š -+-- ---- ---- -+-- è¾“å‡ºæ ·ä¾‹ï¼š 6 1 1 1 3 1 4 4 1 4 3 4 4 è´¹è§£çš„å¼€å…³ å‰ç½®çŸ¥è¯†\nè´ªå¿ƒ åˆ†è€Œæ²»ä¹‹ å‰ç¼€å’Œä¸å·®åˆ† äºŒåˆ† æ’åº å€å¢ è´ªå¿ƒ ","date":"2023-04-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue00/","title":"å°è“ä¹¦0X00æ€»ç»“"}]