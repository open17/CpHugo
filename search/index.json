[{"content":"天才ACM 题目描述 给定一个整数 M，对于任意一个整数集合 S，定义“校验值”如下:\n从集合 S 中取出 M 对数(即 2×M 个数，不能重复使用集合中的数，如果 S 中的整数不够 M 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 S 的“校验值”。\n现在给定一个长度为 N 的数列 A 以及一个整数 T。\n我们要把 A 分成若干段，使得每一段的“校验值”都不超过 T。\n求最少需要分成几段。\n样例 输入样例：\n2\n5 1 49\n8 2 1 7 9\n5 1 64\n8 2 1 7 9\n输出样例：\n2\n1\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;ctime\u0026gt; using namespace std; typedef long long ll; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(ll w=(a);w\u0026lt;(n);++w) #define debug(a,b,c) cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug start\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;;for(int i=a;i\u0026lt;=b;i++){cout\u0026lt;\u0026lt;c[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;;}cout\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#34;debug over\u0026#34;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; #define inf 0x3f typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5e6+9; ll a[N],b[N],temp[N]; ll t; ll k,m,n; inline ll read() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } bool check(ll l,ll last,ll r){ if(l==last){ ll x=a[l]; ll y=a[r]; temp[l]=min(x,y); temp[r]=max(x,y); ll ans=(x-y)*(x-y); return ans\u0026lt;=t; } FOR(i,last+1,r+1){ b[i]=a[i]; } sort(b+last+1,b+r+1); //merge int p1=l,p2=last+1,pp=l; while(p1\u0026lt;=last\u0026amp;\u0026amp;p2\u0026lt;=r){ if(b[p1]\u0026lt;b[p2])temp[pp++]=b[p1++]; else temp[pp++]=b[p2++]; } while(p1\u0026lt;=last)temp[pp++]=b[p1++]; while(p2\u0026lt;=r)temp[pp++]=b[p2++]; //check ll num=m; ll sums=0; ll ll=l,rr=r; while(num\u0026amp;\u0026amp;l\u0026lt;r){ num--; sums+=(temp[r]-temp[l])*(temp[r]-temp[l]); l++; r--; } //cout\u0026lt;\u0026lt;\u0026#34; l:\u0026#34;\u0026lt;\u0026lt;ll\u0026lt;\u0026lt;\u0026#34; last:\u0026#34;\u0026lt;\u0026lt;last\u0026lt;\u0026lt;\u0026#34; r:\u0026#34;\u0026lt;\u0026lt;rr\u0026lt;\u0026lt;\u0026#34; sums:\u0026#34;\u0026lt;\u0026lt;sums\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; //debug(ll,rr,temp) return sums\u0026lt;=t; } int main() { // freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); // freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); k=read(); while(k--){ n=read(); m=read(); t=read(); FOR(i,1,n+1)a[i]=read(); //strat from 1 ,[l,r+size] ll cnt=0,l=1,r=1,size=1; while(r\u0026lt;n+1){ while(size){ if(r+size\u0026lt;n+1\u0026amp;\u0026amp;check(l,r,r+size)){ r+=size; size*=2; FOR(i,l,r+1)b[i]=temp[i]; //cout\u0026lt;\u0026lt;\u0026#34;ss\u0026#34;\u0026lt;\u0026lt;endl; //debug(l,r,b) //cout\u0026lt;\u0026lt;\u0026#34;ss\u0026#34;\u0026lt;\u0026lt;endl; } else{ size/=2; } } //cout\u0026lt;\u0026lt;\u0026#34;!!!!!!!!!!!\u0026#34;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cnt++; size=1; r++; l=r; } cout \u0026lt;\u0026lt; cnt \u0026lt;\u0026lt; endl; } return 0; } st表 详见st表模板\n","date":"2023-05-27T01:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue06/","title":"小蓝书0X06倍增---天才ACM"},{"content":"前言 待更新\nT1 购买两块巧克力 给你一个整数数组 prices ，它表示一个商店里若干巧克力的价格。同时给你一个整数 money ，表示你一开始拥有的钱数。\n你必须购买 恰好 两块巧克力，而且剩余的钱数必须是 非负数 。同时你想最小化购买两块巧克力的总花费。\n请你返回在购买两块巧克力后，最多能剩下多少钱。如果购买任意两块巧克力都超过了你拥有的钱，请你返回 money 。注意剩余钱数必须是非负数。\n示例 1：\n1 2 3 输入：prices = [1,2,2], money = 3 输出：0 解释：分别购买价格为 1 和 2 的巧克力。你剩下 3 - 3 = 0 块钱。所以我们返回 0 。 示例 2：\n1 2 3 输入：prices = [3,2,3], money = 3 输出：3 解释：购买任意 2 块巧克力都会超过你拥有的钱数，所以我们返回 3 。 提示：\n1 2 3 2 \u0026lt;= prices.length \u0026lt;= 50 1 \u0026lt;= prices[i] \u0026lt;= 100 1 \u0026lt;= money \u0026lt;= 100 思路 模拟\n1 2 3 4 5 class Solution: def buyChoco(self, prices: List[int], money: int) -\u0026gt; int: prices.sort() x=money-prices[0]+prices[1] return x if x\u0026gt;=0 else money T2 字符串中的额外字符 给你一个下标从 0 开始的字符串 s 和一个单词字典 dictionary 。你需要将 s 分割成若干个 互不重叠 的子字符串，每个子字符串都在 dictionary 中出现过。s 中可能会有一些 额外的字符 不在任何子字符串中。\n请你采取最优策略分割 s ，使剩下的字符 最少 。\n示例 1：\n1 2 3 输入：s = \u0026#34;leetscode\u0026#34;, dictionary = [\u0026#34;leet\u0026#34;,\u0026#34;code\u0026#34;,\u0026#34;leetcode\u0026#34;] 输出：1 解释：将 s 分成两个子字符串：下标从 0 到 3 的 \u0026#34;leet\u0026#34; 和下标从 5 到 8 的 \u0026#34;code\u0026#34; 。只有 1 个字符没有使用（下标为 4），所以我们返回 1 。 示例 2：\n1 2 3 输入：s = \u0026#34;sayhelloworld\u0026#34;, dictionary = [\u0026#34;hello\u0026#34;,\u0026#34;world\u0026#34;] 输出：3 解释：将 s 分成两个子字符串：下标从 3 到 7 的 \u0026#34;hello\u0026#34; 和下标从 8 到 12 的 \u0026#34;world\u0026#34; 。下标为 0 ，1 和 2 的字符没有使用，所以我们返回 3 。 提示：\n1 2 3 4 5 1 \u0026lt;= s.length \u0026lt;= 50 1 \u0026lt;= dictionary.length \u0026lt;= 50 1 \u0026lt;= dictionary[i].length \u0026lt;= 50 dictionary[i] 和 s 只包含小写英文字母。 dictionary 中的单词互不相同 思路 一开始没看数据大小(真的要改),死磕kmp,然后想的是贪心处理重叠选择(很明显,至少我想了好久没找出来) 后来回过头来看数据范围这么小,直接记忆化搜索AC(其实还wa了一发,用回溯偷懒没过)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution: def minExtraChar(self, s: str, dictionary: List[str]) -\u0026gt; int: ss=set(dictionary) ans=[0] @cache def dfs(i): if i\u0026gt;=len(s): return 0 res=0 for k in range(len(s)-i): if s[i:k+i+1] in ss: res=max(dfs(k+i+1)+k+1,res) else: res=max(res,dfs(k+i+1)) return res return len(s)-dfs(0) T3 一个小组的最大实力值 给你一个下标从 0 开始的整数数组 nums ，它表示一个班级中所有学生在一次考试中的成绩。老师想选出一部分同学组成一个 非空 小组，且这个小组的 实力值 最大，如果这个小组里的学生下标为 i0, i1, i2, \u0026hellip; , ik ，那么这个小组的实力值定义为 nums[i0] * nums[i1] * nums[i2] * \u0026hellip; * nums[ik​] 。\n请你返回老师创建的小组能得到的最大实力值为多少。\n示例 1：\n输入：nums = [3,-1,-5,2,5,-9]\n输出：1350\n解释：一种构成最大实力值小组的方案是选择下标为 [0,2,3,4,5] 的学生。实力值为 3 * (-5) * 2 * 5 * (-9) = 1350 ，这是可以得到的最大实力值。\n示例 2：\n输入：nums = [-4,-5,-4]\n输出：20\n解释：选择下标为 [0, 1] 的学生。得到的实力值为 20 。我们没法得到更大的实力值\n反思 很简单的一道题 这里竟然wa了三发,第一发wa在少打了一个*号,第二三发wa在没注意大小写isZero和iszero 明明本题唯一要思考的分类讨论都仔细思考了防止wa(虽然分类不够精简),却在打字上过于急躁wa\n导致排名狂掉 以后无论代码有多简单一定要记得先测试一下能不能跑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution: def maxStrength(self, nums: List[int]) -\u0026gt; int: ans=1 flag=0 p=[] res=1 isZero=False for i in nums: if i\u0026gt;0: ans*=i flag=1 elif i\u0026lt;0: p.append(i) else: isZero=True p.sort() size=(len(p)//2)*2 for i in range(size): res*=p[i] if flag: return res*ans elif size\u0026gt;=2: return res elif isZero: return 0 return p[0] T4 最大公约数遍历 给你一个下标从 0 开始的整数数组 nums ，你可以在一些下标之间遍历。对于两个下标 i 和 j（i != j），当且仅当 gcd(nums[i], nums[j]) \u0026gt; 1 时，我们可以在两个下标之间通行，其中 gcd 是两个数的 最大公约数 。\n你需要判断 nums 数组中 任意 两个满足 i \u0026lt; j 的下标 i 和 j ，是否存在若干次通行可以从 i 遍历到 j 。\n如果任意满足条件的下标对都可以遍历，那么返回 true ，否则返回 false 。\n示例 1：\n1 2 3 4 5 输入：nums = [2,3,6] 输出：true 解释：这个例子中，总共有 3 个下标对：(0, 1) ，(0, 2) 和 (1, 2) 。 从下标 0 到下标 1 ，我们可以遍历 0 -\u0026gt; 2 -\u0026gt; 1 ，我们可以从下标 0 到 2 是因为 gcd(nums[0], nums[2]) = gcd(2, 6) = 2 \u0026gt; 1 ，从下标 2 到 1 是因为 gcd(nums[2], nums[1]) = gcd(6, 3) = 3 \u0026gt; 1 。 从下标 0 到下标 2 ，我们可以直接遍历，因为 gcd(nums[0], nums[2]) = gcd(2, 6) = 2 \u0026gt; 1 。同理，我们也可以从下标 1 到 2 因为 gcd(nums[1], nums[2]) = gcd(3, 6) = 3 \u0026gt; 1 。 示例 2：\n1 2 3 输入：nums = [3,9,5] 输出：false 解释：我们没法从下标 0 到 2 ，所以返回 false 。 示例 3：\n1 2 3 输入：nums = [4,3,12,8] 输出：true 解释：总共有 6 个下标对：(0, 1) ，(0, 2) ，(0, 3) ，(1, 2) ，(1, 3) 和 (2, 3) 。所有下标对之间都存在可行的遍历，所以返回 true 。 提示：\n1 2 1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 105 思路 见评论区吧\n","date":"2023-05-27T00:00:00Z","image":"https://pic.lingkou.xyz/1683871861-YilDpq-1760-360%20%E5%AE%BD%E5%BE%B7%E6%8A%95%E8%B5%84.png","permalink":"https://open17.github.io/CpHugo/p/lc-biweekly-contest-105/","title":"lc-biweekly-contest-105"},{"content":" 痛苦T4\nT1 公因子的数目 给你两个正整数 a 和 b ，返回 a 和 b 的 公 因子的数目。\n如果 x 可以同时整除 a 和 b ，则认为 x 是 a 和 b 的一个 公因子 。\n示例 1：\n输入：a = 12, b = 6 输出：4 解释：12 和 6 的公因子是 1、2、3、6 。 示例 2：\n输入：a = 25, b = 30 输出：2 解释：25 和 30 的公因子是 1、5 。\n提示：\n1 \u0026lt;= a, b \u0026lt;= 1000\n思路 模拟即可\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int commonFactors(int a, int b) { int t=min(a,b); int cnt=0; for(int i=1;i\u0026lt;=t;i++){ if(a%i==0\u0026amp;\u0026amp;b%i==0)cnt++; } return cnt; } }; T2 沙漏的最大总和 给你一个大小为 m x n 的整数矩阵 grid 。\n按以下形式将矩阵的一部分定义为一个 沙漏 ：\n返回沙漏中元素的 最大 总和。\n注意：沙漏无法旋转且必须整个包含在矩阵中。\n示例 1：\n输入：grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]\n输出：30\n解释：上图中的单元格表示元素总和最大的沙漏：6 + 2 + 1 + 2 + 9 + 2 + 8 = 30 。\n示例 2： 输入：grid = [[1,2,3],[4,5,6],[7,8,9]] 输出：35 解释：上图中的单元格表示元素总和最大的沙漏：1 + 2 + 3 + 5 + 7 + 8 + 9 = 35 。\n提示：\n1 2 3 4 m == grid.length n == grid[i].length 3 \u0026lt;= m, n \u0026lt;= 150 0 \u0026lt;= grid[i][j] \u0026lt;= 106 思路 数据小,暴力模拟也能ac 这里用前缀和优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: long long b[153][153]; int maxSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { memset(b,0,sizeof(b)); for(int i=0;i\u0026lt;grid.size();i++){ for(int j=0;j\u0026lt;grid[0].size();j++){ b[i+1][j+1]=b[i][j+1]+b[i+1][j]+grid[i][j]-b[i][j]; } } long long ans=-1; for(int i=3;i\u0026lt;=grid.size();i++){ for(int j=3;j\u0026lt;=grid[0].size();j++){ ans=max(ans,b[i][j] - b[i-3][j] - b[i][j-3] + b[i-3][j-3]-grid[i-2][j-3]-grid[i-2][j-1]); } } return ans; } }; T3 最小 XOR 给你两个正整数 num1 和 num2 ，找出满足下述条件的整数 x ：\nx 的置位数和 num2 相同，且 x XOR num1 的值 最小 注意 XOR 是按位异或运算。\n返回整数 x 。题目保证，对于生成的测试用例， x 是 唯一确定 的。\n整数的 置位数 是其二进制表示中 1 的数目。\n示例 1：\n1 2 3 4 5 输入：num1 = 3, num2 = 5 输出：3 解释： num1 和 num2 的二进制表示分别是 0011 和 0101 。 整数 3 的置位数与 num2 相同，且 3 XOR 3 = 0 是最小的。 示例 2：\n1 2 3 4 5 输入：num1 = 1, num2 = 12 输出：3 解释： num1 和 num2 的二进制表示分别是 0001 和 1100 。 整数 3 的置位数与 num2 相同，且 3 XOR 1 = 2 是最小的。 提示：\n1 1 \u0026lt;= num1, num2 \u0026lt;= 109 思路 贪心+位运算\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: int lowbit(int a){ int cnt=0; while(a){ a^=(a\u0026amp;(-a)); cnt++; } return cnt; } int minimizeXor(int num1, int num2) { int cnt=lowbit(num2); int res=lowbit(num1); if(cnt==res)return num1; if(res\u0026gt;cnt){ int dif=res-cnt; int ans=0; int p=num1; while(dif){ dif--; ans+=num1\u0026amp;(-num1); num1^=(num1\u0026amp;(-num1)); } return p-ans; } int d=-1; int t=cnt-res; int ans=0; while(d\u0026lt;31\u0026amp;\u0026amp;t\u0026gt;0){ d++; if(num1\u0026amp;(1\u0026lt;\u0026lt;d)){continue;} ans+=pow(2,d); t--; } return ans+num1; } }; 缩减版 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int minimizeXor(int num1, int num2) { int c1 = __builtin_popcount(num1); int c2 = __builtin_popcount(num2); for (; c2 \u0026lt; c1; ++c2) num1 \u0026amp;= num1 - 1; // 最低的 1 变成 0 for (; c2 \u0026gt; c1; --c2) num1 |= num1 + 1; // 最低的 0 变成 1 return num1; } }; // 作者：endlesscheng T4 对字母串可执行的最大删除数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以： 删除 整个字符串 s ，或者 对于满足 1 \u0026lt;= i \u0026lt;= s.length / 2 的任意 i ，如果 s 中的 前 i 个字母和接下来的 i 个字母 相等 ，删除 前 i 个字母。 例如，如果 s = \u0026#34;ababc\u0026#34; ，那么在一步操作中，你可以删除 s 的前两个字母得到 \u0026#34;abc\u0026#34; ，因为 s 的前两个字母和接下来的两个字母都等于 \u0026#34;ab\u0026#34; 。 返回删除 s 所需的最大操作数。 示例 1： 输入：s = \u0026#34;abcabcdabc\u0026#34; 输出：2 解释： - 删除前 3 个字母（\u0026#34;abc\u0026#34;），因为它们和接下来 3 个字母相等。现在，s = \u0026#34;abcdabc\u0026#34;。 - 删除全部字母。 一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。 注意，在第二步操作中无法再次删除 \u0026#34;abc\u0026#34; ，因为 \u0026#34;abc\u0026#34; 的下一次出现并不是位于接下来的 3 个字母。 示例 2： 输入：s = \u0026#34;aaabaab\u0026#34; 输出：4 解释： - 删除第一个字母（\u0026#34;a\u0026#34;），因为它和接下来的字母相等。现在，s = \u0026#34;aabaab\u0026#34;。 - 删除前 3 个字母（\u0026#34;aab\u0026#34;），因为它们和接下来 3 个字母相等。现在，s = \u0026#34;aab\u0026#34;。 - 删除第一个字母（\u0026#34;a\u0026#34;），因为它和接下来的字母相等。现在，s = \u0026#34;ab\u0026#34;。 - 删除全部字母。 一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。 示例 3： 输入：s = \u0026#34;aaaaa\u0026#34; 输出：5 解释：在每一步操作中，都可以仅删除 s 的第一个字母。 提示： 1 \u0026lt;= s.length \u0026lt;= 4000 s 仅由小写英文字母组成 朴素记忆化搜索(MLE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution: def deleteString(self, s: str) -\u0026gt; int: if len(set(s)) == 1: return len(s) @cache def dfs(i,start): ans=0 if i\u0026gt;=len(s): if i==start: return 0 return 1 # print(s[start:i+1],s[i+1:i+1+(i+1-start)]) if s[start:i+1]==s[i+1:i+1+(i+1-start)]: ans=dfs(i+1,i+1)+1 ans=max(ans,dfs(i+1,start)) return ans dfs.cache_clear() return dfs(0,0) 朴素动态规划(TLE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution: def deleteString(self, s: str) -\u0026gt; int: size=len(s)+1 dfs=[[0]*(size+2) for _ in range(size+2)] for j in range(size): if j==size-1: dfs[size-1][j]=0 else: dfs[size-1][j]=1 for i in range(size-1,-1,-1): for j in range(size-1,-1,-1): if s[j:i+1]==s[i+1:i+1+(i+1-j)]: dfs[i][j]=dfs[i+1][i+1]+1 dfs[i][j]=max(dfs[i][j],dfs[i+1][j]) return dfs[0][0] LCP优化朴素动态规划(TLE) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution: def deleteString(self, s: str) -\u0026gt; int: size=len(s)+1 if len(set(s)) == 1: return size-1 dfs=[[0]*(size+2) for _ in range(size+2)] lcp=[[0]*(size+2) for _ in range(size+2)] for i in range(size-2, -1, -1): for j in range(size-2, i, -1): if s[i] == s[j]: lcp[i][j] = lcp[i + 1][j + 1] + 1 for j in range(size): if j==size-1: dfs[size-1][j]=0 else: dfs[size-1][j]=1 for i in range(size-1,-1,-1): for j in range(size-1,-1,-1): if lcp[j][i+1]\u0026gt;=i+1-j: dfs[i][j]=dfs[i+1][i+1]+1 dfs[i][j]=max(dfs[i][j],dfs[i+1][j]) return dfs[0][0] 剪枝记忆化搜索(AC) 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution: def deleteString(self, s: str) -\u0026gt; int: @cache def dfs(i): s_ = s[i:] ans = 1 for j in range(1, len(s) // 2 + 1): if s_[:j] == s_[j:j*2]: ans = max(ans, 1 + dfs(i + j)) return ans dfs.cache_clear() return dfs(0) 剪枝+LCP优化动态规划(AC) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution: def deleteString(self, s: str) -\u0026gt; int: n = len(s) if len(set(s)) == 1: return n # 特判全部相同的情况 lcp = [[0] * (n + 1) for _ in range(n + 1)] # lcp[i][j] 表示 s[i:] 和 s[j:] 的最长公共前缀 for i in range(n - 1, -1, -1): for j in range(n - 1, i, -1): if s[i] == s[j]: lcp[i][j] = lcp[i + 1][j + 1] + 1 f = [0] * n for i in range(n - 1, -1, -1): for j in range(1, (n - i) // 2 + 1): if lcp[i][i + j] \u0026gt;= j: # 说明 s[i:i+j] == s[i+j:i+2*j] f[i] = max(f[i], f[i + j]) f[i] += 1 return f[0] # endlesscheng ","date":"2023-05-26T00:00:00Z","image":"https://pic.lingkou.xyz/1664008640-fTlCRH-1760-360%20%E7%A9%BA%E4%B8%AD%E4%BA%91%E6%B1%87.png","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-313/","title":"lc weekly contest 313"},{"content":"102. 最佳牛围栏 题目描述 农夫约翰的农场由 $N$ 块田地组成，每块地里都有一定数量的牛，其数量不会少于 1 头，也不会超过 2000 头。\n约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。\n围起区域内至少需要包含 $F$ 块地，其中 $F$ 会在输入中给出。\n在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。\n输入格式 第一行输入整数 $N$ 和 $F$，数据间用空格隔开。\n接下来 $N$ 行，每行输入一个整数，第 $i+1$ 行输入的整数代表第 $i$ 片区域内包含的牛的数目。\n输出格式 输出一个整数，表示平均值的最大值乘以 1000 再向下取整之后得到的结果。\n数据范围 $1≤N≤100000$\n$1≤F≤N$\n输入样例： 1 2 3 4 5 6 7 8 9 10 11 10 6 6 4 2 10 3 8 5 9 4 1 输出样例： 1 6500 tag 思维 二分 DP/前缀和 code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f3f3f3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+2; double a[N],b[N]; int n,f; bool check(double t){ FOR(i,1,n+1){ b[i]=a[i]+b[i-1]-t; } double mins=inf; double maxs=-inf; FOR(i,f,n+1){ mins=min(mins,b[i-f]); maxs=max(maxs,b[i]-mins); } return maxs\u0026gt;=0; } int main() { ios cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;f; FOR(i,1,n+1){ cin\u0026gt;\u0026gt;a[i]; } double l=1,r=2001; double eps=1e-5; while(r-l\u0026gt;eps){ double mid=(l+r)/2; if (check(mid))l=mid; else r=mid; } cout\u0026lt;\u0026lt;int(r*1000)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } 元素排序 有 $N$ 个元素，编号 $1,2,\\dots,N$，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。元素的大小关系是 $N$ 个点与 $\\frac{N\\times(N-1)}{2}$ 条有向边构成的任意有向图。\n然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过 $10000$ 次提问来获取信息，每次提问只能了解某两个元素之间的关系。\n现在请你把这 $N$ 个元素排成一行，使得每个元素都小于右边与它相邻的元素。\n你可以通过我们预设的 bool 函数 compare 来获得两个元素之间的大小关系。\n例如，编号为 $a$ 和 $b$ 的两个元素，如果元素 $a$ 小于元素 $b$，则 compare(a,b) 返回 true，否则返回 false。\n将 $N$ 个元素排好序后，把它们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。\n数据范围 $1 \\leq N \\leq 1000$\n输入样例 1 [[0, 1, 0], [0, 0, 0], [1, 1, 0]] 输出样例 1 [3, 1, 2] code 1 2 3 4 5 6 7 8 9 10 11 12 13 //满足归并排序性质，先水过去吧 // Forward declaration of compare API. // bool compare(int a, int b); // return bool means whether a is less than b. class Solution { public: vector\u0026lt;int\u0026gt; specialSort(int N) { vector\u0026lt;int\u0026gt;a; for(int i=1;i\u0026lt;=N;++i)a.push_back(i); stable_sort(a.begin(),a.end(),compare); return a; } }; ","date":"2023-05-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue04/","title":"小蓝书0X04二分法"},{"content":"windows 对拍主程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;ctime\u0026gt; #include\u0026lt;windows.h\u0026gt; int main(){ int cnt=0; system(\u0026#34;g++ 1.cpp -o 1.exe\u0026#34;); system(\u0026#34;g++ 2.cpp -o 2.exe\u0026#34;); system(\u0026#34;g++ data.cpp -o data.exe\u0026#34;); while(1){ cnt++; system(\u0026#34;data.exe\u0026#34;); printf(\u0026#34;data create successfully\\n\u0026#34;); Sleep(1000); system(\u0026#34;1.exe\u0026#34;); system(\u0026#34;2.exe\u0026#34;); if(!system(\u0026#34;fc res.out ans.out\u0026#34;)){ printf(\u0026#34;AC test#%d\\n\u0026#34;,cnt); } else{ printf(\u0026#34;WA!\\n\u0026#34;); Sleep(2000); break; } } return 0; } 数据生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;ctime\u0026gt; using namespace std; typedef long long ll; ll random(ll mod) { ll n1, n2, n3, n4, ans; n1 = rand(); n2 = rand(); n3 = rand(); n4 = rand(); ans = n1 * n2 % mod; ans = ans * n3 % mod; ans = ans * n4 % mod; return ans; } int main(){ freopen(\u0026#34;data.in\u0026#34;,\u0026#34;w\u0026#34;,stdout); srand((unsigned)time(0)); ll i=random(10); cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;endl; return 0; } 程序对拍节点 1 2 3 4 5 6 //1.cpp freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;res.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); //2.cpp freopen(\u0026#34;data.in\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;ans.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); linux 把exe改成out,fc改成diff,Sleep改成sleep,windows.h改为unistd.h\n","date":"2023-05-23T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/duipai/","title":"对拍模板"},{"content":"写在前面 LC346传送门 第四题难,前三题难度较低\nT1 删除子串后的字符串最小长度 给你一个仅由 大写 英文字符组成的字符串 s 。 你可以对此字符串执行一些操作，在每一步操作中，你可以从 s 中删除 任一个 \u0026ldquo;AB\u0026rdquo; 或 \u0026ldquo;CD\u0026rdquo; 子字符串。 通过执行操作，删除所有 \u0026ldquo;AB\u0026rdquo; 和 \u0026ldquo;CD\u0026rdquo; 子串，返回可获得的最终字符串的 最小 可能长度。 注意，删除子串后，重新连接出的字符串可能会产生新的 \u0026ldquo;AB\u0026rdquo; 或 \u0026ldquo;CD\u0026rdquo; 子串\n示例 1： 输入：s = \u0026ldquo;ABFCACDB\u0026rdquo; 输出：2 解释：你可以执行下述操作：\n从 \u0026ldquo;ABFCACDB\u0026rdquo; 中删除子串 \u0026ldquo;AB\u0026rdquo;，得到 s = \u0026ldquo;FCACDB\u0026rdquo; 。 从 \u0026ldquo;FCACDB\u0026rdquo; 中删除子串 \u0026ldquo;CD\u0026rdquo;，得到 s = \u0026ldquo;FCAB\u0026rdquo; 。 从 \u0026ldquo;FCAB\u0026rdquo; 中删除子串 \u0026ldquo;AB\u0026rdquo;，得到 s = \u0026ldquo;FC\u0026rdquo; 。 最终字符串的长度为 2 。 可以证明 2 是可获得的最小长度。 示例 2： 输入：s = \u0026ldquo;ACBBD\u0026rdquo; 输出：5 解释：无法执行操作，字符串长度不变。\n思路 模拟/栈(类似括号删除)\n比赛代码(模拟) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution: def minLength(self, s: str) -\u0026gt; int: p1=0 p2=1 if len(s)==1: return 1 a=[] for i in s: a.append(i) while p2\u0026lt;len(a): if a[p1]==\u0026#34;A\u0026#34; and a[p2]==\u0026#34;B\u0026#34;: del a[p1] del a[p2-1] if p1!=0 and p2!=1: p1-=1 p2-=1 elif a[p1]==\u0026#34;C\u0026#34; and a[p2]==\u0026#34;D\u0026#34;: del a[p1] del a[p2-1] if p1!=0 and p2!=1: p1-=1 p2-=1 else: p1+=1 p2+=1 return len(a) 语法糖模拟 1 2 3 4 5 6 class Solution: def minLength(self, s: str) -\u0026gt; int: while \u0026#34;AB\u0026#34; in s or \u0026#34;CD\u0026#34; in s: s = s.replace(\u0026#34;AB\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;CD\u0026#34;, \u0026#34;\u0026#34;) return len(s) # 作者：endlesscheng 栈 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int minLength(string s) { stack\u0026lt;char\u0026gt; ss; for(auto i:s){ if(!ss.empty()\u0026amp;\u0026amp;((ss.top()==\u0026#39;A\u0026#39;\u0026amp;\u0026amp;i==\u0026#39;B\u0026#39;)||(ss.top()==\u0026#39;C\u0026#39;\u0026amp;\u0026amp;i==\u0026#39;D\u0026#39;)))ss.pop(); else ss.push(i); } return ss.size(); } }; T2 字典序最小回文串 给你一个由 小写英文字母 组成的字符串 s ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母 替换 s 中的一个字符。\n请你执行 尽可能少的操作 ，使 s 变成一个 回文串 。如果执行 最少 操作次数的方案不止一种，则只需选取 字典序最小 的方案。\n对于两个长度相同的字符串 a 和 b ，在 a 和 b 出现不同的第一个位置，如果该位置上 a 中对应字母比 b 中对应字母在字母表中出现顺序更早，则认为 a 的字典序比 b 的字典序要小。\n返回最终的回文字符串。\n示例 1：\n输入：s = \u0026ldquo;egcfe\u0026rdquo; 输出：\u0026ldquo;efcfe\u0026rdquo; 解释：将 \u0026ldquo;egcfe\u0026rdquo; 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 \u0026ldquo;efcfe\u0026rdquo;，只需将 \u0026lsquo;g\u0026rsquo; 改为 \u0026lsquo;f\u0026rsquo; 。 示例 2：\n输入：s = \u0026ldquo;abcd\u0026rdquo; 输出：\u0026ldquo;abba\u0026rdquo; 解释：将 \u0026ldquo;abcd\u0026rdquo; 变成回文字符串的最小操作次数为 2 ，修改 2 次得到的字典序最小回文字符串是 \u0026ldquo;abba\u0026rdquo; 。 示例 3：\n输入：s = \u0026ldquo;seven\u0026rdquo; 输出：\u0026ldquo;neven\u0026rdquo; 解释：将 \u0026ldquo;seven\u0026rdquo; 变成回文字符串的最小操作次数为 1 ，修改 1 次得到的字典序最小回文字符串是 \u0026ldquo;neven\u0026rdquo; 。\n提示：\n1 \u0026lt;= s.length \u0026lt;= 1000 s 仅由小写英文字母组成\n思路 双指针\n赛时代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: string makeSmallestPalindrome(string s) { int st=0; int ed=s.size()-1; while(st\u0026lt;ed){ if(s[st]!=s[ed]){ if(s[st]-\u0026#39;a\u0026#39;\u0026gt;s[ed]-\u0026#39;a\u0026#39;){ s[st]=s[ed]; } else{ s[ed]=s[st]; } } st++; ed--; } return s; } }; T3 求一个整数的惩罚数 给你一个正整数 n ，请你返回 n 的 惩罚数 。\nn 的 惩罚数 定义为所有满足以下条件 i 的数的平方和：\n1 \u0026lt;= i \u0026lt;= n i * i 的十进制表示的字符串可以分割成若干连续子字符串，且这些子字符串对应的整数值之和等于 i 。\n示例 1：\n输入：n = 10 输出：182 解释：总共有 3 个整数 i 满足要求：\n1 ，因为 1 * 1 = 1 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。 因此，10 的惩罚数为 1 + 81 + 100 = 182\n示例 2： 输入：n = 37 输出：1478 解释：总共有 4 个整数 i 满足要求：\n1 ，因为 1 * 1 = 1 9 ，因为 9 * 9 = 81 ，且 81 可以分割成 8 + 1 。 10 ，因为 10 * 10 = 100 ，且 100 可以分割成 10 + 0 。 36 ，因为 36 * 36 = 1296 ，且 1296 可以分割成 1 + 29 + 6 。 因此，37 的惩罚数为 1 + 81 + 100 + 1296 = 1478 提示：\n1 \u0026lt;= n \u0026lt;= 1000\n思路 比赛时看到n最大才1000,可以直接预处理 打表用的dfs, 为了节约时间没把dfs改成动态规划\n赛时代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 打表代码 # a=[] # s=\u0026#34;\u0026#34; # def check(i,v,p): # if i\u0026gt;=len(s): # if p==v: # return 1 # return 0 # x=0 # for d in range(i,len(s)): # x=x|check(d+1,v,p+int(s[i:d+1])) # return x # for i in range(1,1001): # s=str(i*i) # if check(0,i,0): # a.append(i) # print(a) class Solution: def punishmentNumber(self, n: int) -\u0026gt; int: s={1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000} cnt=0 for i in range(1,n+1): if i in s: cnt+=i*i return cnt 记忆化搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution: def punishmentNumber(self, n: int) -\u0026gt; int: @cache def check(i,v,p,s): if i\u0026gt;=len(s): if p==v: return 1 return 0 x=0 for d in range(i,len(s)): x=x|check(d+1,v,p+int(s[i:d+1]),s) return x cnt=0 for i in range(1,n+1): s=str(i*i) if check(0,i,0,s): cnt+=i*i return cnt T4修改图中的边权 给你一个 n 个节点的 无向带权连通 图，节点编号为 0 到 n - 1 ，再给你一个整数数组 edges ，其中 edges[i] = [ai, bi, wi] 表示节点 ai 和 bi 之间有一条边权为 wi 的边。\n部分边的边权为 -1（wi = -1），其他边的边权都为 正 数（wi \u0026gt; 0）。\n你需要将所有边权为 -1 的边都修改为范围 [1, 2 * 109] 中的 正整数 ，使得从节点 source 到节点 destination 的 最短距离 为整数 target 。如果有 多种 修改方案可以使 source 和 destination 之间的最短距离等于 target ，你可以返回任意一种方案。\n如果存在使 source 到 destination 最短距离为 target 的方案，请你按任意顺序返回包含所有边的数组（包括未修改边权的边）。如果不存在这样的方案，请你返回一个 空数组 。\n注意：你不能修改一开始边权为正数的边。\n示例 1：\n输入：n = 5, edges = [[4,1,-1],[2,0,-1],[0,3,-1],[4,3,-1]], source = 0, destination = 1, target = 5 输出：[[4,1,1],[2,0,1],[0,3,3],[4,3,1]] 解释：上图展示了一个满足题意的修改方案，从 0 到 1 的最短距离为 5 。 示例 2：\n输入：n = 3, edges = [[0,1,-1],[0,2,5]], source = 0, destination = 2, target = 6 输出：[] 解释：上图是一开始的图。没有办法通过修改边权为 -1 的边，使得 0 到 2 的最短距离等于 6 ，所以返回一个空数组。 示例 3：\n输入：n = 4, edges = [[1,0,4],[1,2,3],[2,3,5],[0,3,-1]], source = 0, destination = 2, target = 6 输出：[[1,0,4],[1,2,3],[2,3,5],[0,3,1]] 解释：上图展示了一个满足题意的修改方案，从 0 到 2 的最短距离为 6 。\n提示：\n1 2 3 4 5 6 7 8 9 10 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= edges.length \u0026lt;= n * (n - 1) / 2 edges[i].length == 3 0 \u0026lt;= ai, bi \u0026lt; n wi = -1 或者 1 \u0026lt;= wi \u0026lt;= 107 ai != bi 0 \u0026lt;= source, destination \u0026lt; n source != destination 1 \u0026lt;= target \u0026lt;= 109 输入的图是连通图，且没有自环和重边。 请见 ","date":"2023-05-21T00:00:00Z","image":"https://pic.lingkou.xyz/1684119642-NLFpUC-1760-360%20%E9%A1%BA%E4%B8%B0%E7%A7%91%E6%8A%80.png","permalink":"https://open17.github.io/CpHugo/p/lc-weekly-contest-346/","title":"lc weekly contest 346"},{"content":"c++ 快读模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 inline int read() { int x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = x * 10 + ch - \u0026#39;0\u0026#39;; ch = getchar(); } return x * f; } 精简模板 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6; int main() { ios cout \u0026lt;\u0026lt; \u0026#34;Hello, ACM.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 完全模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #define _USE_MATH_DEFINES // C #include \u0026lt;cassert\u0026gt; #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cctype\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;ctime\u0026gt; //io #include \u0026lt;iostream\u0026gt; //基本输入输出流 #include \u0026lt;iomanip\u0026gt; #include \u0026lt;sstream\u0026gt; //基于字符串的流 //标准异常类 #include \u0026lt;stdexcept\u0026gt; //algorithm #include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;functional\u0026gt; //定义运算函数（代替运算符） #include \u0026lt;complex\u0026gt; //复数类 #include \u0026lt;random\u0026gt; //STL #include \u0026lt;string\u0026gt; //字符串类 #include \u0026lt;list\u0026gt; //线性列表容器 #include \u0026lt;vector\u0026gt; //动态数组容器 #include \u0026lt;stack\u0026gt; //堆栈容器 #include \u0026lt;queue\u0026gt; //队列容器 #include \u0026lt;deque\u0026gt; //双端队列容器 #include \u0026lt;bitset\u0026gt; //比特集合 #include \u0026lt;set\u0026gt; //集合容器 #include \u0026lt;map\u0026gt; //映射容器 #include \u0026lt;unordered_set\u0026gt; #include \u0026lt;unordered_map\u0026gt; using namespace std; //fast ios #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define ALL(a) (a).begin(),(a).end() #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define RFOR(w, a, n) for(int w=(n)-1;w\u0026gt;=(a);--w) #define REP(w, n) for(int w=0;w\u0026lt;int(n);++w) #define RREP(w, n) for(int w=int(n)-1;w\u0026gt;=0;--w) #define IN(a, x, b) (a\u0026lt;=x \u0026amp;\u0026amp; x\u0026lt;b) #define trace(...) __f(#__VA_ARGS__, __VA_ARGS__) template \u0026lt;typename Arg1\u0026gt; void __f(const char* name, Arg1\u0026amp;\u0026amp; arg1){ cerr \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; endl; } template \u0026lt;typename Arg1, typename... Args\u0026gt; void __f(const char* names, Arg1\u0026amp;\u0026amp; arg1, Args\u0026amp;\u0026amp;... args){ const char* comma = strchr(names + 1, \u0026#39;,\u0026#39;); cerr.write(names, comma - names) \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; arg1 \u0026lt;\u0026lt; \u0026#34; |\u0026#34;; __f(comma + 1, args...); } typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const double PI = acos(-1.0); const double eps = 1e-6; const int INF = 1 \u0026lt;\u0026lt; 29; const int MOD = 1e9 + 7; const int MAXN = 100; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, ACM.\u0026#34; \u0026lt;\u0026lt; endl; return 0; } python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import sys import heapq import random from math import ceil,floor,fmod,gcd,sqrt,inf from bisect import bisect_left from collections import defaultdict,Counter,deque,OrderedDict from functools import lru_cache,cmp_to_key #sys.setrecursionlimit(1000000) # 输入1 def ii(): return int(sys.stdin.readline().strip()) # 输入2 def iin(): return map(int,sys.stdin.readline().split()) def inn(): return sys.stdin.readline().strip() java go ","date":"2023-05-08T00:03:00Z","image":"https://open17.github.io/CpHugo/p/template/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://open17.github.io/CpHugo/p/template/","title":"算法输入输出模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 vector\u0026lt;int\u0026gt; get_prefix_table(string pattern) { int n = pattern.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = pi[j-1]; } if (pattern[i] == pattern[j]) { j++; } pi[i] = j; } return pi; } vector\u0026lt;int\u0026gt; kmp(string text, string pattern) { vector\u0026lt;int\u0026gt; pi = get_prefix_table(pattern); vector\u0026lt;int\u0026gt; matches; for (int i = 0, j = 0; i \u0026lt; text.length(); i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; text[i] != pattern[j]) { j = pi[j-1]; } if (text[i] == pattern[j]) { j++; } if (j == pattern.length()) { matches.push_back(i - j + 1); j = pi[j-1]; } } return matches; } 【模板】KMP字符串匹配 题目描述 给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。\n现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。\n定义一个字符串 $s$ 的 border 为 $s$ 的一个非 $s$ 本身的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。\n对于 $s_2$，你还需要求出对于其每个前缀 $s\u0026rsquo;$ 的最长 border $t\u0026rsquo;$ 的长度。\n输入格式 第一行为一个字符串，即为 $s_1$。\n第二行为一个字符串，即为 $s_2$。\n输出格式 首先输出若干行，每行一个整数，按从小到大的顺序输出 $s_2$ 在 $s_1$ 中出现的位置。\n最后一行输出 $|s_2|$ 个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。\n样例 #1 样例输入 #1 1 2 ABABABC ABA 样例输出 #1 1 2 3 1 3 0 0 1 提示 样例 1 解释 。\n对于 $s_2$ 长度为 $3$ 的前缀 ABA，字符串 A 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。\n数据规模与约定 本题采用多测试点捆绑测试，共有 3 个子任务。\nSubtask 1（30 points）：$|s_1| \\leq 15$，$|s_2| \\leq 5$。 Subtask 2（40 points）：$|s_1| \\leq 10^4$，$|s_2| \\leq 10^2$。 Subtask 3（30 points）：无特殊约定。 对于全部的测试点，保证 $1 \\leq |s_1|,|s_2| \\leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; get_prefix_table(string pattern) { int n = pattern.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; pattern[i] != pattern[j]) { j = pi[j-1]; } if (pattern[i] == pattern[j]) { j++; } pi[i] = j; } return pi; } vector\u0026lt;int\u0026gt; kmp(string text, string pattern) { vector\u0026lt;int\u0026gt; pi = get_prefix_table(pattern); vector\u0026lt;int\u0026gt; matches; for (int i = 0, j = 0; i \u0026lt; text.length(); i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; text[i] != pattern[j]) { j = pi[j-1]; } if (text[i] == pattern[j]) { j++; } if (j == pattern.length()) { matches.push_back(i - j + 1); j = pi[j-1]; } } return matches; } int main() { string s1, s2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; // 使用 KMP 算法查找所有出现位置 vector\u0026lt;int\u0026gt; matches = kmp(s1, s2); // 输出出现位置 for (int i = 0; i \u0026lt; matches.size(); i++) { cout \u0026lt;\u0026lt; matches[i] \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } // 计算 s2 的前缀的最长 border 长度 vector\u0026lt;int\u0026gt; pi = get_prefix_table(s2); for (int i = 0; i \u0026lt; s2.length(); i++) { cout \u0026lt;\u0026lt; pi[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/kmp/","title":"KMP模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const int MAXN = 1e5 + 5; // 最大数组长度 const int MAXK = 25; // log2(MAXN) 向上取整 int a[MAXN]; // 输入数组 int st[MAXN][MAXK + 1]; // ST表 int Log2[MAXN]; void build(int n) { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; // 初始化第一列 } for (int j = 1; j \u0026lt;= MAXK; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = min(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); // 更新ST表 } } for (int i = 2; i \u0026lt;= n; ++i) Log2[i] = Log2[i / 2] + 1; } int query(int l, int r) { int k = Log2[r - l + 1]; // 计算区间长度的对数，向下取整 return min(st[l][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); // 返回区间最小值 } 【模板】ST 表 题目背景 这是一道 ST 表经典题——静态区间最大值\n请注意最大数据时限只有 0.8s，数据强度不低，请务必保证你的每次查询复杂度为 $O(1)$。若使用更高时间复杂度算法不保证能通过。\n如果您认为您的代码时间复杂度正确但是 TLE，可以尝试使用快速读入：\n1 2 3 4 5 6 7 inline int read() { int x=0,f=1;char ch=getchar(); while (ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if (ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while (ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-48;ch=getchar();} return x*f; } 函数返回值为读入的第一个整数。\n快速读入作用仅为加快读入，并非强制使用。\n题目描述 给定一个长度为 $N$ 的数列，和 $ M $ 次询问，求出每一次询问的区间内数字的最大值。\n输入格式 第一行包含两个整数 $N,M$，分别表示数列的长度和询问的个数。\n第二行包含 $N$ 个整数（记为 $a_i$），依次表示数列的第 $i$ 项。\n接下来 $M$ 行，每行包含两个整数 $l_i,r_i$，表示查询的区间为 $[l_i,r_i]$。\n输出格式 输出包含 $M$ 行，每行一个整数，依次表示每一次询问的结果。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 8 9 10 8 8 9 3 1 7 5 6 0 8 1 6 1 5 2 7 2 6 1 8 4 8 3 7 1 8 样例输出 #1 1 2 3 4 5 6 7 8 9 9 7 7 9 8 7 9 提示 对于 $30%$ 的数据，满足 $1\\le N,M\\le 10$。\n对于 $70%$ 的数据，满足 $1\\le N,M\\le {10}^5$。\n对于 $100%$ 的数据，满足 $1\\le N\\le {10}^5$，$1\\le M\\le 2\\times{10}^6$，$a_i\\in[0,{10}^9]$，$1\\le l_i\\le r_i\\le N$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; const int MAXN = 1e5 + 5; // 最大数组长度 const int MAXK = 25; // log2(MAXN) 向上取整 int a[MAXN]; // 输入数组 int st[MAXN][MAXK + 1]; // ST表 int Log2[MAXN]; void build(int n) { for (int i = 1; i \u0026lt;= n; i++) { st[i][0] = a[i]; // 初始化第一列 } for (int j = 1; j \u0026lt;= MAXK; j++) { for (int i = 1; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) { st[i][j] = max(st[i][j - 1], st[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); // 更新ST表 } } for (int i = 2; i \u0026lt;= n; ++i) Log2[i] = Log2[i / 2] + 1; } int query(int l, int r) { int k = Log2[r - l + 1]; // 计算区间长度的对数，向下取整 return max(st[l][k], st[r - (1 \u0026lt;\u0026lt; k) + 1][k]); // 返回区间最小值 } inline int read() { int x=0,f=1;char ch=getchar(); while (ch\u0026lt;\u0026#39;0\u0026#39;||ch\u0026gt;\u0026#39;9\u0026#39;){if (ch==\u0026#39;-\u0026#39;) f=-1;ch=getchar();} while (ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;){x=x*10+ch-48;ch=getchar();} return x*f; } int main() { int n,m; n=read(); m=read(); for(int i=1;i\u0026lt;=n;i++){ a[i]=read(); } build(n); while(m--){ int l=read(),r=read(); printf(\u0026#34;%d\\n\u0026#34;,query(l,r)); } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/st/","title":"ST表模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 深度优先搜索，用于求每个节点的深度和祖先信息 void dfs(int u, int fa) { depth[u] = depth[fa] + 1; // 当前节点的深度为父节点的深度加一 p[u][0] = fa; // 当前节点的 2^0 级祖先为父节点 // 递推求出当前节点的 2^i 级祖先 for (int i = 1; i \u0026lt; M; i ++ ) p[u][i] = p[p[u][i - 1]][i - 1]; // 遍历当前节点的每一个儿子，递归调用 dfs 函数 for (auto v : g[u]) if (v != fa) // 避免向父节点递归 dfs(v, u); } // 求两个节点的最近公共祖先 int lca(int a, int b) { if (depth[a] \u0026lt; depth[b]) swap(a, b); // 保证 a 深度不小于 b // 先将 a 跳到和 b 同一深度 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (depth[p[a][i]] \u0026gt;= depth[b]) a = p[a][i]; if (a == b) return a; // 特判 a 和 b 在同一条链上的情况 // 一起向上跳，直到 a 和 b 的第一个不同的祖先 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (p[a][i] != p[b][i]) { a = p[a][i]; b = p[b][i]; } return p[a][0]; // 返回 a 的父节点，即为 LCA } 【模板】最近公共祖先（LCA） 题目描述 如题，给定一棵有根多叉树，请求出指定两个点直接最近的公共祖先。\n输入格式 第一行包含三个正整数 $N,M,S$，分别表示树的结点个数、询问的个数和树根结点的序号。\n接下来 $N-1$ 行每行包含两个正整数 $x, y$，表示 $x$ 结点和 $y$ 结点之间有一条直接连接的边（数据保证可以构成树）。\n接下来 $M$ 行每行包含两个正整数 $a, b$，表示询问 $a$ 结点和 $b$ 结点的最近公共祖先。\n输出格式 输出包含 $M$ 行，每行包含一个正整数，依次为每一个询问的结果。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 8 9 10 5 5 4 3 1 2 4 5 1 1 4 2 4 3 2 3 5 1 2 4 5 样例输出 #1 1 2 3 4 5 4 4 1 4 4 提示 对于 $30%$ 的数据，$N\\leq 10$，$M\\leq 10$。\n对于 $70%$ 的数据，$N\\leq 10000$，$M\\leq 10000$。\n对于 $100%$ 的数据，$1 \\leq N,M\\leq 500000$，$1 \\leq x, y,a ,b \\leq N$，不保证 $a \\neq b$。\n样例说明：\n该树结构如下：\n第一次询问：$2, 4$ 的最近公共祖先，故为 $4$。\n第二次询问：$3, 2$ 的最近公共祖先，故为 $4$。\n第三次询问：$3, 5$ 的最近公共祖先，故为 $1$。\n第四次询问：$1, 2$ 的最近公共祖先，故为 $4$。\n第五次询问：$4, 5$ 的最近公共祖先，故为 $4$。\n故输出依次为 $4, 4, 1, 4, 4$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int N = 500010, M = 20; int n, m, s; // n：节点数，m：查询次数，s：根节点编号 int depth[N], p[N][M]; // depth：每个节点的深度，p：每个节点的 2^i 级祖先 vector\u0026lt;int\u0026gt; g[N]; // g：树的邻接表表示 // 深度优先搜索，用于求每个节点的深度和祖先信息 void dfs(int u, int fa) { depth[u] = depth[fa] + 1; // 当前节点的深度为父节点的深度加一 p[u][0] = fa; // 当前节点的 2^0 级祖先为父节点 // 递推求出当前节点的 2^i 级祖先 for (int i = 1; i \u0026lt; M; i ++ ) p[u][i] = p[p[u][i - 1]][i - 1]; // 遍历当前节点的每一个儿子，递归调用 dfs 函数 for (auto v : g[u]) if (v != fa) // 避免向父节点递归 dfs(v, u); } // 求两个节点的最近公共祖先 int lca(int a, int b) { if (depth[a] \u0026lt; depth[b]) swap(a, b); // 保证 a 深度不小于 b // 先将 a 跳到和 b 同一深度 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (depth[p[a][i]] \u0026gt;= depth[b]) a = p[a][i]; if (a == b) return a; // 特判 a 和 b 在同一条链上的情况 // 一起向上跳，直到 a 和 b 的第一个不同的祖先 for (int i = M - 1; i \u0026gt;= 0; i -- ) if (p[a][i] != p[b][i]) { a = p[a][i]; b = p[b][i]; } return p[a][0]; // 返回 a 的父节点，即为 LCA } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; s; // 读入节点数、查询次数和根节点编号 // 逐个读入每条边，构建树的邻接表表示 for (int i = 1; i \u0026lt; n; i ++ ) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; g[a].push_back(b); g[b].push_back(a); } dfs(s, 0); // 求每个节点的深度和祖先信息 while (m -- ) { int a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; // 读入查询 cout \u0026lt;\u0026lt; lca(a, b) \u0026lt;\u0026lt; endl; // 输出 } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/lca/","title":"倍增LCA模板"},{"content":"模板 只适用于模数为质数的情况(费马小定理) 1 2 3 4 5 6 7 vector\u0026lt;long long\u0026gt; inv_vec(long long n, long long m) { vector\u0026lt;long long\u0026gt; inv(n + 1, 1); for (long long i = 2; i \u0026lt;= n; i++) { inv[i] = (m - m / i) * inv[m % i] % m; } return inv; } 【模板】乘法逆元 题目背景 这是一道模板题\n题目描述 给定 $n,p$ 求 $1\\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。\n这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\\equiv1\\pmod p$ 的解。\n输入格式 一行两个正整数 $n,p$。\n输出格式 输出 $n$ 行，第 $i$ 行表示 $i$ 在模 $p$ 下的乘法逆元。\n样例 #1 样例输入 #1 1 10 13 样例输出 #1 1 2 3 4 5 6 7 8 9 10 1 7 9 10 8 11 2 5 3 4 提示 $ 1 \\leq n \\leq 3 \\times 10 ^ 6, n \u0026lt; p \u0026lt; 20000528 $\n输入保证 $ p $ 为质数。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;iostream\u0026gt; using namespace std; const int N=3e6+2; long long inv[N]; void inv_vec(long long n, long long m) { inv[0]=1; inv[1]=1; for (long long i = 2; i \u0026lt;= n; i++) { inv[i] = (m - m / i) * inv[m % i] % m; printf(\u0026#34;%lld\\n\u0026#34;,inv[i]); } } int main(){ int n,p; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;p); printf(\u0026#34;1\\n\u0026#34;); inv_vec(n,p); return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/inv2/","title":"乘法逆元递推模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 long long extgcd(long long a, long long b, long long \u0026amp;x, long long \u0026amp;y) { if (b == 0) { x = 1; y = 0; return a; } long long d = extgcd(b, a % b, y, x); y -= a / b * x; return d; } long long inv(long long a, long long m) { long long x, y; if (extgcd(a, m, x, y) != 1) { return -1; // 不存在乘法逆元 } return (x % m + m) % m; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/inv1/","title":"乘法逆元模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 10 FOR(p,0,n){ while(!maxs.empty()\u0026amp;\u0026amp;maxs.back()\u0026lt;a[p])maxs.pop_back(); while(!mins.empty()\u0026amp;\u0026amp;mins.back()\u0026gt;a[p])mins.pop_back(); maxs.push_back(a[p]); mins.push_back(a[p]); ans1[p]=maxs.front(); ans2[p]=mins.front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;maxs.front()==a[p-k+1])maxs.pop_front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;mins.front()==a[p-k+1])mins.pop_front(); } 滑动窗口 /【模板】单调队列 题目描述 有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。\n例如：\nThe array is $[1,3,-1,-3,5,3,6,7]$, and $k = 3$。\n输入格式 输入一共有两行，第一行有两个正整数 $n,k$。 第二行 $n$ 个整数，表示序列 $a$\n输出格式 输出共两行，第一行为每次窗口滑动的最小值\n第二行为每次窗口滑动的最大值\n样例 #1 样例输入 #1 1 2 8 3 1 3 -1 -3 5 3 6 7 样例输出 #1 1 2 -1 -3 -3 -3 3 3 3 3 5 5 6 7 提示 【数据范围】 对于 $50%$ 的数据，$1 \\le n \\le 10^5$；\n对于 $100%$ 的数据，$1\\le k \\le n \\le 10^6$，$a_i \\in [-2^{31},2^{31})$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e6; int a[N],ans1[N],ans2[N]; deque\u0026lt;int\u0026gt; maxs,mins; int main() { ios int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; FOR(i,0,n){ cin\u0026gt;\u0026gt;a[i]; } FOR(p,0,n){ while(!maxs.empty()\u0026amp;\u0026amp;maxs.back()\u0026lt;a[p])maxs.pop_back(); while(!mins.empty()\u0026amp;\u0026amp;mins.back()\u0026gt;a[p])mins.pop_back(); maxs.push_back(a[p]); mins.push_back(a[p]); ans1[p]=maxs.front(); ans2[p]=mins.front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;maxs.front()==a[p-k+1])maxs.pop_front(); if(p-k\u0026gt;=-1\u0026amp;\u0026amp;mins.front()==a[p-k+1])mins.pop_front(); } FOR(i,k-1,n){ cout\u0026lt;\u0026lt;ans2[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; FOR(i,k-1,n){ cout\u0026lt;\u0026lt;ans1[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/monotonicqueue/","title":"单调队列模板"},{"content":"模板1 这种思路通常用于寻找右边的数（求左边时倒叙即可） 每次stack弹出时才记录答案，因此需要维护一个数组或者哈希表 确定单调性与目标相反即可，若求右最小，单调增（方向指的是自底向顶，后面同），最大反之即可 这里以求右边NGE为代表 1 2 3 4 5 6 7 8 9 10 11 12 const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; FOR(i,1,n+1){ while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;a[i]){ b[s.top()]=i; s.pop(); } s.push(i); } } 模板2 这种思路通常用于寻找左边的数 寻找右边时，应反转列表（实际上倒叙即可）来看 这种写法每次维护后的栈顶即使答案 这里以求右边NGE为代表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; for(int i=n;i\u0026gt;0;i--){ //这里的等号要注意，不然如 5，5 的话返回的是 2，0（下标从1开始） while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;=a[i]){ s.pop(); } if(!s.empty()){ b[i]=s.top(); } s.push(i); } } 【模板】单调栈 题目背景 模板题，无背景。\n2019.12.12 更新数据，放宽时限，现在不再卡常了。\n题目描述 给出项数为 $n$ 的整数数列 $a_{1 \\dots n}$。\n定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的下标，即 $f(i)=\\min_{i\u0026lt;j\\leq n, a_j \u0026gt; a_i} {j}$。若不存在，则 $f(i)=0$。\n试求出 $f(1\\dots n)$。\n输入格式 第一行一个正整数 $n$。\n第二行 $n$ 个正整数 $a_{1\\dots n}$。\n输出格式 一行 $n$ 个整数 $f(1\\dots n)$ 的值。\n样例 #1 样例输入 #1 1 2 5 1 4 2 3 5 样例输出 #1 1 2 5 4 5 0 提示 【数据规模与约定】\n对于 $30%$ 的数据，$n\\leq 100$；\n对于 $60%$ 的数据，$n\\leq 5 \\times 10^3$ ；\n对于 $100%$ 的数据，$1 \\le n\\leq 3\\times 10^6$，$1\\leq a_i\\leq 10^9$。\nCODE1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; FOR(i,1,n+1){ while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;a[i]){ b[s.top()]=i; s.pop(); } s.push(i); } } int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,1,n+1)cin\u0026gt;\u0026gt;a[i]; NGE(n); FOR(i,1,n+1)cout\u0026lt;\u0026lt;b[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } CODE2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=3e6+3; int a[N],b[N]; void NGE(int n){ stack\u0026lt;int\u0026gt; s; for(int i=n;i\u0026gt;0;i--){ while(!s.empty()\u0026amp;\u0026amp;a[s.top()]\u0026lt;=a[i]){ s.pop(); } if(!s.empty()){ b[i]=s.top(); } s.push(i); } } int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,1,n+1)cin\u0026gt;\u0026gt;a[i]; NGE(n); FOR(i,1,n+1)cout\u0026lt;\u0026lt;b[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/monotonicstack/","title":"单调栈模板"},{"content":"Basic Counting Principles The product rule 乘法原理\nExercise •Prove Theorem: $ if |S| = n, then |P(S)| = 2^n$\nThe sum rule 加法原理\nThe Inclusion-Exclusion Principle 容斥原理\nThe Pigeonhole Principle 抽屉原理\nTheorem 1: If k is a positive integer and k + 1 or more objects are placed into k boxes, then there is at least one box containing two or more of the objects.\nTheorem 2: If n objects are placed into k boxes, then there is at least one box containing at least n/k objects.\nPermutation 排列（考虑顺序） $P(n, r) = n!/(n − r)!$\nCombination 组合（不考虑顺序） $C(n, r), or (^n_r)$\n隔板法 How many solutions does the equation a + b + c = 11 have where a, b, and c are non-negative integers?\nBinomial Coefficients 二项式定理： Recurrence Relations Linear Homogeneous recurrence relation Theorem 1: Let $c_1$ and $c_2$ be real numbers. Suppose that $r^2 – c_1 – c_2 = 0$ has two distinct roots $r_1$ and $r_2$. Then the sequence ${a_n}$ is a solution of the recurrence relation $a_n= c_1a_{n-1} + c_2a_{n-2}$ if and only if $a_n= k_1r_1^n+k_2r_2^n$ for $n = 0, 1, 2, …,$ where $k_1$ and $k_2$ are constants.\n","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/counting/","title":"离散数学————Counting"},{"content":"欧拉筛 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const int N=100; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 【模板】线性筛素数 题目背景 本题已更新，从判断素数改为了查询第 $k$ 小的素数\n提示：如果你使用 cin 来读入，建议使用 std::ios::sync_with_stdio(0) 来加速。\n题目描述 如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。\n输入格式 第一行包含两个正整数 $n,q$，分别表示查询的范围和查询的个数。\n接下来 $q$ 行每行一个正整数 $k$，表示查询第 $k$ 小的素数。\n输出格式 输出 $q$ 行，每行一个正整数表示答案。\n样例 #1 样例输入 #1 1 2 3 4 5 6 100 5 1 2 3 4 5 样例输出 #1 1 2 3 4 5 2 3 5 7 11 提示 【数据范围】\n对于 $100%$ 的数据，$n = 10^8$，$1 \\le q \\le 10^6$，保证查询的素数不大于 $n$。\nData by NaCly_Fish.\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e8; int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int main() { ios int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; get_primes(n); while(q--){ int x; cin\u0026gt;\u0026gt;x; cout\u0026lt;\u0026lt;primes[x-1]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-05-08T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/eulersieve/","title":"欧拉筛模板"},{"content":"按序合并路径压缩优化并查集 封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Buf { public: Buf(int sz) : root(sz), rank(sz) { for (int i = 0; i \u0026lt; sz; i++) { root[i] = i; rank[i] = 1; } } int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] \u0026lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(int x, int y) { return find(x) == find(y); } private: vector\u0026lt;int\u0026gt; root; vector\u0026lt;int\u0026gt; rank; }; 非封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ll root[MAXN],rank[MAXN],n; void initbuf(ll n){ for (ll i = 0; i \u0026lt; n; i++) { root[i] = i; } } ll find(ll x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(ll x, ll y) { ll rootX = find(x); ll rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) root[rootY] = rootX; else if (rank[rootX] \u0026lt; rank[rootY])root[rootX] = rootY; else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(ll x, ll y) { return find(x) == find(y); } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/buf/","title":"并查集模板"},{"content":"模板 1 2 3 4 5 6 7 8 9 ll qpow(ll a,ll b,ll p){ ll ans=1%p; while(b){ if(b\u0026amp;1)ans=(ans*a)%p; b\u0026gt;\u0026gt;=1; a=(a*a)%p; } return ans; } 题目描述 给你三个整数 $a,b,p$，求 $a^b \\bmod p$。\n输入格式 输入只有一行三个整数，分别代表 $a,b,p$。\n输出格式 输出一行一个字符串 a^b mod p=s，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。\n样例 #1 样例输入 #1 1 2 10 9 样例输出 #1 1 2^10 mod 9=7 提示 样例解释\n$2^{10} = 1024$，$1024 \\bmod 9 = 7$。\n数据规模与约定\n对于 $100%$ 的数据，保证 $0\\le a,b \u0026lt; 2^{31}$，$a+b\u0026gt;0$，$2 \\leq p \\lt 2^{31}$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; ll qpow(ll a,ll b,ll p){ ll ans=1%p; while(b){ if(b\u0026amp;1)ans=(ans*a)%p; b\u0026gt;\u0026gt;=1; a=(a*a)%p; } return ans; } int main() { ios ll a,b,p; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; ll res=qpow(a,b,p); cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;^\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;\u0026#34; mod \u0026#34;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#34;=\u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/qpowp/","title":"快速幂取余模板"},{"content":" A relation is a structure that is used to represent the relationships between elements\nCategory of relations Binary relations N-ary relations Binary Relations A binary relation R from the set 𝐴 to the set 𝐵 is a subset of 𝐴 × 𝐵.\nR is a set of ordered pairs in the form (𝑎, 𝑏) where 𝑎 is from 𝐴 and 𝑏 is from 𝐵.\na R b denotes (𝑎, 𝑏) ∈ 𝑅, called 𝑎 is related to 𝑏 by R\nFunctions and Relations Are all the functions relations? Yes Are all relations functions? No Relation on the Set A relation on the set is a relation from 𝐴 to 𝐴. Properties of Relations Reflexive A relation 𝑅 on a set 𝐴 is called reflexive if (𝑎, 𝑎) ∈ 𝑅 for every element 𝑎 ∈ A\nSymmetric A relation 𝑅 on a set 𝐴 is called symmetric if (𝑏, 𝑎) ∈ 𝑅 whenever (𝑎, 𝑏) ∈ R\nAnti-symmetric relation 𝑅 on a set 𝐴 is called anti-symmetric if whenever (𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑎) ∈ 𝑅, then 𝑎 = 𝑏\nTransitive A relation 𝑅 on a set 𝐴 is called transitive if whenever (𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑐) ∈ 𝑅, then (𝑎, 𝑐) ∈ 𝑅\nCombining Relations The composite of 𝑅 and 𝑆 (𝑆 ◦ 𝑅): consisting of all ordered pairs (𝑎, 𝑐) where 𝑎 ∈ 𝐴, and 𝑐 ∈ 𝐶 if there exists 𝑏 such that (𝑎, 𝑏) ∈ 𝑅 and (𝑏, 𝑐) ∈ 𝑆.\nE.g.,\n▪ 𝐴 = {1}, 𝐵 = {0, 1}, 𝐶 = {2, 3}\n▪ 𝑅 = {(1, 0), (1, 1)} (a relation from 𝐴 to 𝐵)\n▪ 𝑆 = {(0, 2), (1, 3)} (a relation from 𝐵 to 𝐶)\n▪ 𝑆 ◦ 𝑅 = {(1, 2), (1, 3)}\nPowers of a Relation Let 𝑅 be a relation on the set 𝐴. The powers 𝑅𝑛 for integer 𝑛 with 𝑛 \u0026gt; 0 are defined recursively by $R^1 = R$\n$R^{n}=R^{n-1}◦R$\nTheorem: The relation 𝑅 on a set 𝐴 is transitive if and only if 𝑅^𝑛 ⊆ 𝑅 for 𝑛 = 1, 2, 3, ⋯\n𝑛-ary Relations Let 𝐴1, 𝐴2, … , 𝐴𝑛 be sets. An 𝑛-ary relation on these sets is a subset of 𝐴1 × 𝐴2 × ⋯ × 𝐴𝑛 Domain: 𝐴1 × 𝐴2 × ⋯ × 𝐴𝑛 Degree: n Relations and Database Currently, the most commonly used databases are relational databases. Each database consists of multiple relations. Each relation is presented as a table. Operations on n-ary Relations Selection operator 𝜎: 𝑛-ary relation 𝑅 condition 𝑐 Selection operator 𝜎𝑐: maps 𝑅 to an 𝑛-ary relations 𝑇, where all the tuples in 𝑇 satisfy the condition 𝑐.\ni.e. 𝜎_{𝑚𝑎𝑗𝑜𝑟}=\u0026ldquo;𝐶𝑜𝑚𝑝𝑢𝑡𝑒𝑟 𝑆𝑐𝑖𝑒𝑛𝑐𝑒\u0026rdquo; 𝐺𝑟𝑎𝑑𝑒𝑅𝑒𝑝𝑜𝑟𝑡 = {(𝐽𝑜ℎ𝑛,001,𝐶𝑜𝑚𝑝𝑢𝑡𝑒𝑟 𝑆𝑐𝑖𝑒𝑛𝑐𝑒, 3.5)} Projection operator 𝜋: the input relation is on 𝑛 tuples (𝑎1, 𝑎2, ⋯ , 𝑎𝑛) , the output relation is on 𝑚 tuples (𝑎𝑖_1,𝑎𝑖_2, ⋯ , 𝑎𝑖_𝑚), 𝑚 \u0026lt; 𝑛. Projection operator 𝜋𝑖1,𝑖2,⋯,𝑖𝑚: removes the tuples not in the 𝑚-tuple (𝑎𝑖1𝑎𝑖2, ⋯ , 𝑎𝑖𝑚) list i.e. 𝜋_{𝑛𝑎𝑚𝑒,𝐺𝑃𝐴} (𝐺𝑟𝑎𝑑𝑒𝑅𝑒𝑝𝑜𝑟𝑡) = {(𝐽𝑜ℎ𝑛, 3.5 ),( 𝑇𝑜𝑛𝑦, 3.2 ),( 𝐽𝑜𝑛𝑎𝑠, 3.3)} Equivalence Relations A relation on a set 𝐴 is called an equivalence relation if it is reflexive, symmetric, and transitive. Let 𝑅 be an equivalence relation on 𝐴. Equivalent class Equivalent class -\u0026gt; Equivalent relations\nPartition All the equivalent classes obtained from 𝐴 through an equivalent class are either same or disjoint. These disjoint classes are subsets of 𝐴. The union of these subsets is 𝐴. These subsets are called a partition of A In general, (𝐴1, 𝐴2, ⋯ , 𝐴𝑛) is a partition of 𝐴 if: 𝐴𝑖 ≠ ∅ for all 1 ≤ 𝑖 ≤ 𝑛 𝐴𝑖 ∩ 𝐴𝑗 = ∅ for all 1 ≤ 𝑖,𝑗 ≤ 𝑛 𝐴1 ∪ 𝐴2 ∪ ⋯ ∪ 𝐴𝑛 = A Theorem: Let 𝑅 be an equivalence relation on a nonempty set 𝐴. The following statements are equivalent:\na R b [𝑎] = [𝑏] 𝑎 ∩ [𝑏] ≠ ∅ ","date":"2023-05-05T00:00:00Z","image":"https://img0.baidu.com/it/u=1209717743,1836540112\u0026fm=253\u0026fmt=auto\u0026app=138\u0026f=JPEG?w=889\u0026h=500","permalink":"https://open17.github.io/CpHugo/p/distcreterelations/","title":"离散数学——Relations"},{"content":"Sets A set is a collection of objects Sets are used to group objects together Three ways to express the members in a set - List all the members - Use predicates - Use suspension(省略号)points(must be inferred) universal set $ℕ$ : the set of all natural numbers $ℤ$ : the set of integers $ℤ^+$ : the set of all the positive integers $ℚ$: the set of all rational numbers $ℝ$: the set of all the real numbers $ℂ$: the set of all complex numbers Venn Diagrams two basic shapes A rectangle: indicates the universal set Circles or other shapes: indicate normal sets Elements and Sets $A∈B$ : A is in or is an element of B $A∉B$ : A is not in or is not an element of B Subsets Subsets Proper subsets(真子集) Empty sets Cardinality number of distinct elements in a set\nThe cardinality of a set s is denoted as |s|\nPower Sets $P(S) = {A|A ⊆ S}$\nTheorem of Power Sets: $ if |S| = n, then |P(S)| = 2^n$\nOrdered n-tuple The form (1, 2, … , ) or \u0026lt; 1, 2, … , \u0026gt; (1,2) not equal to (2,1) Cartesian Product(笛卡尔乘积) Cartesian product of $S_1, S_2, ⋯ ,S_n (denoted S_1 × S_2 × ⋯ ×S_n )$ $S_1 × S_2 × ⋯ ×S_n = {(a1, a2, … ,an )|a_1 ∈ S_1 ∧ a_2 ∈ S_2 ∧⋯ ∧ a_n ∈ S_n}$\nDisjoint Sets If A ∩ B = ∅ then A and B are disjoint. If A ∩ B ≠ ∅ then A and B are overlapped. function conditions A function from to is a subset of × which satisfies the following two conditions\n1.$ ∀ x(x ∈ A → ∃ y(y ∈ B ∧ (x,y) ∈f)) $\n2. $ (((x_1,y_1 ) ∈ f ∧ (x_1,y_2 ) ∈ f) → y_1 = y_2)$\nImage, Pre-image and Range(值域) If $y = f(x)$ from set A to set B, then\ny is called the image of x under f x is called a pre-image of y the set of all the images of the elements in the domain under is called the range of f, f(A) = {f(x)|x ∈ A} injective function（单射） f is one-to-one\nurjective function (满射) Onto function :$∀y ∈ B (∃x(x ∈A ∧f (x) =y ))$\nbijective function (双射) [One-to-One and onto function] is also called bijective function\nFloor functions Denoted $\\lfloor x \\rfloor$ The largest integer less than or equivalent to x Ceiling functions Denoted $\\lceil x \\rceil$ The smallest integer greater than or equivalent to x Sequences 数列 Sequences are ordered lists of elements • A sequence is a function from a subset of the set of integers ({0, 1, 2, 3, … } or {1, 2, 3, … }) to a set , denoted {$a_n$}. The integers determine the positions of the elements in the list\nSummations 求和 A summation is the value of the sum of the terms of a sequence.\nSpecial Summations Geometric series 等比数列和 $\\sum^n_{j=0}ar^j$\nharmonic series $\\sum^n_{j=1} \\frac{1}{j}$\n","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/sfss/","title":"离散数学——SFSS"},{"content":"【模板】并查集 题目描述 如题，现在有一个并查集，你需要完成合并和查询操作。\n输入格式 第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。\n接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。\n当 $Z_i=1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。\n当 $Z_i=2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出 Y ；否则输出 N 。\n输出格式 对于每一个 $Z_i=2$ 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 8 4 7 2 1 2 1 1 2 2 1 2 1 3 4 2 1 4 1 2 3 2 1 4 样例输出 #1 1 2 3 4 N Y N Y 提示 对于 $30%$ 的数据，$N \\le 10$，$M \\le 20$。\n对于 $70%$ 的数据，$N \\le 100$，$M \\le 10^3$。\n对于 $100%$ 的数据，$1\\le N \\le 10^4$，$1\\le M \\le 2\\times 10^5$，$1 \\le X_i, Y_i \\le N$，$Z_i \\in { 1, 2 }$。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; class Buf { public: Buf(int sz) : root(sz), rank(sz) { for (int i = 0; i \u0026lt; sz; i++) { root[i] = i; rank[i] = 1; } } int find(int x) { if (x == root[x]) { return x; } return root[x] = find(root[x]); } void unionSet(int x, int y) { int rootX = find(x); int rootY = find(y); if (rootX != rootY) { if (rank[rootX] \u0026gt; rank[rootY]) { root[rootY] = rootX; } else if (rank[rootX] \u0026lt; rank[rootY]) { root[rootX] = rootY; } else { root[rootY] = rootX; rank[rootX] += 1; } } } bool connected(int x, int y) { return find(x) == find(y); } private: vector\u0026lt;int\u0026gt; root; vector\u0026lt;int\u0026gt; rank; }; int main() { ios int n,m,y,x,z; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; Buf a=Buf(n+1); while(m--){ cin\u0026gt;\u0026gt;z\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; if(z==1){ a.unionSet(x,y); } else{ if(a.connected(x,y))cout\u0026lt;\u0026lt;\u0026#34;Y\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;N\u0026#34;; cout\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0003/","title":"洛谷0003——并查集"},{"content":"[TJOI2009] 开关 题目描述 现有 $n$ 盏灯排成一排，从左到右依次编号为：$1$，$2$，……，$n$。然后依次执行 $m$ 项操作。\n操作分为两种：\n指定一个区间 $[a,b]$，然后改变编号在这个区间内的灯的状态（把开着的灯关上，关着的灯打开）； 指定一个区间 $[a,b]$，要求你输出这个区间内有多少盏灯是打开的。 灯在初始时都是关着的。\n输入格式 第一行有两个整数 $n$ 和 $m$，分别表示灯的数目和操作的数目。\n接下来有 $m$ 行，每行有三个整数，依次为：$c$、$a$、$b$。其中 $c$ 表示操作的种类。\n当 $c$ 的值为 $0$ 时，表示是第一种操作。 当 $c$ 的值为 $1$ 时，表示是第二种操作。 $a$ 和 $b$ 则分别表示了操作区间的左右边界。\n输出格式 每当遇到第二种操作时，输出一行，包含一个整数，表示此时在查询的区间中打开的灯的数目。\n样例 #1 样例输入 #1 1 2 3 4 5 6 4 5 0 1 2 0 2 4 1 2 3 0 2 4 1 1 4 样例输出 #1 1 2 1 2 提示 数据规模与约定 对于全部的测试点，保证 $2\\le n\\le 10^5$，$1\\le m\\le 10^5$，$1\\le a,b\\le n$，$c\\in{0,1}$。\\\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e5+9; //开4倍 //n 为维护的数组长度，A为维护的数组 ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //叶子节点可以不更新 if (len \u0026lt;= 1) return; //向下传递lazy标记 if(mark[p]%2)tree[p \u0026lt;\u0026lt; 1] = (len - len / 2)-tree[p\u0026lt;\u0026lt;1]; mark[p \u0026lt;\u0026lt; 1] += mark[p]%2; if(mark[p]%2)tree[p \u0026lt;\u0026lt; 1 | 1] = (len / 2)-tree[p\u0026lt;\u0026lt;1|1]; mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]%2; //向下传递了，自然清除自身的tag mark[p] = 0; } void push_up(int p){ //这里维护的是区间和 tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //如果叶子节点 if (cl == cr) return void(tree[p] = A[cl]); //左右递归建树 int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] = d * (cr - cl + 1)-tree[p]; mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } int main() { ios int m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; build(); int op,x,y; while(m--){ cin\u0026gt;\u0026gt;op; if(op==0){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; update(x,y,1); } else{ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll res=query(x,y); cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0004/","title":"洛谷0004——[TJOI2009] 开关"},{"content":"【模板】线段树 1 题目描述 如题，已知一个数列，你需要进行下面两种操作：\n将某区间每一个数加上 $k$。 求出某区间每一个数的和。 输入格式 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。\n第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。\n接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：\n1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 输出格式 输出包含若干行整数，即为所有操作 2 的结果。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 1 2 3 11 8 20 提示 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。\n对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。\n对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。\n保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。\n【样例解释】\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e5+9; //开4倍 //n 为维护的数组长度，A为维护的数组 ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //叶子节点可以不更新 if (len \u0026lt;= 1) return; //向下传递lazy标记 tree[p \u0026lt;\u0026lt; 1] += mark[p] * (len - len / 2); mark[p \u0026lt;\u0026lt; 1] += mark[p]; tree[p \u0026lt;\u0026lt; 1 | 1] += mark[p] * (len / 2); mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]; //向下传递了，自然清除自身的tag mark[p] = 0; } void push_up(int p){ //这里维护的是区间和 tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //如果叶子节点 if (cl == cr) return void(tree[p] = A[cl]); //左右递归建树 int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] += d * (cr - cl + 1); mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } int main() { ios int m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; FOR(i,1,n+1){ cin\u0026gt;\u0026gt;A[i]; } build(); int op,x,y,k; while(m--){ cin\u0026gt;\u0026gt;op; if(op==1){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;k; update(x,y,k); } else{ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll res=query(x,y); cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2023-05-05T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0005/","title":"洛谷0005——【模板】线段树 1"},{"content":"封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class FenwickTree{ public: int n; vector\u0026lt;int\u0026gt; tree; FenwickTree(int i): n(i),tree(i+1){ for(int a=0;a\u0026lt;=i;a++){ tree[a]=0; } } void update(int i,int val){ while(i\u0026lt;=n){ tree[i]+=val; i+=i\u0026amp;(-i); } } int query(int i){ int res=0; while(i\u0026gt;0){ res+=tree[i]; i-=i\u0026amp;(-i); } return res; } } 非封装模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //n为实际长度 ll tree[MAXN],n; void update(int i,int val){ while(i\u0026lt;=n){ tree[i]+=val; i+=i\u0026amp;(-i); } } int query(int i){ int res=0; while(i\u0026gt;0){ res+=tree[i]; i-=i\u0026amp;(-i); } return res; } ","date":"2023-05-05T00:00:00Z","image":"https://img2.baidu.com/it/u=1929941019,3324507395\u0026fm=253\u0026fmt=auto\u0026app=138\u0026f=JPEG?w=889\u0026h=500","permalink":"https://open17.github.io/CpHugo/p/fenwicktree/","title":"树状数组模板"},{"content":"lazy线段树模板 区间修改logn 区间查询logn （维护存在交换律的信息） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 const int MAXN=1e5+9; //开4倍 //n 为维护的数组长度，A为维护的数组 ll tree[MAXN \u0026lt;\u0026lt; 2], mark[MAXN \u0026lt;\u0026lt; 2], n,A[MAXN]; void push_down(int p, int len) { //叶子节点可以不更新 if (len \u0026lt;= 1) return; //向下传递lazy标记 tree[p \u0026lt;\u0026lt; 1] += mark[p] * (len - len / 2); mark[p \u0026lt;\u0026lt; 1] += mark[p]; tree[p \u0026lt;\u0026lt; 1 | 1] += mark[p] * (len / 2); mark[p \u0026lt;\u0026lt; 1 | 1] += mark[p]; //向下传递了，自然清除自身的tag mark[p] = 0; } void push_up(int p){ //这里维护的是区间和 tree[p] = tree[p \u0026lt;\u0026lt; 1] + tree[p \u0026lt;\u0026lt; 1 | 1]; } void build(int p = 1, int cl = 1, int cr = n) { //如果叶子节点 if (cl == cr) return void(tree[p] = A[cl]); //左右递归建树 int mid = (cl + cr) \u0026gt;\u0026gt; 1; build(p \u0026lt;\u0026lt; 1, cl, mid); build(p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ll query(int l, int r, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r) return tree[p]; push_down(p, cr - cl + 1); ll mid = (cl + cr) \u0026gt;\u0026gt; 1, ans = 0; if (mid \u0026gt;= l) ans += query(l, r, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) ans += query(l, r, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); return ans; } void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n) { //当前被包含 if (cl \u0026gt;= l \u0026amp;\u0026amp; cr \u0026lt;= r){ tree[p] += d * (cr - cl + 1); mark[p] += d; return; } push_down(p, cr - cl + 1); int mid = (cl + cr) \u0026gt;\u0026gt; 1; if (mid \u0026gt;= l) update(l, r, d, p \u0026lt;\u0026lt; 1, cl, mid); if (mid \u0026lt; r) update(l, r, d, p \u0026lt;\u0026lt; 1 | 1, mid + 1, cr); push_up(p); } ","date":"2023-05-05T00:00:00Z","image":"https://img2.baidu.com/it/u=1110941159,2287283460\u0026fm=253\u0026fmt=auto\u0026app=138\u0026f=JPEG?w=889\u0026h=500","permalink":"https://open17.github.io/CpHugo/p/segmenttree/","title":"线段树模板"},{"content":"【深进1.例1】求区间和 题目描述 给定 $n$ 个正整数组成的数列 $a_1, a_2, \\cdots, a_n$ 和 $m$ 个区间 $[l_i,r_i]$，分别求这 $m$ 个区间的区间和。对于所有测试数据，$n,m\\le10^5,a_i\\le 10^4$\n输入格式 共 $n+m+2$ 行。\n第一行，为一个正整数 $n$ 。\n第二行，为 $n$ 个正整数 $a_1,a_2, \\cdots ,a_n$\n第三行，为一个正整数 $m$ 。\n第 $4$ 到第 $n+m+2$ 行，每行为两个正整数 $l_i,r_i$ ，满足$1\\le l_i\\le r_i\\le n$\n输出格式 共 $m$ 行。\n第 $i$ 行为第 $i$ 组答案的询问。\n样例 #1 样例输入 #1 1 2 3 4 5 4 4 3 2 1 2 1 4 2 3 样例输出 #1 1 2 10 5 提示 样例解释：第 1 到第 4 个数加起来和为 10。第 2 个数到第 3 个数加起来和为5。\n对于 50% 的数据：$n,m\\le 1000$ ；\n对于100% 的数据：$n.m\\le 10^5,a_i\\le 10^4$\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+3; int a[N]; int b[N]; int main() { ios int n,m; cin\u0026gt;\u0026gt;n; FOR(i,0,n){ cin\u0026gt;\u0026gt;a[i]; } FOR(i,1,n+1){ b[i]=b[i-1]+a[i-1]; } cin\u0026gt;\u0026gt;m; int l,r; FOR(i,0,m){ cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;b[r]-b[l-1]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0001/","title":"洛谷0001——求区间和"},{"content":"最大加权矩形 题目描述 为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。\n校长先给他们一个 $n\\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如\n1 2 3 4 0 –2 –7 0 9 2 –6 2 -4 1 –4 1 -1 8 0 –2 在左下角：\n1 2 3 9 2 -4 1 -1 8 和为 $15$。\n几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？\n输入格式 第一行：$n$，接下来是 $n$ 行 $n$ 列的矩阵。\n输出格式 最大矩形（子矩阵）的和。\n样例 #1 样例输入 #1 1 2 3 4 5 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 样例输出 #1 1 15 提示 $1 \\leq n\\le 120$\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=123; int a[N][N]; int b[N][N]; int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,0,n){ FOR(j,0,n){ cin\u0026gt;\u0026gt;a[i][j]; } } FOR(i,1,n+1){ FOR(j,1,n+1){ b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i-1][j-1]; } } int ans=-inf; FOR(x1,1,n+1){ FOR(y1,1,n+1){ FOR(x2,x1,n+1){ FOR(y2,y1,n+1){ ans=max(ans,b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1]); } } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/luogu0002/","title":"洛谷0002——最大加权矩形"},{"content":"一维前缀和 1 2 3 // S[i] = a[1] + a[2] + ... a[i] // a[l] + ... + a[r] = S[r] - S[l - 1] S[r] - S[l - 1] 二维前缀和 1 2 3 4 // S[i, j] = 第i行j列格子左上部分所有元素的和 b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j] // 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： b[x2][y2] - b[x1 - 1][y2] - b[x2][y1 - 1] + b[x1 - 1][y1 - 1] 一维差分 1 2 // 给区间[l, r]中的每个数加上c： B[l] += c, B[r + 1] -= c 二维差分 1 2 // 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1][y1] += c, S[x2 + 1][y1] -= c, S[x1][y2 + 1] -= c, S[x2 + 1][y2 + 1] += c tips 从1开始，0开大，防特判 ","date":"2023-05-02T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/presum/","title":"前缀和与差分模板"},{"content":"Topics1 Logic and proofs Set, functions, sequences, and summations Counting Relations Graph theory Tree Boolean algebra Logic and Proofs Propositional logic Truth table (Given a proposition, draw the truth table)\nLogical operators Conjunction ∧\nDisjunction ∨\nExclusive OR ⊕ Implication $→$\nPropositional equivalence Laws De Morgan’s laws (否定拆括号取反) Distributive(分配) laws $p\\rightarrow q=\\neg p \\vee q$ Tautology and contradiction Given two propositions, prove they are equivalent\nPredicates Universal quantification\nExistential quantification\nTranslate a sentence to a logical expression\nProofs Inference rules 推理规则 (prove or disprove an argument)\n肯定前件推理 $p\\wedge( p \\rightarrow q)\\Rightarrow q$ 否定后件推理 $\\neg q \\wedge(p\\rightarrow q) \\Rightarrow \\neg p$ 析取三段论 假说演绎推理 归结推理 Argument Valid argument Invalid argument Proof methods direct proofs Indirect proofs Proof by contraposition(非非反) Proof by contradiction\nExistence proof (constructive and non-constructive) Uniqueness proof (two steps) 存在且仅存在一个 假设存在两个满足,然后证明两个相等\nSets, Functions, Sequences and Summations Sets Subset 子集,空集,非空真子集,真子集\nPowerset (P(S)=A∣A⊆S)\nCardinality 集合元素个数，特别有|P(S)|=$2^n$\nCartesian product(笛卡尔积) 全部组合\nSet operations Set identity (prove two sets are the same)\nDe Morgan’s Law Laws and membership table 0,1表\nFunctions One-to-one functions (injection) 单射,一一对应\nOnto functions (surjection) 满射,全部y都有x\nOne-to-one and onto functions (bijection) 单加满\nSpecial functions Ceiling function上 Floor function下 Sequences and summations Countings Rules Product rule 乘法原理\nSum rule 加法原理\n隔板法 Principles Inclusion-exclusion principle 容斥\nPigeonhole principle 抽屉原理(ceil(n/k))\nPermutation and combination $$P(n,r)=n!/(n-r)!$$\nRecurrence relation $$C(n,r)=n!/[(n-r)!*r!]$$\nConstruct a recurrence relation Solve a recurrence relation $$ a_n=c_1a_{n-1}+c_2a_{n-2} \\ r^2-c_1r-c_2=0 \\ a_n=k_1r_1^n+k_2r_2^n $$\nRelations Representing relations There are several other ways to represent relations\nTables Matrices Graphs Relations on a set A relation on the set is a relation from 𝐴 to 𝐴\nReflexive (a,a) belongs to R for all element in A\nSymmetric 对称\nAnti-symmetric 反对称\nTransitive 传递性\nEquivalence relation Equivalence relation and Partition Equivalence relation ⇔ Partition\nProve a relation is an equivalence relation. Reflexive Symmetric Transitive\nGiven an equivalence relation, list equivalent classes (give the partition) Graph Theory Graph Definition G=(V,E)\nRepresenting graphs (adjacency matrix, adjacency list, and sketch) Isomorphism 邻接矩阵 $bijection f:V_1 \\rightarrow V_2: \\forall a,b \\in V_1((a,b)\\in E_1 \\leftrightarrow (f(a),f(b))\\in E_2) $ Eular path and Eular circuit containing every edge (simple path)\n欧拉回路:each vertex has even degree\n欧拉路径在连通multi: exactly 2 vertices of odd degree\nHamilton path and Hamilton circuit each vertex once\nOre’s theorem If for every pair of nonadjacent vertices u and v in the simple graph G with n vertices, deg(u) + deg(v) ≥ n ,then has a Hamilton circuit.\nDirac’s theorem If the degree of each vertex is great than or equals n/2 in the connected simple graph G with n vertices where n ≥ 3, then G has a Hamilton circuit.\nPlanar graphs r=e–v+2\nEuler’s Formula G is a connected planar simple graph\nv ≥ 3, then e ≤ 3v – 6 G has a vertex of degree not exceeding 5 if v\u0026gt;=3 and no circuits of length 3,then e\u0026lt;=2v-4 Trees Tree traversal Preorder traversal 中左1右\nIn-order traversal 左1中右\nPost-order traversal 左1右中\nExpression forms (conversion among the different forms) 关键 Internal vertices(非叶子节点) represent operations\nLeaves(叶子节点) represent the variables or numbers\nInfix prefix postfix Spanning tree DFS 回溯(字母序)\nBFS 都走(字母序,不重复)\nBoolean Algebra Boolean expressions . 与 product + 或 sum - 非 complement Boolean identities 换成逻辑表达式再换回来记忆\nmin-term(最小项) A min-term of Boolean variables x1, x2, ⋯ ,xn is a Boolean product of literals2 y1y2 , ⋯ , yn where yi (1 ≤ i ≤ n ) is either xi or complement of xi Each min-term has exactly one literal for every variable.\nDNF 任何命题公式，最终都能够化成 ( A 1 ∧ A 2 ) ∨ ( A 3 ∧ A 4 )的形式，这种先 ∧ 合 取 再 ∨ 析 取 的范式，被称为 “析取范式”。\nDNF is the unique sum of min-terms of the variables in the expression,Also called sum of products expansion\nSOP是DNF的化简，DNF是SOP的扩展3\nMaxterms(最大项) A max-term of Boolean variables x1, x2, ⋯ , is the sum of literals y1 + y2+, ⋯ ,yn + where (1 ≤ i ≤ n) is either xi or complement of xi\nCNF 任何命题公式，最终都能够化成 ( A 1 ∨ A 2 ) ∧ ( A 3 ∨ A 4 ) 的形式，这种先 ∨ 析 取 再 ∧ 合 取 的范式，被称为 “ 合取范式”。\nPOS同上\nIf we have DNF for $\\overline F $, then get CNF from $\\overline{\\overline F} $\nEquivalence of expressions Funtion completeness can represent {+ . ——} using Operate O\nLogic circuits Logic gates Logic circuits Karnaugh maps4 1、取大不取小，圈越大，消去的变量越多，与项越简单，能画入大圈就不画入小圈；\n2、圈数越少，化简后的与项就越少；\n3、一个最小项可以重复使用，即只要需要，一个方格可以同时被多圈所圈\nSteps in designing a logic circuit 推荐阅读\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nA literal is a Boolean variable or its complement.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n有些书上定义DNF为SOP，将SOP的扩展叫做CDNF，本文不采用这种定义\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n可以参考\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-05-01T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/dm-quick-review/","title":"review"},{"content":" A tree is a connected undirected simple graph that contains no simple circuits.\nRooted Trees concept A rooted tree is a tree in which one node has been designated the root.\nEvery edge is directed away from the root.\nGiven a vertex 𝑣 in a rooted tree 𝑇:\nParent: unique vertex 𝑢 such that (𝑢,𝑣) is an edge (in the direction from root to 𝑣) Child: any vertex for which 𝑣 is a parent Siblings : vertices with the same parent(兄弟节点) Ancestors : all vertices from root to 𝑣 (except itself) Descendants : vertices with 𝑣 as an ancestors tips A vertex of a tree is called a leaf if it has no children.\nVertices that have children are called internal vertices.\nGame(state) Trees(决策树) Vertices: positions (states) in a game Edges: legal moves from one position (state) to another Leaves: Final positions (states) of a game m-ary Trees(M叉树) A rooted tree is called 𝑚-ary if every internal vertex has no more than 𝑚 children\nIt is called full if every internal (non-leaf) vertex has exactly 𝑚 children. A 2-ary tree is called a binary tree If vertex 𝑣 is in a tree 𝑇, the sub-tree with root 𝑣 is the tree consisting of 𝑣 and all its descendants. Balanced Tree(平衡树) level and height The level of a node is the length of the path from the root to the node (The level of the root is defined to be zero). The height of a tree is maximum level of node.\nbalanced A rooted 𝑚-ary tree with height ℎ is called balanced if all leaves are at levels ℎ or ℎ−1.\nBinary Search Tree (二叉搜索树) 左小右大\nAlgorithms The presentation of an algorithm (from high level to low level):\ndescriptive method in a natural language pseudo code source code Traversal Algorithm Pre-order traversal Let 𝑇 be a rooted tree with root 𝑟. If 𝑇 consists only of 𝑟, then 𝑟 is the preorder traversal of 𝑇. Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right. The preorder traversal of 𝑇 will begin by visiting 𝑟, then 𝑇1 (in preorder), then 𝑇2 (in preorder), etc, until 𝑇𝑛 is traversed in preorder\nIn-order traversal Let 𝑇 be a rooted tree with root 𝑟 If 𝑇 consists only of 𝑟, then 𝑟 is the in-order traversal of 𝑇. Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right. The in-order traversal of 𝑇 will begin by visiting 𝑇1 (in-order), then the root 𝑟, then 𝑇2 (in-order), etc, until 𝑇𝑛 is traversed in-order\nPost-order traversal Let 𝑇 be a rooted tree with root 𝑟 If 𝑇 consists only of 𝑟, then r is the post-order traversal of 𝑇. Otherwise, let 𝑇1 , 𝑇2 , … , 𝑇_𝑛 be the sub-trees at 𝑟 from left to right. The post-order traversal of 𝑇 will begin by visiting 𝑇1 (in post-order), then 𝑇2 (in post-order), etc, then 𝑇𝑛 (in post-order) and finally the root 𝑟.\nExpression Trees The expression tree for an arithmetic expression consists of\nVertices: numbers, +, −, ∗, /, ↑(↑ represents the power function) Edges: linking parts of an expression Internal vertices(非叶子节点) represent operations Leaves(叶子节点) represent the variables or numbers Spanning Trees(生成树) A spanning tree of a connected undirected graph 𝐺 is a sub-graph of 𝐺 that contains all of 𝐺’s vertices and enough of its edges to form a tree.\nHow to obtain? To obtain a spanning tree from a connected undirected graph with cycles:\nRemove edges until there are no cycles\nDepth-First Search Depth-First Search (DFS) proceeds along a path from a vertex 𝑣 as deeply into the graph as possible before backing up (back-tracking). To create a depth-first search (DFS) spanning tree: Traverse the graph using a depth-first search and mark the edges that you follow. After the traversal is complete, the graph’s vertices and marked edges form the spanning tree.\n(If there are multiple choices, choose the next vertex in the alphabetical order.)\nBreadth-First Search Breadth-First Search (BFS) visits every vertex adjacent to a vertex v that it can before visiting any other vertex. To create a breath-first search (BFS) spanning tree Traverse the graph using a bread-first search and mark the edges that you follow. When the traversal is complete, the graph’s vertices and marked edges form the spanning tree.\nMinimum Spanning Trees(最小生成树) A minimum spanning tree in a connected weighted graph is a spanning tree that has the smallest possible sum of weights of edges.\nThere may be several different minimum spanning trees for a particular graph. But the minimum weight is unique.\nPrim Initially, starts from an empty (no vertices, no edges) sub minimum spanning tree 𝑇. Randomly put a vertex 𝑣 into 𝑇. Among all the edges (𝑢,𝑠) such that 𝑢 is in 𝑇 and 𝑠 is not in 𝑇, find the one of the minimum weight. And add the edge and the endpoint to 𝑇. Repeat Step 3 for 𝑛−1 iterations (because a tree has 𝑛−1 edges). Kruskal Initially, starts from a subgraph of all vertices but no edges. Find the edge with the smallest weight. If adding the smallest edge to the subgraph does not create any cycle, add it. (To maintain the tree property.) Otherwise, this edge is not in the MST. So, discard the edge. Repeat steps 2-4 until for 𝑛−1 iterations (because a tree has 𝑛−1 edges). ","date":"2023-05-01T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/dstree/","title":"离散数学---Tree"},{"content":"Graph Theory Graph concepts Definition1 A graph G = (V,E) is a pair and consists of two sets V and such that:\nV is the set of vertices(顶点) E is the set of edges(边) Remember V cannot be empty,but E can(endpoint/node) Each edge have 1 or 2 vertices(1 is a ring) Definition2 (u,v) is an edge connetcing vettices u and v u and v are neighbors (adjacent). (u,v) connects u and v ((u,v) is incident on u and v). Simple graphs each edge connects two different vertices and where no two edges connect the same pair of vertices. Multigraph A multigraph is a graph that may have multiple edges connecting the same pair of vertices. If there are m different edges associated to the same unordered pair of vertices u and v, (u, v) is an edge of multiplicity. Loops(自环) A loop is an edge that connects one vertex to itself. Graphs that may include loops, and possibly multiples edges connecting the same pair of vertices are called pseudo-graphs. Directed Graph(有向图) A directed graph (V,E) consists of a nonempty set V and a set of directed edges E\ntips The edge (u,v) in a directed graph starts at u and ends at v.\nDegree(度) The degree of a vertex in an undirected graph is the number of edges connected with it except that a loop at a vertex(自环算2)contribute twice to the degree of that vertex.\nIn-Degree and Out-Degree(入度、出度) $In:def^-(v)$\n$Out:def^+(v)$\nHandshaking Theorem For an undirected graph G= (V,E):\n$$2|E|=\\sum_{v \\in V}deg(v)$$\nOdd Degree Theorem In a directed graph G = (V,E) $$|E|=\\sum_{v \\in V}deg^-(v)=\\sum_{v \\in V}deg^+(v)$$\nSpecial graphs Complete graphs(完全图) A complete graph is a simple graph in which there is an edge between each pair of distinct vertices, denoted by $K_n$ where n is the number of nodes in the graph\nCycles A cycle is a graph that contains (n ≥ 3) vertices {V1, V2, … ,Vn } and n edges (V1, V2), (V2, V3), …, (Vn, V1), denoted by $C_n$ where is the number of nodes in the graph.\nWheels $Cn$加上中间一个点以及连边，记做$W_n$\nCubes A cube of dimension n($Q_n$)is a simple graph of $2^n$ vertices, where each vertex represents a bit string of length n. Two vertices are adjacent if and only if they differ by one bit.\nBipartite Graphs(二分图) A simple graph G = (V,E ) is called bipartite if its vertex set V can be partitioned into two disjoint set V1 and V2 such that every edge in the graph connects a vertex in V1 and a vertex in V2. V1 and V2 are called a bipartite of the vertex set V of G Theorem(染色法) 前置知识：二分图不存在奇数环\nA simple graph G= (V,E) is bipartite if and only if it is possible to color each vertex with one of two colors so that no adjacent vertices have the same color.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 int n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色 // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i \u0026lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } //source：https://www.acwing.com/blog/content/405/ Complete Bipartite Graphs(完全二分图) $K_{m,n} $\nIn a complete bipartite graph, for any vertex in a subset,there is an edge between it and each vertex in another set.\nOutline Subgraphs and Proper Subgraphs A subgraph H = (W,F) of graph G = (V,E) is made up of vertices W ⊆ V and edges F ⊆ E. A subgraph H of G is a proper subgraph if H ≠ G. Union of Simple Graphs The union of two simple graphs G1 = (V1, E1) and G2 = (V2, E2) is the simple graph G = (V, E) such that V = V1 ∪ V2 and E = E1 ∪ E2\nRepresenting Graphs Adjacency matrix(邻接矩阵):dense graph Adjacency table(邻接表):sparse graph Graph Isomorphism(同构图) 判断同构：推荐使用邻接矩阵判断\nGraph Connectivity Path path of length m from vertexu to vertex v is a sequence of edges e1, e2, … , $e_n$ such that e1 starts at u and $e_n$ ends at v.\nCircuit A circuit is a path that begins and ends at the same vertex in graph.\nSimple path or circuit A simple path or circuit does not pass through the same edge twice or more.\nGraph Connectedness An undirected graph is connected if there is a path between every pair of distinct vertices A directed graph is strongly connected if there is a path from a to b and from b to a whenever a and b are vertices in the graph Euler Paths An Euler path in G is a simple path containing every edge of G An Euler circuit in a graph G is a simple circuit containing every edge of G THEOREM A connected multi-graph has an Euler circuit if and only if each vertex has even degree.\nHamilton Circuits A Hamilton path is a path that traverses each vertex in G exactly once A Hamilton circuit is a circuit that traverses each vertex in G exactly once. Ore’s theorem If for every pair of nonadjacent vertices u and v in the simple graph G with n vertices, deg(u) + deg(v) ≥ n ,then has a Hamilton circuit.\nDirac’s theorem If the degree of each vertex is great than or equals n/2 in the connected simple graph G with n vertices where n ≥ 3, then G has a Hamilton circuit.\nPlanar Graphs In a planar representation of\ne: number of edges v: number of vertices r: number of regions $r= e – v + 2$ Euler’s Formula G is a connected planar simple graph\nv ≥ 3, then e ≤ 3v – 6 G has a vertex of degree not exceeding 5 if v\u0026gt;=3 and no circuits of length 3,then e\u0026lt;=2v-4 ","date":"2023-05-01T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/dmgraph/","title":"离散数学————Graph"},{"content":" 1 2 3 4 5 #include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World!\u0026#34;); return 0; } 基础知识 分号 每个语句必须以分号结束\n符号类型 一定要是英文符号\n注释 单行注释 多行注释(也可单行) 1 2 3 //单行注释 /*多行注释*/ 数据类型 TYPE BYTE MORE char 1 字节 -128 到 127 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 ——— unsigned int 2 或 4 字节 ——— short 2 字节 ——— unsigned short 2 字节 ——— long 4 字节 ——— unsigned long 4 字节 ——— float 4 字节 6 位有效位 double 8 字节 15 位有效位 long double 16 字节 19 位有效位 1 2 3 4 5 6 7 //sizeof可以获取储存字节大小 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;int 存储大小 : %lu \\n\u0026#34;,sizeof(int)); return 0; } 常量 整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。\n整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。\n浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。\n当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。\n字符常量 单引号内 char -\u0026gt; 1字节 转义字符 \\n 换行符号 \\b 退格 \\ (特殊符号) 本身 字符串常量 双引号中\n多行时\n定义常量 1 2 //name=value #define name value 变量 变量名可以是字母、数字和下划线的组合\n规则\n开头必须是字母或 下划线（可以下划线） 不可以是C语言关键字 不能有空格 类型转换 显示转换 1 2 3 c=1.2F b=(int)c //要注意在c中强制转换不是一个函数式转换 隐式转换 方向： 精度上升 特殊： scanf/printf 只能int-chr转换(精度上升的转换都不行？) char - int 转换(显/隐) 详见字符ascii 储存类（不考） 运算符 算数运算符 + - * / 小心隐式转换（加减也会） 除法取全舍去（负时偏向绝对值） 1 2 3 //例如 10/3==-3; 10/(-3)==-3 取模 % 在算法中常/与%使用依次去位数\n(高精度模板题)\n++\u0026ndash; 自增自减 注意Attention！\na++ 先赋值后运算\n++a 先运算后赋值\n赋值运算符 形式： (算数运算符)$=$\n如 a += 1\n关系运算符\n== != \u0026gt; \u0026lt; \u0026lt;= \u0026gt;= 注意Attention！\n在c中不能1\u0026lt;a\u0026lt;b这样判断\n逻辑运算符 与 \u0026amp;\u0026amp; 或 || 非 ! 位运算符号\n详见 位运算 输入输出 输入流 stdin 未读取的不会清空，共享\n1 2 3 4 5 6 //手动清空输入流 //通过连续读取来清空输入流 int r=getchar(); while (r!=EOF){ r=getchar() } 输出流 stdout 连续，不会自动换行 -\u0026gt; \\n的重要性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int main(){ char a; //其实getchar()返回的是int，不过由于char-int的隐式转换，也无所谓 //每当按下回车时getchar会读取stdin中第一个，并将其从stdin中弹出 a=getchar(); //putchar 接收的也是int putchar(a); //scanf 记得占位符正确和写寻地址符 //当然数组名本身即使地址，不要寻地址符 //每当按下回车时getchar会读取stdin中前n个（取决于占位符），并将其从stdin中弹出 scanf(\u0026#34;%c\u0026#34;,\u0026amp;a); //一般函数最后输出结尾都会加上\\n printf(\u0026#34;%c\\n\u0026#34;,a); return 0; } 占位符 占位符 类型 %d int %c char %s str(char[]) %f float %.3f 3位 %lf double %p pointer 字符ascii 32 空格 48-57 数字0-9 65-90 大写字母 97-122 小写字母 1 2 3 4 5 6 7 8 9 10 // 标准输入输出库 #include \u0026lt;stdio.h\u0026gt; int main(){ //隐式转换 97 a int c = \u0026#39;a\u0026#39;; printf(\u0026#34;%c %d\u0026#34;,c,c); //在c中取ascii码值可直接类型转换得出 //而由“11”(str)取得11(int)可调库，或者哈希映射（自建数组下表映射或者ascii映射(+48)) return 0; } 更多输入输出 详见字符串\n文件读写 文件打开和关闭 不要忘记关闭文件\n1 2 3 4 // open FILE *fopen( const char *filename, const char *mode ); // close fclose( FILE *fp ); filename 文件路径 mode 访问模式 mode description r read 只读 w write 只写，重写/新建(会覆盖) a add 只写，追加/新建(不会覆盖) r+ 读写 w+ 读写，重写/新建(会覆盖) a+ 读写，追加/新建(不会覆盖) 二进制模式 \u0026ldquo;rb\u0026rdquo;, \u0026ldquo;wb\u0026rdquo;, \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;rb+\u0026rdquo;, \u0026ldquo;r+b\u0026rdquo;, \u0026ldquo;wb+\u0026rdquo;, \u0026ldquo;w+b\u0026rdquo;, \u0026ldquo;ab+\u0026rdquo;, \u0026ldquo;a+b\u0026rdquo;\nEOF 1 2 //在c中EOF标识符实际为-1 #define EOF -1 读取文件 注意fscanf()先要传入fp，和其它相反\n1 2 3 4 //char *buf 为缓冲区（自己开一个数组） int fgetc( FILE * fp ); char *fgets( char *buf, int n, FILE *fp ); int fscanf(FILE *fp ,const char *s, char *buf); 函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 \u0026lsquo;\\n\u0026rsquo; 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符 int fscanf(FILE *fp, const char *format, \u0026hellip;) 函数文件中读取字符串在遇到第一个空格和换行符时，会停止读取\n写入文件 注意fprintf()先要传入fp，和其它相反\n1 2 3 4 // 失败时返回EOF int fputc( int c, FILE *fp ); int fputs( const char *s, FILE *fp ); int fprintf(FILE * fp,const char*s); 二进制读写 1 2 fread(); fwrite(); 二进制 比特与字节 bit 二进制一个数位 1 byte = 8 bit 进制转换 10进制-\u0026gt;2进制： 除2法取余数 2进制-\u0026gt;10进制： 从右到左依次乘从$2^0$开始到$2^n$的和\n位运算 与 \u0026amp; 或 | 取反 ~ 异或 ^ 左右移 \u0026laquo;\u0026lt; \u0026raquo;\u0026gt; 1 2 3 4 5 6 int a=4; //二进制右移1位即除以2，左一乘以2 //同理，十进制则1位乘除10，注意c中左右移符号是二进制的移动 if (a\u0026gt;\u0026gt;1==a/2){ printf(\u0026#34;True\u0026#34;); } 常见性质(略) 二进制算法 二进制枚举 快速幂 基础结构 分支结构 1 2 3 4 5 6 7 8 9 10 11 12 13 //分支 if (){ } else if (){ } else{ } //三元 a==0?printf(\u0026#34;a=0\u0026#34;):printf(\u0026#34;a!=0\u0026#34;); !!!注意\n如果switch没有break则会继续执行（会触发default或者其它case）\nexpression必须是常量表达式，必须是一个整型或枚举类型\n1 2 3 4 5 6 7 8 9 10 11 12 switch(expression){ case constant-expression : statement(s); break; /* 可选的 */ case constant-expression : statement(s); break; /* 可选的 */ /* 您可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s); } 循环结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int a=10; while(1){ a--; if (a\u0026gt;5){ continue; } printf(\u0026#34;NO\u0026#34;) if (a\u0026lt;4) break; } for(a=10;a\u0026lt;3;a--){ printf(\u0026#34;%d,a\u0026#34;); } do{ printf(\u0026#34;%d\u0026#34;,a); a-=1 }while(a); 省略 如果只跟一个句子，可以省略大括号 单数字作为条件时0假其它真 如下面的句子是合法的\n1 2 3 4 5 6 7 8 9 10 for(int i=0;i\u0026lt;10;i++) for(int j=i;j\u0026lt;10;j++) printf(\u0026#34;%d\u0026#34;,j); if(a==0) printf(\u0026#34;YES!!!\u0026#34;); int a=0; if(!a){ printf(\u0026#34;a is zero\u0026#34;); } 数组与字符串 一维数组 声明格式 type arrayName [ arraySize ]; 1 int a[50]; 初始化(大括号) 1 2 3 4 5 6 7 8 9 //标准初始化 int a[2]={1,2}; //可以只初始化少初始化，但不能多初始化 //即大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目 int a[10]={1,4,3,5}; //如果没有指定数组大小，则其等于初始化个数 int a[]={1,2,4}; 两种访问 下标（索引）从0开始 指针访问（数组名指向数组第一个元素的地址，数组储存连续） 详见指针 高维数组 声明与初始化\n(要记得大小从1开始，但索引从0开始) 1 2 3 4 5 // int a[2][2][2]; // // int a[2][3]={1,2,3,2,4,6} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 - 两种访问 - 下标（索引）从0开始 - 指针访问 - 列指针与行指针 - 单指针（利用连续性） [详见指针](#指针) ### 字符串 \u0026gt;everal ways to initialize a string **一定**以 ***\u0026#39;\\0\u0026#39;*** 结尾 + char str[20] = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\0\u0026#39;}; + char str[20] = \u0026#34;Hello\u0026#34;; // \u0026#39;\\0\u0026#39; is automatically set to str[5] + char str[] = \u0026#34;Hello\u0026#34;; //str\u0026#39;s size is 6 如果已经声明，就不能进行**初始化** #### 易错练习 是否正确？ ```c //注意字符和字符串的引号 //注意隐式转换 char a[]={\u0026#39;a\u0026#39;,\u0026#39;c\u0026#39;,0} 字符串相关 \u0026lt;stdio.h\u0026gt; printf() %s\nsprintf() 1 2 3 4 5 6 7 8 int sprintf( char *str, const char *format, ... ); char buffer[50]; int n, a = 5, b = 3; n = sprintf(buffer, \u0026#34;%d plus %d is %d\u0026#34;, a, b, a+b); // n 实际长度13 //buffer=\u0026#34;5 plus 3 is 8\u0026#34; puts() puts stops printing when it meets \u0026lsquo;\\0\u0026rsquo;.\nscanf() %s 读到空格停止 %ns 读到空格/读n个字符停止 gets() 读一整行，字符数组开小了可能越界\nfgets() fgets(your_line, sizeof(your_line), stdin)\n利用sizeof ，防止越界\n字符串相关 \u0026lt;string.h\u0026gt; strlen() length of str, not including \u0026lsquo;\\0\u0026rsquo;;\nstrcpy(destination,source) 字符串赋值要strcpy，别直接等于号赋值\ncopy string from source to destination(包括\u0026rsquo;\\0\u0026rsquo;)\n小心越界\nstrncpy(destination, source, n) 复制前n个字符，最后自动加上\u0026rsquo;\\0\u0026rsquo;\nstrcmp(str1, str2) 逐位比较ascii，直到某一位ascii不一样，str1\u0026gt;str2 返回 1，相等返回0，其余-1\nstrncmp(str1, str2, n) 前n个\nstrcat(destination, source); 连接，加在dest上，小心越界\n字符串相关 \u0026lt;stdlib.h\u0026gt; atoi(str) str-\u0026gt;int\n支持正负号\n取前面可以转换的，到非数字字符停止(无视空格) ex. atoi(\u0026quot;-10aaa\u0026quot;)=-10\natof(str) • Same as atoi\n• Space, +, - are acceptable\n• An E or e (exponent) is acceptable\n• A decimal point is acceptable\n相关算法（仅作了解） BF，BK，KMP，BM 前缀树 后缀树 AC自动机 其它 基础语法 函数 函数的声明 如果函数放于main函数后面/多文件，需要提前声明 声明时参数的名称并不重要，只有参数的类型是必需的，因此以下都是都是有效声明 1 2 int max(int, int); int max(int a, int b); void 无返回值 返回多个值 利用指针 形式参数 详见作用域 传递数组 传一个指针 传不定长数组(ex. int a[],如果二维需要指定第二维度，int a[][3]) 传定长数组(int a[20]) #define函数 1 2 #define MAX(a,b) a\u0026gt;b?a:b #define SQ(x) x*x 作用域 3 types 在函数或块内部的局部变量,在所有函数外部的全局变量,在形式参数的函数参数定义中\nsmall has big 小可以改大的，大不能改小的\n形参同名替代（小带大） 但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用\n递归 懂得都懂 ——佚名 自顶向下,利用系统栈\n经典题 斐波那契 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int Fibonacci(int n){ if (n\u0026lt;=2){ return 1; } return Fibonacci(n-1)+Fibonacci(n-2); } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;%d\u0026#34;,Fibonacci(n)); return 0; } 命令行参数 1 2 3 int main(int argc, char *argv[] ){ return 0; } argc 存放命令行参数的个数 *argv[] 从argv[1]开始存放每一个参数的指针，第一个即argv[0]存放程序名 多文件 构成 宏文件（xxx.h） 文件存放声明\nxxx.c 文件存放函数\n主函数里 #include\u0026quot;xxx.h\u0026quot;\n进阶语法 指针 结构体 结构体定义与初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 //一个完整结构体的example struct tag1{ int a; char b[30]; }variable1={1,\u0026#34;ssss\u0026#34;}; struct tag1 variable2; typedef struct{ float f; }tag2; tag2 variable3; ！！！注意！！！\n无论如何struct结尾必须有分号 typedef格式固定，下面不是变量而是标签 如果变量已经声明，就不能进行初始化 1 2 3 4 5 6 7 8 9 10 11 //无typedef时下面一定是变量（无标签） struct { int a; }VARIABLE; //下面一定是tag //tag 不能放上面 //实质 typedef struct{int a;} TAG; //类同 typedef unsigned char UC; typedef struct{ int a; }TAG; 结构体内部元素赋值 1 2 3 4 5 6 7 8 9 struct day{ char feeling[100]; int time; }today; today.time=222; strcpy(today.feeling,\u0026#34;dddd\u0026#34;); struct day yesterday={\u0026#34;good\u0026#34;,221}; 结构体指针 接着上文定义的结构体\n1 2 3 struct day *check; check=\u0026amp;today printf(\u0026#34;%s\u0026#34;,check-\u0026gt;feeling); 结构体数组 接着上文定义的结构体\n1 2 3 4 5 6 struct day holiday[60]; int i; for(i=0;i\u0026lt;60;i++){ strcpy(holiday[i].feeling,happy); holiday[i].time=i; } 枚举类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 enum week { MON=1, TUE, WED, THU, FRI, SAT, SUN }day; day=MON; printf(\u0026#34;%d\u0026#34;,day); //若不初始化MON，默认第一个是 0 //注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。 //如果我们把第3个枚举成员的值定义为 9，第4个就为 10，以此类推，第2个依然为1。 //可以和整形强制转化 int a=1; days=(enum week)a; //days=MON 动态内存 入门级基础算法 数学 求质数 了解朴素质数判定即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 朴素质数判定 /* 已经声明过 #define true 1 #define false 0 */ int check(int a){ if (a\u0026lt;2){ return false; } int i; for(i=2;i*i\u0026lt;a;i++){ if (a%i==0){ return false; } } return true; } 最大公约数\n了解欧几里得算法即可\n1 2 3 4 int gcd(int a,int b){ if (b==0) return a; return gcd(b, a % b); } 最小公倍数\n$lcm(a,b)gcd(a,b)=ab$\n先求出gcd即可\n高精度（了解加法减法即可）\n排序 稳定排序 不稳定排序 计数排序 桶排序 qsort() 双指针 同向 逆向 滑窗 ","date":"2023-04-26T00:00:00Z","image":"https://picx.zhimg.com/80/v2-905bb346af5546905d0eae5178eeb7ad_720w.webp?source=1940ef5c","permalink":"https://open17.github.io/CpHugo/p/cstart/","title":"C语言快速入门"},{"content":"a的b次方对p取模 前置知识 qpow math:$(a+b)%p=(a%p+b%p)%p$ code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 求 a的 b次方对 p取模的值。 // 输入格式 // 三个整数 a,b,p，在同一行用空格隔开。 // 输出格式 // 输出一个整数，表示a^b mod p的值。 // 数据范围 // 0≤a,b≤10^9 // 1≤p≤109 // 输入样例： // 3 2 7 // 输出样例： // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; // 防止当b=0，p=1时被卡 res=1%p; while(b){ if(b\u0026amp;1)res=(res*a)%p; a*=a; a%=p; b\u0026gt;\u0026gt;=1; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } a*b对p取模 前置知识 qpow math:(a+b)%p=(a%p+b%p)%p code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 求 a // 乘 b // 对 p // 取模的值。 // 输入格式 // 第一行输入整数a // ，第二行输入整数b // ，第三行输入整数p // 。 // 输出格式 // 输出一个整数，表示a*b mod p的值。 // 数据范围 // 1≤a,b,p≤1018 // 输入样例： // 3 // 4 // 5 // 输出样例： // 2 #include \u0026lt;iostream\u0026gt; using namespace std; typedef long long ll; int main(){ ll a,b,p,res=0; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;p; while(b){ if(b\u0026amp;1)res=(res+a)%p; b\u0026gt;\u0026gt;=1; a*=2; a%=p; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } 最短Hamilton路径 前置知识\n旅行商问题:NP完全,没有多项式时间解法 位运算 状压DP bitset:STL 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // 给定一张 n个点的带权无向图，点从 0∼n−1标号，求起点 0到终点 n−1的最短 Hamilton 路径。 // Hamilton 路径的定义是从 0到 n−1不重不漏地经过每个点恰好一次。输入格式 // 第一行输入整数 n。 // 接下来 n行每行 n个整数，其中第 i行第 j个整数表示点 i到 j的距离（记为 a[i,j]）。 // 对于任意的 x,y,z，数据保证 a[x,x]=0，a[x,y]=a[y,x]并且 a[x,y]+a[y,z]≥a[x,z]。 // 输出格式 // 输出一个整数，表示最短 Hamilton 路径的长度。 // 数据范围 // 1≤n≤20 // 0≤a[i,j]≤107 // 输入样例： // 5 // 0 2 4 5 1 // 2 0 6 5 3 // 4 6 0 8 3 // 5 5 8 0 5 // 1 3 3 5 0 // 输出样例： // 18 #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) #define inf 0x3f const int N=20,M=1\u0026lt;\u0026lt;20; int n; //大数组开到全局里，防止爆栈 //f[i][j]: i:经过状态，j:j点最短路 int f[M][N],w[N][N]; int main(){ cin\u0026gt;\u0026gt;n; For(i,0,n){ For(j,0,n){ cin\u0026gt;\u0026gt;w[i][j]; } } memset(f,inf,sizeof(f)); f[1][0]=0; For(i,0,1\u0026lt;\u0026lt;n){ For(j,0,n){ if(i\u0026gt;\u0026gt;j\u0026amp;1){ //int p=i^(1\u0026lt;\u0026lt;j) int p=i-(1\u0026lt;\u0026lt;j); For(k,0,n){ if(p\u0026amp;(1\u0026lt;\u0026lt;k)) // if(p\u0026gt;\u0026gt;k\u0026amp;1) f[i][j]=min(f[i][j],f[p][k]+w[k][j]); } } } } cout\u0026lt;\u0026lt;f[(1\u0026lt;\u0026lt;n)-1][n-1]\u0026lt;\u0026lt;endl; return 0; } 起床困难综合症 前置知识 位运算性质 :与或非运算在二进制表示下不进位，也就是说每个bit之间独立位运算 贪心 题目描述 21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 正是由于 drd 的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。 为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。 历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。 drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。\n具体说来，drd 的防御战线由 n扇防御门组成。 每扇防御门包括一个运算 op和一个参数 t ，其中运算一定是 OR,XOR,AND中的一种，参数则一定为非负整数。\n如果还未通过防御门时攻击力为 x 则其通过这扇防御门后攻击力将变为 x op t\n最终 drd 受到的伤害为对方初始攻击力 x 依次经过所有 n扇防御门后转变得到的攻击力。\n由于 atm 水平有限，他的初始攻击力只能为 0 到 m之间的一个整数（即他的初始攻击力只能在 0,1,…,m中任选， 但在通过防御门之后的攻击力不受 m的限制）。\n为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。\n输入格式 第 1行包含 2个整数，依次为 n,m，表示 drd 有 n扇防御门，atm 的初始攻击力为 0到 m之间的整数。\n接下来 n 行，依次表示每一扇防御门。每行包括一个字符串 op 和一个非负整数 t ，两者由一个空格隔开，且 op 在前，t 在后，op 表示该防御门所对应的操作，t 表示对应的参数。\n输出格式 输出一个整数，表示 atm 的一次攻击最多使 drd 受到多少伤害。\n数据范围 输入样例： 3 10\nAND 5\nOR 6\nXOR 7\n输出样例： 1\n样例解释 atm可以选择的初始攻击力为 0,1,…,10\n假设初始攻击力为 4，最终攻击力经过了如下计算\n4 AND 5 = 4\n4 OR 6 = 6 6 XOR 7 = 1 类似的，我们可以计算出初始攻击力为 1,3,5,7,9 时最终攻击力为 0 ，初始攻击力为 0,2,4,6,8,10 时最终攻击力为 1 ，因此 atm 的一次攻击最多使 drd 受到的伤害值为 1\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; #define For(a,b,c) for(int a=b;a\u0026lt;c;a++) const int N=1e6; vector\u0026lt;pair\u0026lt;string,int\u0026gt;\u0026gt; a(N); string op; int t; int n,m; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int change(int p,int q){ For(i,0,n){ int x=a[i].second\u0026gt;\u0026gt;p\u0026amp;1; if(a[i].first==\u0026#34;AND\u0026#34;)q\u0026amp;=x; else if(a[i].first==\u0026#34;OR\u0026#34;)q|=x; else {q^=x;} } return q; } int main(){ ios cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; For(i,0,n){ cin\u0026gt;\u0026gt;a[i].first; cin\u0026gt;\u0026gt;a[i].second; } int pre=0,aft=0; For(i,0,30){ int p=29-i; int pos1=change(p,0); int pos2=change(p,1); if(pre+(1\u0026lt;\u0026lt;p)\u0026lt;=m \u0026amp;\u0026amp; pos2\u0026gt;pos1){ pre+=1\u0026lt;\u0026lt;p; aft+=pos2\u0026lt;\u0026lt;p; } else aft+=pos1\u0026lt;\u0026lt;p; } cout\u0026lt;\u0026lt;aft\u0026lt;\u0026lt;endl; } XOR成对变换 1 2 3 4 if n\u0026amp;1: n^1==n-1 else: n^1==n+1 lowbit n\u0026amp;(-n)\n","date":"2023-04-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue01/","title":"小蓝书0X01位运算"},{"content":"激光炸弹 题目 地图上有 $N$ 个目标，用整数 $X_i,Y_i$ 表示目标在地图上的位置，每个目标都有一个价值 $W_i$。\n注意：不同目标可能在同一位置。\n现在有一种新型的激光炸弹，可以摧毁一个包含 $R \\times R$ 个位置的正方形内的所有目标。\n激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 $x,y$ 轴平行。\n求一颗炸弹最多能炸掉地图上总价值为多少的目标。\n输入格式\n第一行输入正整数 $N$ 和 $R$，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。\n接下来 $N$ 行，每行输入一组数据，每组数据包括三个整数 $X_i,Y_i,W_i$，分别代表目标的 $x$ 坐标，$y$ 坐标和价值，数据用空格隔开。\n输出格式\n输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。\n数据范围\n$0 \\le R \\le 10^9$\n$0 \u0026lt; N \\le 10^4, 0 \\le X_i, Y_i \\le 5000, 0 \\le W_i \\le 1000$\n输入样例：\n2 1\n0 0 1\n1 1 1\n输出样例：\n1\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5000+3; int b[N][N]; int main() { ios int r,x,y,w,t; cin\u0026gt;\u0026gt;t\u0026gt;\u0026gt;r; while(t--){ cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;w; //标准开大一格 b[x+1][y+1]+=w; } FOR(i,1,N) FOR(j,1,N) //题目卡内存，只能开一个数组，原地修改 b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+b[i][j]; int ans=0; // 注意细节 r=min(N-1,r); FOR(i,r,N){ FOR(j,r,N){ ans=max(b[i][j]-b[i-r][j]-b[i][j-r]+b[i-r][j-r],ans); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } IncDec序列 很多时候，我们将区间操作转换为差分序列的单点操作，以降低难度\n题目描述 给定一个长度为 $n$ 的数列 $a_1,a_2,\\dots,a_n$，每次可以选择一个区间 $[l,r]$，使下标在这个区间内的数都加一或者都减一。\n求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。\n输入格式\n第一行输入正整数 $n$。\n接下来 $n$ 行，每行输入一个整数，第 $i+1$ 行的整数代表 $a_i$。\n输出格式\n第一行输出最少操作次数。\n第二行输出最终能得到多少种结果。\n数据范围\n$0\u0026lt;n\\le 10^5$, $0\\le a_i\u0026lt;2^{31}$\n输入样例：\n4\n1\n1\n2\n2\n输出样例：\n1\n2\ntag 思维 贪心 code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=1e5+3; ll a[N]; int main() { ios int n; cin\u0026gt;\u0026gt;n; FOR(i,1,n+1){ cin\u0026gt;\u0026gt;a[i]; } // 注意这里倒着 for(int i=n;i\u0026gt;0;i--)a[i]-=a[i-1]; ll cnt=0,cnt2=0; FOR(i,2,n+1){ if(a[i]\u0026gt;0)cnt+=a[i]; else cnt2-=a[i]; } cout\u0026lt;\u0026lt;max(cnt,cnt2)\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; cout\u0026lt;\u0026lt;abs(cnt2-cnt)+1\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; return 0; } 最高的牛 题目 有 N 头牛站成一行，被编队为 1、2、3…N，每头牛的身高都为整数。\n当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。\n现在，我们只知道其中最高的牛是第 P 头，它的身高是 H，剩余牛的身高未知。\n但是，我们还知道这群牛之中存在着 M 对关系，每对关系都指明了某两头牛 A 和 B 可以相互看见。\n求每头牛的身高的最大可能值是多少。\n输入格式\n第一行输入整数 N,P,H,M，数据用空格隔开。\n接下来 M 行，每行输出两个整数 A 和 B，代表牛 A 和牛 B 可以相互看见，数据用空格隔开。\n输出格式\n一共输出 N 行数据，每行输出一个整数。\n第 i 行输出的整数代表第 i 头牛可能的最大身高。\n数据范围\n$1≤N≤5000$，$1≤H≤1000000$，$1≤A,B≤10000$，$0≤M≤10000$\n输入样例：\n1 2 3 4 5 6 9 3 5 5 1 3 5 3 4 3 3 7 9 8 输出样例：\n1 2 3 4 5 6 7 8 9 5 4 5 3 4 4 5 5 5 注意：此题中给出的关系对可能存在重复。\ncode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ios ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); #define FOR(w, a, n) for(int w=(a);w\u0026lt;(n);++w) #define inf 0x3f typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=5000+3; set\u0026lt;pii\u0026gt; used; int d[N]; int main() { ios int n,p,h,m,a,b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;p\u0026gt;\u0026gt;h\u0026gt;\u0026gt;m; while(m--){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(a\u0026gt;b)swap(a,b); if(used.count(make_pair(a,b)))continue; d[a+1]--; d[b]++; used.insert(make_pair(a,b)); } d[0]=h; FOR(i,1,n+1){ d[i]+=d[i-1]; cout\u0026lt;\u0026lt;d[i]\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } ","date":"2023-04-26T00:00:00Z","permalink":"https://open17.github.io/CpHugo/p/blue03/","title":"小蓝书0X03前缀和与差分"}]